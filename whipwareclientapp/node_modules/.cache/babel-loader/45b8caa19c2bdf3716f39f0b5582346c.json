{"ast":null,"code":"/*\r\njQWidgets v9.0.0 (2020-Jan)\r\nCopyright (c) 2011-2020 jQWidgets.\r\nLicense: https://jqwidgets.com/license/\r\n*/\n\n/* eslint-disable */\n(function (a) {\n  a.jqx.jqxWidget(\"jqxChart\", \"\", {});\n  a.extend(a.jqx._jqxChart.prototype, {\n    defineInstance: function defineInstance() {\n      a.extend(true, this, this._defaultSettings);\n\n      this._createColorsCache();\n\n      return this._defaultSettings;\n    },\n    _defaultSettings: {\n      title: \"Title\",\n      description: \"Description\",\n      source: [],\n      seriesGroups: [],\n      categoryAxis: null,\n      xAxis: {},\n      valueAxis: null,\n      renderEngine: \"\",\n      enableAnimations: true,\n      enableAxisTextAnimation: false,\n      backgroundImage: \"\",\n      background: \"#FFFFFF\",\n      padding: {\n        left: 5,\n        top: 5,\n        right: 5,\n        bottom: 5\n      },\n      backgroundColor: \"#FFFFFF\",\n      showBorderLine: true,\n      borderLineWidth: 1,\n      borderLineColor: null,\n      borderColor: null,\n      titlePadding: {\n        left: 5,\n        top: 5,\n        right: 5,\n        bottom: 10\n      },\n      showLegend: true,\n      legendLayout: null,\n      enabled: true,\n      colorScheme: \"scheme01\",\n      animationDuration: 500,\n      showToolTips: true,\n      showToolTipsOnAllSeries: false,\n      toolTipShowDelay: 300,\n      toolTipDelay: 500,\n      toolTipHideDelay: 4000,\n      toolTipMoveDuration: 300,\n      toolTipFormatFunction: null,\n      toolTipAlignment: \"dataPoint\",\n      localization: null,\n      columnSeriesOverlap: false,\n      rtl: false,\n      legendPosition: null,\n      greyScale: false,\n      axisPadding: 5,\n      enableCrosshairs: false,\n      crosshairsColor: \"#BCBCBC\",\n      crosshairsDashStyle: \"2,2\",\n      crosshairsLineWidth: 1,\n      enableEvents: true,\n      _itemsToggleState: [],\n      _isToggleRefresh: false,\n      _isSelectorRefresh: false,\n      _sliders: [],\n      _selectorRange: [],\n      _rangeSelectorInstances: {},\n      _resizeState: {},\n      renderer: null,\n      _isRangeSelectorInstance: false,\n      drawBefore: null,\n      draw: null,\n      _renderData: {},\n      enableSampling: true\n    },\n    _defaultLineColor: \"#BCBCBC\",\n    _touchEvents: {\n      mousedown: a.jqx.mobile.getTouchEventName(\"touchstart\"),\n      click: a.jqx.mobile.getTouchEventName(\"touchstart\"),\n      mouseup: a.jqx.mobile.getTouchEventName(\"touchend\"),\n      mousemove: a.jqx.mobile.getTouchEventName(\"touchmove\"),\n      mouseenter: \"mouseenter\",\n      mouseleave: \"mouseleave\"\n    },\n    _getEvent: function _getEvent(b) {\n      if (this._isTouchDevice) {\n        return this._touchEvents[b];\n      } else {\n        return b;\n      }\n    },\n    destroy: function destroy() {\n      this.host.remove();\n    },\n    _jqxPlot: null,\n    createInstance: function createInstance(d) {\n      if (!a.jqx.dataAdapter) {\n        throw \"jqxdata.js is not loaded\";\n      }\n\n      var c = this;\n\n      c._refreshOnDownloadComlete();\n\n      c._isTouchDevice = a.jqx.mobile.isTouchDevice();\n\n      if (!c._jqxPlot) {\n        c._jqxPlot = new jqxPlot();\n      }\n\n      c.addHandler(c.host, c._getEvent(\"mousemove\"), function (g) {\n        if (c.enabled == false) {\n          return;\n        }\n\n        if (!c._isRangeSelectorInstance) {\n          c.host.css(\"cursor\", \"default\");\n        }\n\n        var f = g.pageX || g.clientX || g.screenX;\n        var j = g.pageY || g.clientY || g.screenY;\n        var i = c.host.offset();\n\n        if (c._isTouchDevice) {\n          var h = a.jqx.position(g);\n          f = h.left;\n          j = h.top;\n        }\n\n        f -= i.left;\n        j -= i.top;\n        c.onmousemove(f, j);\n      });\n      c.addHandler(c.host, c._getEvent(\"mouseleave\"), function (h) {\n        if (c.enabled == false) {\n          return;\n        }\n\n        var f = c._mouseX;\n        var i = c._mouseY;\n        var g = c._plotRect;\n\n        if (g && f >= g.x && f <= g.x + g.width && i >= g.y && i <= g.y + g.height) {\n          return;\n        }\n\n        c._cancelTooltipTimer();\n\n        c._hideToolTip(0);\n\n        c._unselect();\n      });\n      c.addHandler(c.host, \"click\", function (g) {\n        if (c.enabled == false) {\n          return;\n        }\n\n        var f = g.pageX || g.clientX || g.screenX;\n        var j = g.pageY || g.clientY || g.screenY;\n        var i = c.host.offset();\n\n        if (c._isTouchDevice) {\n          var h = a.jqx.position(g);\n          f = h.left;\n          j = h.top;\n        }\n\n        f -= i.left;\n        j -= i.top;\n        c._mouseX = f;\n        c._mouseY = j;\n\n        if (!isNaN(c._lastClickTs)) {\n          if (new Date().valueOf() - c._lastClickTs < 100) {\n            return;\n          }\n        }\n\n        this._hostClickTimer = setTimeout(function () {\n          if (!c._isTouchDevice) {\n            c._cancelTooltipTimer();\n\n            c._hideToolTip();\n\n            c._unselect();\n          }\n\n          if (c._pointMarker && c._pointMarker.element) {\n            var l = c.seriesGroups[c._pointMarker.gidx];\n            var k = l.series[c._pointMarker.sidx];\n            g.stopImmediatePropagation();\n\n            c._raiseItemEvent(\"click\", l, k, c._pointMarker.iidx);\n          }\n        }, 100);\n      });\n      var e = c.element.style;\n\n      if (e) {\n        var b = false;\n\n        if (e.width != null) {\n          b |= e.width.toString().indexOf(\"%\") != -1;\n        }\n\n        if (e.height != null) {\n          b |= e.height.toString().indexOf(\"%\") != -1;\n        }\n\n        if (b) {\n          a.jqx.utilities.resize(this.host, function () {\n            if (c.timer) {\n              clearTimeout(c.timer);\n            }\n\n            var f = 1;\n            c.timer = setTimeout(function () {\n              var g = c.enableAnimations;\n              c.enableAnimations = false;\n              c.refresh();\n              c.enableAnimations = g;\n            }, f);\n          }, false, true);\n        }\n      }\n    },\n    _refreshOnDownloadComlete: function _refreshOnDownloadComlete() {\n      var d = this;\n      var e = this.source;\n\n      if (e instanceof a.jqx.dataAdapter) {\n        var f = e._options;\n\n        if (f == undefined || f != undefined && !f.autoBind) {\n          e.autoSync = false;\n          e.dataBind();\n        }\n\n        var c = this.element.id;\n\n        if (e.records.length == 0) {\n          var b = function b() {\n            if (d.ready) {\n              d.ready();\n            }\n\n            d.refresh();\n          };\n\n          e.unbindDownloadComplete(c);\n          e.bindDownloadComplete(c, b);\n        } else {\n          if (d.ready) {\n            d.ready();\n          }\n        }\n\n        e.unbindBindingUpdate(c);\n        e.bindBindingUpdate(c, function () {\n          if (d._supressBindingRefresh) {\n            return;\n          }\n\n          d.refresh();\n        });\n      }\n    },\n    propertyChangedHandler: function propertyChangedHandler(b, c, e, d) {\n      if (this.isInitialized == undefined || this.isInitialized == false) {\n        return;\n      }\n\n      if (c == \"source\") {\n        this._refreshOnDownloadComlete();\n      }\n\n      this.refresh();\n    },\n    _initRenderer: function _initRenderer(b) {\n      if (!a.jqx.createRenderer) {\n        throw \"Please include jqxdraw.js\";\n      }\n\n      return a.jqx.createRenderer(this, b);\n    },\n    _internalRefresh: function _internalRefresh() {\n      var b = this;\n\n      if (a.jqx.isHidden(b.host)) {\n        return;\n      }\n\n      b._stopAnimations();\n\n      if (!b.renderer || !b._isToggleRefresh && !b._isUpdate) {\n        b._hideToolTip(0);\n\n        b._isVML = false;\n        b.host.empty();\n        b._measureDiv = undefined;\n\n        b._initRenderer(b.host);\n      }\n\n      var d = b.renderer;\n\n      if (!d) {\n        return;\n      }\n\n      var c = d.getRect();\n\n      b._render({\n        x: 1,\n        y: 1,\n        width: c.width,\n        height: c.height\n      });\n\n      this._raiseEvent(\"refreshBegin\", {\n        instance: this\n      });\n\n      if (d instanceof a.jqx.HTML5Renderer) {\n        d.refresh();\n      }\n\n      b._isUpdate = false;\n\n      this._raiseEvent(\"refreshEnd\", {\n        instance: this\n      });\n    },\n    saveAsPNG: function saveAsPNG(d, b, c) {\n      return this._saveAsImage(\"png\", d, b, c);\n    },\n    saveAsJPEG: function saveAsJPEG(d, b, c) {\n      return this._saveAsImage(\"jpeg\", d, b, c);\n    },\n    saveAsPDF: function saveAsPDF(d, b, c) {\n      return this._saveAsImage(\"pdf\", d, b, c);\n    },\n    _saveAsImage: function _saveAsImage(e, h, b, c) {\n      var g = false;\n\n      for (var d = 0; d < this.seriesGroups.length && !g; d++) {\n        var f = this._getXAxis(d);\n\n        if (f && f.rangeSelector) {\n          g = true;\n        }\n      }\n\n      return a.jqx._widgetToImage(this, e, h, b, c, g ? this._selectorSaveAsImageCallback : undefined);\n    },\n    _selectorSaveAsImageCallback: function _selectorSaveAsImageCallback(B, h) {\n      var r = B;\n\n      for (var z = 0; z < r.seriesGroups.length; z++) {\n        var o = r._getXAxis(z);\n\n        if (!o || !o.rangeSelector || o.rangeSelector.renderTo) {\n          continue;\n        }\n\n        var m = r._rangeSelectorInstances[z];\n\n        if (!m) {\n          continue;\n        }\n\n        var s = m.jqxChart(\"getInstance\");\n        var e = s.renderEngine;\n        var d = s.renderer.getRect();\n        var f = s.renderer.getContainer().find(\"canvas\")[0];\n        var p = f.getContext(\"2d\");\n        var w = r._sliders[z];\n        var b = r.seriesGroups[z].orientation == \"horizontal\";\n        var c = !b ? \"width\" : \"height\";\n        var v = b ? \"width\" : \"height\";\n        var y = !b ? \"x\" : \"y\";\n        var g = b ? \"x\" : \"y\";\n        var k = {};\n        k[y] = w.startOffset + w.rect[y];\n        k[g] = w.rect[g];\n        k[c] = w.endOffset - w.startOffset;\n        k[v] = w.rect[v];\n        var n = o.rangeSelector.colorSelectedRange || \"blue\";\n        var u = o.rangeSelector.colorUnselectedRange || \"white\";\n        var l = o.rangeSelector.colorRangeLine || \"grey\";\n        var q = [];\n        q.push(s.renderer.rect(k.x, k.y, k.width, k.height, {\n          fill: n,\n          opacity: 0.1\n        }));\n\n        if (!b) {\n          q.push(s.renderer.line(a.jqx._ptrnd(w.rect.x), a.jqx._ptrnd(w.rect.y), a.jqx._ptrnd(k.x), a.jqx._ptrnd(w.rect.y), {\n            stroke: l,\n            opacity: 0.5\n          }));\n          q.push(s.renderer.line(a.jqx._ptrnd(k.x + k.width), a.jqx._ptrnd(w.rect.y), a.jqx._ptrnd(w.rect.x + w.rect.width), a.jqx._ptrnd(w.rect.y), {\n            stroke: l,\n            opacity: 0.5\n          }));\n          q.push(s.renderer.line(a.jqx._ptrnd(k.x), a.jqx._ptrnd(w.rect.y), a.jqx._ptrnd(k.x), a.jqx._ptrnd(w.rect.y + w.rect.height), {\n            stroke: l,\n            opacity: 0.5\n          }));\n          q.push(s.renderer.line(a.jqx._ptrnd(k.x + k.width), a.jqx._ptrnd(w.rect.y), a.jqx._ptrnd(k.x + k.width), a.jqx._ptrnd(w.rect.y + w.rect.height), {\n            stroke: l,\n            opacity: 0.5\n          }));\n        } else {\n          q.push(s.renderer.line(a.jqx._ptrnd(w.rect.x + w.rect.width), a.jqx._ptrnd(w.rect.y), a.jqx._ptrnd(w.rect.x + w.rect.width), a.jqx._ptrnd(k.y), {\n            stroke: l,\n            opacity: 0.5\n          }));\n          q.push(s.renderer.line(a.jqx._ptrnd(w.rect.x + w.rect.width), a.jqx._ptrnd(k.y + k.height), a.jqx._ptrnd(w.rect.x + w.rect.width), a.jqx._ptrnd(w.rect.y + w.rect.height), {\n            stroke: l,\n            opacity: 0.5\n          }));\n          q.push(s.renderer.line(a.jqx._ptrnd(w.rect.x), a.jqx._ptrnd(k.y), a.jqx._ptrnd(w.rect.x + w.rect.width), a.jqx._ptrnd(k.y), {\n            stroke: l,\n            opacity: 0.5\n          }));\n          q.push(s.renderer.line(a.jqx._ptrnd(w.rect.x), a.jqx._ptrnd(k.y + k.height), a.jqx._ptrnd(w.rect.x + w.rect.width), a.jqx._ptrnd(k.y + k.height), {\n            stroke: l,\n            opacity: 0.5\n          }));\n        }\n\n        s.renderer.refresh();\n        var t = p.getImageData(d.x, d.y, d.width, d.height);\n        var A = h.getContext(\"2d\");\n        A.putImageData(t, parseInt(m.css(\"left\")), parseInt(m.css(\"top\")), 1, 1, d.width, d.height);\n\n        for (var x = 0; x < q.length; x++) {\n          s.renderer.removeElement(q[x]);\n        }\n\n        s.renderer.refresh();\n      }\n\n      return true;\n    },\n    refresh: function refresh() {\n      this._internalRefresh();\n    },\n    update: function update() {\n      this._isUpdate = true;\n\n      this._internalRefresh();\n    },\n    _seriesTypes: [\"line\", \"stackedline\", \"stackedline100\", \"spline\", \"stackedspline\", \"stackedspline100\", \"stepline\", \"stackedstepline\", \"stackedstepline100\", \"area\", \"stackedarea\", \"stackedarea100\", \"splinearea\", \"stackedsplinearea\", \"stackedsplinearea100\", \"steparea\", \"stackedsteparea\", \"stackedsteparea100\", \"rangearea\", \"splinerangearea\", \"steprangearea\", \"column\", \"stackedcolumn\", \"stackedcolumn100\", \"rangecolumn\", \"scatter\", \"stackedscatter\", \"stackedscatter100\", \"bubble\", \"stackedbubble\", \"stackedbubble100\", \"pie\", \"donut\", \"candlestick\", \"ohlc\", \"waterfall\", \"stackedwaterfall\"],\n    clear: function clear() {\n      var b = this;\n\n      for (var c in b._defaultSettings) {\n        b[c] = b._defaultSettings[c];\n      }\n\n      b.title = \"\";\n      b.description = \"\";\n      b.refresh();\n    },\n    _validateSeriesGroups: function _validateSeriesGroups() {\n      if (!a.isArray(this.seriesGroups)) {\n        throw \"Invalid property: 'seriesGroups' property is required and must be a valid array.\";\n      }\n\n      for (var b = 0; b < this.seriesGroups.length; b++) {\n        var c = this.seriesGroups[b];\n\n        if (!c.type) {\n          throw \"Invalid property: Each series group must have a valid 'type' property.\";\n        }\n\n        if (!a.isArray(c.series)) {\n          throw \"Invalid property: Each series group must have a 'series' property which must be a valid array.\";\n        }\n      }\n    },\n    _render: function _render(C) {\n      var m = this;\n      var I = m.renderer;\n\n      m._validateSeriesGroups();\n\n      m._colorsCache.clear();\n\n      if (!m._isToggleRefresh && m._isUpdate && m._renderData) {\n        m._renderDataClone();\n      }\n\n      m._renderData = [];\n      I.clear();\n\n      m._unselect();\n\n      m._hideToolTip(0);\n\n      var n = m.backgroundImage;\n\n      if (n == undefined || n == \"\") {\n        m.host.css({\n          \"background-image\": \"\"\n        });\n      } else {\n        m.host.css({\n          \"background-image\": n.indexOf(\"(\") != -1 ? n : \"url('\" + n + \"')\"\n        });\n      }\n\n      m._rect = C;\n      var Y = m.padding || {\n        left: 5,\n        top: 5,\n        right: 5,\n        bottom: 5\n      };\n      var q = I.createClipRect(C);\n      var L = I.beginGroup();\n      I.setClip(L, q);\n      var ai = I.rect(C.x, C.y, C.width - 2, C.height - 2);\n\n      if (n == undefined || n == \"\") {\n        I.attr(ai, {\n          fill: m.backgroundColor || m.background || \"white\"\n        });\n      } else {\n        I.attr(ai, {\n          fill: \"transparent\"\n        });\n      }\n\n      if (m.showBorderLine != false) {\n        var F = m.borderLineColor == undefined ? m.borderColor : m.borderLineColor;\n\n        if (F == undefined) {\n          F = m._defaultLineColor;\n        }\n\n        var o = this.borderLineWidth;\n\n        if (isNaN(o) || o < 0 || o > 10) {\n          o = 1;\n        }\n\n        I.attr(ai, {\n          \"stroke-width\": o,\n          stroke: F\n        });\n      } else {\n        if (a.jqx.browser.msie && a.jqx.browser.version < 9) {\n          I.attr(ai, {\n            \"stroke-width\": 1,\n            stroke: m.backgroundColor || \"white\"\n          });\n        }\n      }\n\n      if (a.isFunction(m.drawBefore)) {\n        m.drawBefore(I, C);\n      }\n\n      var V = {\n        x: Y.left,\n        y: Y.top,\n        width: C.width - Y.left - Y.right,\n        height: C.height - Y.top - Y.bottom\n      };\n      m._paddedRect = V;\n      var e = m.titlePadding || {\n        left: 2,\n        top: 2,\n        right: 2,\n        bottom: 2\n      };\n      var l;\n\n      if (m.title && m.title.length > 0) {\n        var S = m.toThemeProperty(\"jqx-chart-title-text\", null);\n        l = I.measureText(m.title, 0, {\n          \"class\": S\n        });\n        I.text(m.title, V.x + e.left, V.y + e.top, V.width - (e.left + e.right), l.height, 0, {\n          \"class\": S\n        }, true, \"center\", \"center\");\n        V.y += l.height;\n        V.height -= l.height;\n      }\n\n      if (m.description && m.description.length > 0) {\n        var T = m.toThemeProperty(\"jqx-chart-title-description\", null);\n        l = I.measureText(m.description, 0, {\n          \"class\": T\n        });\n        I.text(m.description, V.x + e.left, V.y + e.top, V.width - (e.left + e.right), l.height, 0, {\n          \"class\": T\n        }, true, \"center\", \"center\");\n        V.y += l.height;\n        V.height -= l.height;\n      }\n\n      if (m.title || m.description) {\n        V.y += e.bottom + e.top;\n        V.height -= e.bottom + e.top;\n      }\n\n      var b = {\n        x: V.x,\n        y: V.y,\n        width: V.width,\n        height: V.height\n      };\n      m._plotRect = b;\n\n      m._buildStats(b);\n\n      var H = m._isPieOnlySeries();\n\n      var s = m.seriesGroups;\n      var E;\n      var D = {\n        xAxis: {},\n        valueAxis: {}\n      };\n\n      for (var Z = 0; Z < s.length && !H; Z++) {\n        if (s[Z].type == \"pie\" || s[Z].type == \"donut\") {\n          continue;\n        }\n\n        var z = m._getXAxis(Z);\n\n        if (!z) {\n          throw \"seriesGroup[\" + Z + \"] is missing xAxis definition\";\n        }\n\n        var ae = z == m._getXAxis() ? -1 : Z;\n        D.xAxis[ae] = 0;\n      }\n\n      var U = m.axisPadding;\n\n      if (isNaN(U)) {\n        U = 5;\n      }\n\n      var r = {\n        left: 0,\n        right: 0,\n        leftCount: 0,\n        rightCount: 0\n      };\n      var p = [];\n\n      for (Z = 0; Z < s.length; Z++) {\n        var ad = s[Z];\n\n        if (ad.type == \"pie\" || ad.type == \"donut\" || ad.spider == true || ad.polar == true) {\n          p.push({\n            width: 0,\n            position: 0,\n            xRel: 0\n          });\n          continue;\n        }\n\n        E = ad.orientation == \"horizontal\";\n\n        var z = m._getXAxis(Z);\n\n        var ae = z == m._getXAxis() ? -1 : Z;\n\n        var k = m._getValueAxis(Z);\n\n        var O = k == m._getValueAxis() ? -1 : Z;\n        var R = !E ? k.axisSize : z.axisSize;\n        var f = {\n          x: 0,\n          y: b.y,\n          width: b.width,\n          height: b.height\n        };\n        var Q = E ? m._getXAxis(Z).position : k.position;\n\n        if (!R || R == \"auto\") {\n          if (E) {\n            R = this._renderXAxis(Z, f, true, b).width;\n\n            if ((D.xAxis[ae] & 1) == 1) {\n              R = 0;\n            } else {\n              if (R > 0) {\n                D.xAxis[ae] |= 1;\n              }\n            }\n          } else {\n            R = m._renderValueAxis(Z, f, true, b).width;\n\n            if ((D.valueAxis[O] & 1) == 1) {\n              R = 0;\n            } else {\n              if (R > 0) {\n                D.valueAxis[O] |= 1;\n              }\n            }\n          }\n        }\n\n        if (Q != \"left\" && m.rtl == true) {\n          Q = \"right\";\n        }\n\n        if (Q != \"right\") {\n          Q = \"left\";\n        }\n\n        if (r[Q + \"Count\"] > 0 && r[Q] > 0 && R > 0) {\n          r[Q] += U;\n        }\n\n        p.push({\n          width: R,\n          position: Q,\n          xRel: r[Q]\n        });\n        r[Q] += R;\n        r[Q + \"Count\"]++;\n      }\n\n      var u = Math.max(1, Math.max(C.width, C.height));\n      var ac = {\n        top: 0,\n        bottom: 0,\n        topCount: 0,\n        bottomCount: 0\n      };\n      var W = [];\n\n      for (Z = 0; Z < s.length; Z++) {\n        var ad = s[Z];\n\n        if (ad.type == \"pie\" || ad.type == \"donut\" || ad.spider == true || ad.polar == true) {\n          W.push({\n            height: 0,\n            position: 0,\n            yRel: 0\n          });\n          continue;\n        }\n\n        E = ad.orientation == \"horizontal\";\n\n        var k = this._getValueAxis(Z);\n\n        var O = k == m._getValueAxis() ? -1 : Z;\n\n        var z = m._getXAxis(Z);\n\n        var ae = z == m._getXAxis() ? -1 : Z;\n        var ab = !E ? z.axisSize : k.axisSize;\n        var Q = E ? k.position : z.position;\n\n        if (!ab || ab == \"auto\") {\n          if (E) {\n            ab = m._renderValueAxis(Z, {\n              x: 0,\n              y: 0,\n              width: u,\n              height: 0\n            }, true, b).height;\n\n            if ((D.valueAxis[O] & 2) == 2) {\n              ab = 0;\n            } else {\n              if (ab > 0) {\n                D.valueAxis[O] |= 2;\n              }\n            }\n          } else {\n            ab = m._renderXAxis(Z, {\n              x: 0,\n              y: 0,\n              width: u,\n              height: 0\n            }, true).height;\n\n            if ((D.xAxis[ae] & 2) == 2) {\n              ab = 0;\n            } else {\n              if (ab > 0) {\n                D.xAxis[ae] |= 2;\n              }\n            }\n          }\n        }\n\n        if (Q != \"top\") {\n          Q = \"bottom\";\n        }\n\n        if (ac[Q + \"Count\"] > 0 && ac[Q] > 0 && ab > 0) {\n          ac[Q] += U;\n        }\n\n        W.push({\n          height: ab,\n          position: Q,\n          yRel: ac[Q]\n        });\n        ac[Q] += ab;\n        ac[Q + \"Count\"]++;\n      }\n\n      m._createAnimationGroup(\"series\");\n\n      var t = m.showLegend != false;\n      var B = !t ? {\n        width: 0,\n        height: 0\n      } : m._renderLegend(m.legendLayout ? m._rect : V, true);\n\n      if (this.legendLayout && (!isNaN(this.legendLayout.left) || !isNaN(this.legendLayout.top))) {\n        B = {\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (V.height < ac.top + ac.bottom + B.height || V.width < r.left + r.right) {\n        I.endGroup();\n        return;\n      }\n\n      b.height -= ac.top + ac.bottom + B.height;\n      b.x += r.left;\n      b.width -= r.left + r.right;\n      b.y += ac.top;\n      var G = [];\n\n      if (!H) {\n        var af = m._getXAxis().tickMarksColor || m._defaultLineColor;\n\n        for (Z = 0; Z < s.length; Z++) {\n          var ad = s[Z];\n\n          if (ad.polar == true || ad.spider == true || ad.type == \"pie\" || ad.type == \"donut\") {\n            continue;\n          }\n\n          E = ad.orientation == \"horizontal\";\n          var ae = m._getXAxis(Z) == m._getXAxis() ? -1 : Z;\n          var O = m._getValueAxis(Z) == m._getValueAxis() ? -1 : Z;\n          var f = {\n            x: b.x,\n            y: 0,\n            width: b.width,\n            height: W[Z].height\n          };\n\n          if (W[Z].position != \"top\") {\n            f.y = b.y + b.height + W[Z].yRel;\n          } else {\n            f.y = b.y - W[Z].yRel - W[Z].height;\n          }\n\n          if (E) {\n            if ((D.valueAxis[O] & 4) == 4) {\n              continue;\n            }\n\n            if (!m._isGroupVisible(Z)) {\n              continue;\n            }\n\n            m._renderValueAxis(Z, f, false, b);\n\n            D.valueAxis[O] |= 4;\n          } else {\n            G.push(f);\n\n            if ((D.xAxis[ae] & 4) == 4) {\n              continue;\n            }\n\n            if (!m._isGroupVisible(Z)) {\n              continue;\n            }\n\n            m._renderXAxis(Z, f, false, b);\n\n            D.xAxis[ae] |= 4;\n          }\n        }\n      }\n\n      if (t) {\n        var A = m.legendLayout ? m._rect : V;\n\n        var P = V.x + a.jqx._ptrnd((V.width - B.width) / 2);\n\n        var N = b.y + b.height + ac.bottom;\n        var R = V.width;\n        var ab = B.height;\n\n        if (m.legendLayout) {\n          if (!isNaN(m.legendLayout.left)) {\n            P = m.legendLayout.left;\n          }\n\n          if (!isNaN(m.legendLayout.top)) {\n            N = m.legendLayout.top;\n          }\n\n          if (!isNaN(m.legendLayout.width)) {\n            R = m.legendLayout.width;\n          }\n\n          if (!isNaN(m.legendLayout.height)) {\n            ab = m.legendLayout.height;\n          }\n        }\n\n        if (P + R > A.x + A.width) {\n          R = A.x + A.width - P;\n        }\n\n        if (N + ab > A.y + A.height) {\n          ab = A.y + A.height - N;\n        }\n\n        m._renderLegend({\n          x: P,\n          y: N,\n          width: R,\n          height: ab\n        });\n      }\n\n      m._hasHorizontalLines = false;\n\n      if (!H) {\n        for (Z = 0; Z < s.length; Z++) {\n          var ad = s[Z];\n\n          if (ad.polar == true || ad.spider == true || ad.type == \"pie\" || ad.type == \"donut\") {\n            continue;\n          }\n\n          E = s[Z].orientation == \"horizontal\";\n          var f = {\n            x: b.x - p[Z].xRel - p[Z].width,\n            y: b.y,\n            width: p[Z].width,\n            height: b.height\n          };\n\n          if (p[Z].position != \"left\") {\n            f.x = b.x + b.width + p[Z].xRel;\n          }\n\n          var ae = m._getXAxis(Z) == m._getXAxis() ? -1 : Z;\n          var O = m._getValueAxis(Z) == m._getValueAxis() ? -1 : Z;\n\n          if (E) {\n            G.push(f);\n\n            if ((D.xAxis[ae] & 8) == 8) {\n              continue;\n            }\n\n            if (!m._isGroupVisible(Z)) {\n              continue;\n            }\n\n            m._renderXAxis(Z, f, false, b);\n\n            D.xAxis[ae] |= 8;\n          } else {\n            if ((D.valueAxis[O] & 8) == 8) {\n              continue;\n            }\n\n            if (!m._isGroupVisible(Z)) {\n              continue;\n            }\n\n            m._renderValueAxis(Z, f, false, b);\n\n            D.valueAxis[O] |= 8;\n          }\n        }\n      }\n\n      if (b.width <= 0 || b.height <= 0) {\n        return;\n      }\n\n      m._plotRect = {\n        x: b.x,\n        y: b.y,\n        width: b.width,\n        height: b.height\n      };\n\n      for (Z = 0; Z < s.length; Z++) {\n        this._drawPlotAreaLines(Z, true, {\n          gridLines: false,\n          tickMarks: false,\n          alternatingBackground: true\n        });\n\n        this._drawPlotAreaLines(Z, false, {\n          gridLines: false,\n          tickMarks: false,\n          alternatingBackground: true\n        });\n      }\n\n      for (Z = 0; Z < s.length; Z++) {\n        this._drawPlotAreaLines(Z, true, {\n          gridLines: true,\n          tickMarks: true,\n          alternatingBackground: false\n        });\n\n        this._drawPlotAreaLines(Z, false, {\n          gridLines: true,\n          tickMarks: true,\n          alternatingBackground: false\n        });\n      }\n\n      var K = false;\n\n      for (Z = 0; Z < s.length && !K; Z++) {\n        var ad = s[Z];\n\n        if (ad.annotations !== undefined || a.isFunction(ad.draw) || a.isFunction(ad.drawBefore)) {\n          K = true;\n          break;\n        }\n      }\n\n      var M = I.beginGroup();\n\n      if (!K) {\n        var J = I.createClipRect({\n          x: b.x - 2,\n          y: b.y,\n          width: b.width + 4,\n          height: b.height\n        });\n        I.setClip(M, J);\n      }\n\n      for (Z = 0; Z < s.length; Z++) {\n        var ad = s[Z];\n        var c = false;\n\n        for (var ag in m._seriesTypes) {\n          if (m._seriesTypes[ag] == ad.type) {\n            c = true;\n            break;\n          }\n        }\n\n        if (!c) {\n          throw 'Invalid serie type \"' + ad.type + '\"';\n        }\n\n        if (a.isFunction(ad.drawBefore)) {\n          ad.drawBefore(I, C, Z, this);\n        }\n\n        if (ad.polar == true || ad.spider == true) {\n          if (ad.type.indexOf(\"pie\") == -1 && ad.type.indexOf(\"donut\") == -1) {\n            m._renderSpiderAxis(Z, b);\n          }\n        }\n\n        m._renderAxisBands(Z, b, true);\n\n        m._renderAxisBands(Z, b, false);\n      }\n\n      for (Z = 0; Z < s.length; Z++) {\n        var ad = s[Z];\n\n        if (m._isColumnType(ad.type)) {\n          m._renderColumnSeries(Z, b);\n        } else {\n          if (ad.type.indexOf(\"pie\") != -1 || ad.type.indexOf(\"donut\") != -1) {\n            m._renderPieSeries(Z, b);\n          } else {\n            if (ad.type.indexOf(\"line\") != -1 || ad.type.indexOf(\"area\") != -1) {\n              m._renderLineSeries(Z, b);\n            } else {\n              if (ad.type.indexOf(\"scatter\") != -1 || ad.type.indexOf(\"bubble\") != -1) {\n                m._renderScatterSeries(Z, b);\n              } else {\n                if (ad.type.indexOf(\"candlestick\") != -1 || ad.type.indexOf(\"ohlc\") != -1) {\n                  m._renderCandleStickSeries(Z, b, ad.type.indexOf(\"ohlc\") != -1);\n                }\n              }\n            }\n          }\n        }\n\n        if (ad.annotations) {\n          if (!this._moduleAnnotations) {\n            throw \"Please include 'jqxchart.annotations.js'\";\n          }\n\n          for (var X = 0; X < ad.annotations.length; X++) {\n            m._renderAnnotation(Z, ad.annotations[X], b);\n          }\n        }\n\n        if (a.isFunction(ad.draw)) {\n          m.draw(I, C, Z, this);\n        }\n      }\n\n      I.endGroup();\n\n      if (m.enabled == false) {\n        var aa = I.rect(C.x, C.y, C.width, C.height);\n        I.attr(aa, {\n          fill: \"#777777\",\n          opacity: 0.5,\n          stroke: \"#00FFFFFF\"\n        });\n      }\n\n      if (a.isFunction(m.draw)) {\n        m.draw(I, C);\n      }\n\n      I.endGroup();\n\n      m._startAnimation(\"series\");\n\n      if (m._credits) {\n        m._credits();\n      }\n\n      var ah = false;\n\n      for (var Z = 0; Z < m.seriesGroups.length && !ah; Z++) {\n        var z = m._getXAxis(Z);\n\n        if (z && z.rangeSelector) {\n          ah = true;\n        }\n      }\n\n      if (ah) {\n        if (!this._moduleRangeSelector) {\n          throw \"Please include 'jqxchart.rangeselector.js'\";\n        }\n\n        var d = [];\n\n        if (!this._isSelectorRefresh) {\n          m.removeHandler(a(document), m._getEvent(\"mousemove\"), m._onSliderMouseMove);\n          m.removeHandler(a(document), m._getEvent(\"mousedown\"), m._onSliderMouseDown);\n          m.removeHandler(a(document), m._getEvent(\"mouseup\"), m._onSliderMouseUp);\n        }\n\n        if (!m._isSelectorRefresh) {\n          m._rangeSelectorInstances = {};\n        }\n\n        for (Z = 0; Z < m.seriesGroups.length; Z++) {\n          var v = this._getXAxis(Z);\n\n          if (d.indexOf(v) == -1) {\n            if (this._renderXAxisRangeSelector(Z, G[Z])) {\n              d.push(v);\n            }\n          }\n        }\n      }\n    },\n    _credits: function _credits() {\n      if (a.jqx.credits !== \"75CE8878-FCD1-4EC7-9249-BA0F153A5DE8\") {\n        var c = this;\n        var d = String.fromCharCode(119, 119, 119, 46, 106, 113, 119, 105, 100, 103, 101, 116, 115, 46, 99, 111, 109);\n\n        if (!c._isRangeSelectorInstance && location.hostname.indexOf(d.substring(4)) == -1) {\n          var g = c.renderer;\n          var f = c._rect;\n          var h = {\n            \"class\": c.toThemeProperty(\"jqx-chart-legend-text\", null),\n            opacity: 0.5\n          };\n          var e = g.measureText(d, 0, h);\n          var b = g.text(d, f.x + f.width - e.width - 5, f.y + f.height - e.height - 5, e.width, e.height, 0, h);\n          a(b).on(\"click\", function () {\n            location.href = \"http://\" + d + \"/?ref=\" + c.widgetName;\n          });\n        }\n      }\n    },\n    _isPieOnlySeries: function _isPieOnlySeries() {\n      var c = this.seriesGroups;\n\n      if (c.length == 0) {\n        return false;\n      }\n\n      for (var b = 0; b < c.length; b++) {\n        if (c[b].type != \"pie\" && c[b].type != \"donut\") {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    _renderChartLegend: function _renderChartLegend(V, C, S, v) {\n      var l = this;\n      var D = l.renderer;\n      var I = {\n        x: C.x,\n        y: C.y,\n        width: C.width,\n        height: C.height\n      };\n      var N = 3;\n\n      if (I.width >= 2 * N) {\n        I.x += N;\n        I.width -= 2 * N;\n      }\n\n      if (I.height >= 2 * N) {\n        I.y += N;\n        I.height -= 2 * N;\n      }\n\n      var E = {\n        width: I.width,\n        height: 0\n      };\n      var G = 0,\n          F = 0;\n      var p = 20;\n      var m = 0;\n      var f = 10;\n      var Q = 10;\n      var w = 0;\n\n      for (var P = 0; P < V.length; P++) {\n        var J = V[P].css;\n\n        if (!J) {\n          J = l.toThemeProperty(\"jqx-chart-legend-text\", null);\n        }\n\n        p = 20;\n        var A = V[P].text;\n        var j = D.measureText(A, 0, {\n          \"class\": J\n        });\n\n        if (j.height > p) {\n          p = j.height;\n        }\n\n        if (j.width > w) {\n          w = j.width;\n        }\n\n        if (v) {\n          if (P != 0) {\n            F += p;\n          }\n\n          if (F > I.height) {\n            F = 0;\n            G += w + 2 * Q + f;\n            w = j.width;\n            E.width = G + w;\n          }\n        } else {\n          if (G != 0) {\n            G += Q;\n          }\n\n          if (G + 2 * f + j.width > I.width && j.width < I.width) {\n            G = 0;\n            F += p;\n            p = 20;\n            m = I.width;\n            E.height = F + p;\n          }\n        }\n\n        var K = false;\n\n        if (j.width > I.width) {\n          K = true;\n          var s = I.width;\n          var T = A;\n          var X = T.split(/\\s+/);\n          var o = [];\n          var q = \"\";\n\n          for (var M = 0; M < X.length; M++) {\n            var k = q + (q.length > 0 ? \" \" : \"\") + X[M];\n            var B = l.renderer.measureText(k, 0, {\n              \"class\": J\n            });\n\n            if (B.width > s && k.length > 0 && q.length > 0) {\n              o.push({\n                text: q\n              });\n              q = X[M];\n            } else {\n              q = k;\n            }\n\n            if (M + 1 == X.length) {\n              o.push({\n                text: q\n              });\n            }\n          }\n\n          j.width = 0;\n          var c = 0;\n\n          for (var H = 0; H < o.length; H++) {\n            var W = o[H].text;\n            var B = l.renderer.measureText(W, 0, {\n              \"class\": J\n            });\n            j.width = Math.max(j.width, B.width);\n            c += j.height;\n          }\n\n          j.height = c;\n        }\n\n        var z = G + j.width < I.width && F + j.height < C.height;\n\n        if (l.legendLayout) {\n          var z = I.x + G + j.width < l._rect.x + l._rect.width && I.y + F + j.height < l._rect.y + l._rect.height;\n        }\n\n        if (!S && z) {\n          var h = V[P].seriesIndex;\n          var n = V[P].groupIndex;\n          var b = V[P].itemIndex;\n          var Y = V[P].fillColor;\n          var U = V[P].lineColor;\n\n          var e = l._isSerieVisible(n, h, b);\n\n          var R = D.beginGroup();\n          var O = e ? V[P].opacity : 0.1;\n\n          if (K) {\n            var T = A;\n            var s = I.width;\n            var X = T.split(/\\s+/);\n            var u = \"\";\n            var d = 0;\n            var o = [];\n            var q = \"\";\n\n            for (var M = 0; M < X.length; M++) {\n              var k = q + (q.length > 0 ? \" \" : \"\") + X[M];\n              var B = l.renderer.measureText(k, 0, {\n                \"class\": J\n              });\n\n              if (B.width > s && k.length > 0 && q.length > 0) {\n                o.push({\n                  text: q,\n                  dy: d\n                });\n                d += B.height;\n                q = X[M];\n              } else {\n                q = k;\n              }\n\n              if (M + 1 == X.length) {\n                o.push({\n                  text: q,\n                  dy: d\n                });\n              }\n            }\n\n            for (var H = 0; H < o.length; H++) {\n              var W = o[H].text;\n              d = o[H].dy;\n              var B = l.renderer.measureText(W, 0, {\n                \"class\": J\n              });\n\n              if (v) {\n                l.renderer.text(W, I.x + G + 1.5 * f, I.y + F + d, j.width, p, 0, {\n                  \"class\": J\n                }, false, \"left\", \"center\");\n              } else {\n                l.renderer.text(W, I.x + G + 1.5 * f, I.y + F + d, j.width, p, 0, {\n                  \"class\": J\n                }, false, \"center\", \"center\");\n              }\n            }\n\n            var L = D.rect(I.x + G, I.y + F + f / 2 + d / 2, f, f);\n\n            if (v) {\n              F += d;\n            }\n\n            l.renderer.attr(L, {\n              fill: Y,\n              \"fill-opacity\": O,\n              stroke: U,\n              \"stroke-width\": 1,\n              \"stroke-opacity\": V[P].opacity\n            });\n          } else {\n            var L = D.rect(I.x + G, I.y + F + f / 2, f, f);\n            l.renderer.attr(L, {\n              fill: Y,\n              \"fill-opacity\": O,\n              stroke: U,\n              \"stroke-width\": 1,\n              \"stroke-opacity\": V[P].opacity\n            });\n\n            if (v) {\n              l.renderer.text(A, I.x + G + 1.5 * f, I.y + F, j.width, j.height + f / 2, 0, {\n                \"class\": J\n              }, false, \"left\", \"center\");\n            } else {\n              l.renderer.text(A, I.x + G + 1.5 * f, I.y + F, j.width, p, 0, {\n                \"class\": J\n              }, false, \"center\", \"center\");\n            }\n          }\n\n          l.renderer.endGroup();\n\n          l._setLegendToggleHandler(n, h, b, R);\n        }\n\n        if (v) {} else {\n          G += j.width + 2 * f;\n\n          if (m < G) {\n            m = G;\n          }\n        }\n      }\n\n      if (S) {\n        E.height = a.jqx._ptrnd(F + p + 5);\n        E.width = a.jqx._ptrnd(m);\n        return E;\n      }\n    },\n    isSerieVisible: function isSerieVisible(d, b, c) {\n      return this._isSerieVisible(d, b, c);\n    },\n    _isSerieVisible: function _isSerieVisible(f, b, d) {\n      while (this._itemsToggleState.length < f + 1) {\n        this._itemsToggleState.push([]);\n      }\n\n      var e = this._itemsToggleState[f];\n\n      while (e.length < b + 1) {\n        e.push(isNaN(d) ? true : []);\n      }\n\n      var c = e[b];\n\n      if (isNaN(d)) {\n        return c;\n      }\n\n      if (!a.isArray(c)) {\n        e[b] = c = [];\n      }\n\n      while (c.length < d + 1) {\n        c.push(true);\n      }\n\n      return c[d];\n    },\n    isGroupVisible: function isGroupVisible(b) {\n      return this._isGroupVisible(b);\n    },\n    _isGroupVisible: function _isGroupVisible(e) {\n      var d = false;\n      var c = this.seriesGroups[e].series;\n\n      if (!c) {\n        return d;\n      }\n\n      for (var b = 0; b < c.length; b++) {\n        if (this._isSerieVisible(e, b)) {\n          d = true;\n          break;\n        }\n      }\n\n      return d;\n    },\n    _toggleSerie: function _toggleSerie(h, b, e, c) {\n      var g = !this._isSerieVisible(h, b, e);\n\n      if (c != undefined) {\n        g = c;\n      }\n\n      var i = this.seriesGroups[h];\n      var f = i.series[b];\n\n      this._raiseEvent(\"toggle\", {\n        state: g,\n        seriesGroup: i,\n        serie: f,\n        elementIndex: e\n      });\n\n      if (isNaN(e)) {\n        this._itemsToggleState[h][b] = g;\n      } else {\n        var d = this._itemsToggleState[h][b];\n\n        if (!a.isArray(d)) {\n          d = [];\n        }\n\n        while (d.length < e) {\n          d.push(true);\n        }\n\n        d[e] = g;\n      }\n\n      this._isToggleRefresh = true;\n      this.update();\n      this._isToggleRefresh = false;\n    },\n    showSerie: function showSerie(d, b, c) {\n      this._toggleSerie(d, b, c, true);\n    },\n    hideSerie: function hideSerie(d, b, c) {\n      this._toggleSerie(d, b, c, false);\n    },\n    _setLegendToggleHandler: function _setLegendToggleHandler(j, c, h, e) {\n      var i = this.seriesGroups[j];\n      var f = i.series[c];\n      var b = f.enableSeriesToggle;\n\n      if (b == undefined) {\n        b = i.enableSeriesToggle != false;\n      }\n\n      if (b) {\n        var d = this;\n        this.renderer.addHandler(e, \"click\", function (g) {\n          d._toggleSerie(j, c, h);\n        });\n      }\n    },\n    _renderLegend: function _renderLegend(c, e) {\n      var o = this;\n      var d = [];\n\n      for (var v = 0; v < o.seriesGroups.length; v++) {\n        var t = o.seriesGroups[v];\n\n        if (t.showLegend == false) {\n          continue;\n        }\n\n        for (var q = 0; q < t.series.length; q++) {\n          var m = t.series[q];\n\n          if (m.showLegend == false) {\n            continue;\n          }\n\n          var u = o._getSerieSettings(v, q);\n\n          var p;\n\n          if (t.type == \"pie\" || t.type == \"donut\") {\n            var k = o._getXAxis(v);\n\n            var h = m.legendFormatSettings || t.legendFormatSettings || k.formatSettings || m.formatSettings || t.formatSettings;\n            var n = m.legendFormatFunction || t.legendFormatFunction || k.formatFunction || m.formatFunction || t.formatFunction;\n\n            var j = o._getDataLen(v);\n\n            for (var r = 0; r < j; r++) {\n              p = o._getDataValue(r, m.displayText, v);\n              p = o._formatValue(p, h, n, v, q, r);\n\n              var l = o._getColors(v, q, r);\n\n              d.push({\n                groupIndex: v,\n                seriesIndex: q,\n                itemIndex: r,\n                text: p,\n                css: m.displayTextClass,\n                fillColor: l.fillColor,\n                lineColor: l.lineColor,\n                opacity: u.opacity\n              });\n            }\n\n            continue;\n          }\n\n          var h = m.legendFormatSettings || t.legendFormatSettings;\n          var n = m.legendFormatFunction || t.legendFormatFunction;\n          p = o._formatValue(m.displayText || m.dataField || \"\", h, n, v, q, NaN);\n\n          var l = o._getSeriesColors(v, q);\n\n          var f = this._get([m.legendFillColor, m.legendColor, l.fillColor]);\n\n          var b = this._get([m.legendLineColor, m.legendColor, l.lineColor]);\n\n          d.push({\n            groupIndex: v,\n            seriesIndex: q,\n            text: p,\n            css: m.displayTextClass,\n            fillColor: f,\n            lineColor: b,\n            opacity: u.opacity\n          });\n        }\n      }\n\n      return o._renderChartLegend(d, c, e, o.legendLayout && o.legendLayout.flow == \"vertical\");\n    },\n    _getInterval: function _getInterval(d, c) {\n      if (!d) {\n        return c;\n      }\n\n      var b = this._get([d.unitInterval, c]);\n\n      if (!isNaN(d.step)) {\n        b = d.step * c;\n      }\n\n      return b;\n    },\n    _getOffsets: function _getOffsets(u, d, n, t, r, l, g, e, k) {\n      var s = this._getInterval(r[u], e);\n\n      var m = [];\n\n      if (u == \"\" || r[u].visible && r[u].visible != \"custom\") {\n        m = this._generateIntervalValues(t, s, e, g, k);\n      }\n\n      var f;\n\n      if (u != \"labels\") {\n        var j = g ? l.left : 0;\n\n        if (!g && e > 1) {\n          j = l.left * (e + 1);\n        }\n\n        if (m.length == 1) {\n          j *= 2;\n        }\n\n        f = this._valuesToOffsets(m, d, t, n, l, false, j);\n\n        if (!g) {\n          var o = (l.left + l.right) * s / e;\n\n          if (d.flip) {\n            f.unshift(f[0] + o);\n          } else {\n            f.push(f[f.length - 1] + o);\n          }\n        }\n      } else {\n        var j = l.left;\n\n        if (m.length == 1) {\n          j *= 2;\n        }\n\n        f = this._valuesToOffsets(m, d, t, n, l, g, j);\n      }\n\n      var q = this._arraysToObjectsArray([m, f], [\"value\", \"offset\"]);\n\n      if (d[u] && d[u].custom) {\n        var h = this._objectsArraysToArray(d[u].custom, \"value\");\n\n        var c = this._objectsArraysToArray(d[u].custom, \"offset\");\n\n        var b = this._valuesToOffsets(h, d, t, n, l, g, l.left);\n\n        for (var p = 0; p < d[u].custom.length; p++) {\n          q.push({\n            value: h[p],\n            offset: isNaN(c[p]) ? b[p] : c[p]\n          });\n        }\n      }\n\n      return q;\n    },\n    _renderXAxis: function _renderXAxis(d, y, Q, c) {\n      var f = this;\n\n      var r = f._getXAxis(d);\n\n      var P = f.seriesGroups[d];\n      var W = P.orientation == \"horizontal\";\n      var G = {\n        width: 0,\n        height: 0\n      };\n\n      var O = f._getAxisSettings(r);\n\n      if (!r || !O.visible || P.type == \"spider\") {\n        return G;\n      }\n\n      if (!f._isGroupVisible(d) || this._isPieGroup(d)) {\n        return G;\n      }\n\n      var V = f._alignValuesWithTicks(d);\n\n      while (f._renderData.length < d + 1) {\n        f._renderData.push({});\n      }\n\n      if (f.rtl) {\n        r.flip = true;\n      }\n\n      var A = W ? y.height : y.width;\n      var w = r.text;\n\n      var t = f._calculateXOffsets(d, A);\n\n      var S = t.axisStats;\n      var j = r.rangeSelector;\n      var E = 0;\n\n      if (j) {\n        if (!this._moduleRangeSelector) {\n          throw \"Please include 'jqxchart.rangeselector.js'\";\n        }\n\n        E = this._selectorGetSize(r);\n      }\n\n      var D = W && r.position == \"right\" || !W && r.position == \"top\";\n\n      if (!Q && j) {\n        if (W) {\n          y.width -= E;\n\n          if (r.position != \"right\") {\n            y.x += E;\n          }\n        } else {\n          y.height -= E;\n\n          if (r.position == \"top\") {\n            y.y += E;\n          }\n        }\n      }\n\n      var k = {\n        rangeLength: t.rangeLength,\n        itemWidth: t.itemWidth,\n        intervalWidth: t.intervalWidth,\n        data: t,\n        settings: O,\n        isMirror: D,\n        rect: y\n      };\n      f._renderData[d].xAxis = k;\n      var F = S.interval;\n\n      if (isNaN(F)) {\n        return G;\n      }\n\n      if (W) {\n        O.title.angle -= 90;\n        O.labels.angle -= 90;\n      }\n\n      var m = this._getInterval(O.gridLines, F);\n\n      var J = this._getInterval(O.tickMarks, F);\n\n      var B = this._getInterval(O.labels, F);\n\n      var K;\n      var U = S.min;\n      var s = S.max;\n      var M = t.padding;\n      var R = r.flip == true || f.rtl;\n      var h = {\n        min: U,\n        max: s\n      };\n\n      if (S.logAxis.enabled) {\n        h.min = S.logAxis.minPow;\n        h.max = S.logAxis.maxPow;\n      }\n\n      if (r.type == \"date\") {\n        O.gridLines.offsets = this._generateDTOffsets(U, s, A, M, m, F, S.dateTimeUnit, V, NaN, false, R);\n        O.tickMarks.offsets = this._generateDTOffsets(U, s, A, M, J, F, S.dateTimeUnit, V, NaN, false, R);\n        K = this._generateDTOffsets(U, s, A, M, B, F, S.dateTimeUnit, V, NaN, true, R);\n      } else {\n        O.gridLines.offsets = this._getOffsets(\"gridLines\", r, A, S, O, M, V, F);\n        O.tickMarks.offsets = this._getOffsets(\"tickMarks\", r, A, S, O, M, V, F);\n        K = this._getOffsets(\"labels\", r, A, S, O, M, V, F);\n      }\n\n      var n = f.renderer.getRect();\n      var l = n.width - y.x - y.width;\n\n      var p = f._getDataLen(d);\n\n      var o;\n\n      if (f._elementRenderInfo && f._elementRenderInfo.length > d) {\n        o = f._elementRenderInfo[d].xAxis;\n      }\n\n      var q = [];\n      var I;\n\n      if (O.labels.formatFunction) {\n        I = O.labels.formatFunction;\n      }\n\n      var v;\n\n      if (O.labels.formatSettings) {\n        v = a.extend({}, O.labels.formatSettings);\n      }\n\n      if (r.type == \"date\") {\n        if (r.dateFormat && !I) {\n          if (v) {\n            v.dateFormat = v.dateFormat || r.dateFormat;\n          } else {\n            v = {\n              dateFormat: r.dateFormat\n            };\n          }\n        } else {\n          if (!I && (!v || v && !v.dateFormat)) {\n            I = this._getDefaultDTFormatFn(r.baseUnit || \"day\");\n          }\n        }\n      }\n\n      for (var N = 0; N < K.length; N++) {\n        var L = K[N].value;\n        var H = K[N].offset;\n\n        if (isNaN(H)) {\n          continue;\n        }\n\n        var T = undefined;\n\n        if (r.type != \"date\" && S.useIndeces && r.dataField) {\n          T = Math.round(L);\n          L = f._getDataValue(T, r.dataField);\n\n          if (L == undefined) {\n            L = \"\";\n          }\n        }\n\n        var w = f._formatValue(L, v, I, d, undefined, T);\n\n        if (w == undefined || w.toString() == \"\") {\n          if (isNaN(T)) {\n            T = N;\n          }\n\n          if (T >= S.filterRange.min && T <= S.filterRange.max) {\n            w = S.useIndeces ? (S.min + T).toString() : L == undefined ? \"\" : L.toString();\n          }\n        }\n\n        var b = {\n          key: L,\n          text: w,\n          targetX: H,\n          x: H\n        };\n\n        if (o && o.itemOffsets[L]) {\n          b.x = o.itemOffsets[L].x;\n          b.y = o.itemOffsets[L].y;\n        }\n\n        q.push(b);\n      }\n\n      var C = f._getAnimProps(d);\n\n      var u = C.enabled && q.length < 500 ? C.duration : 0;\n\n      if (f.enableAxisTextAnimation == false) {\n        u = 0;\n      }\n\n      var z = {\n        items: q,\n        renderData: k\n      };\n\n      var e = f._renderAxis(W, D, O, {\n        x: y.x,\n        y: y.y,\n        width: y.width,\n        height: y.height\n      }, c, F, false, true, z, Q, u);\n\n      if (W) {\n        e.width += E;\n      } else {\n        e.height += E;\n      }\n\n      return e;\n    },\n    _animateAxisText: function _animateAxisText(f, h) {\n      var c = f.items;\n      var d = f.textSettings;\n\n      for (var e = 0; e < c.length; e++) {\n        var g = c[e];\n\n        if (!g) {\n          continue;\n        }\n\n        if (!g.visible) {\n          continue;\n        }\n\n        var b = g.targetX;\n        var j = g.targetY;\n\n        if (!isNaN(g.x) && !isNaN(g.y)) {\n          b = g.x + (b - g.x) * h;\n          j = g.y + (j - g.y) * h;\n        }\n\n        if (g.element) {\n          this.renderer.removeElement(g.element);\n          g.element = undefined;\n        }\n\n        g.element = this.renderer.text(g.text, b, j, g.width, g.height, d.angle, {\n          \"class\": d.style\n        }, false, d.halign, d.valign, d.textRotationPoint);\n      }\n    },\n    _getPolarAxisCoords: function _getPolarAxisCoords(f, b) {\n      var j = this.seriesGroups[f];\n      var q = b.x + a.jqx.getNum([j.offsetX, b.width / 2]);\n      var p = b.y + a.jqx.getNum([j.offsetY, b.height / 2]);\n      var l = Math.min(b.width, b.height);\n      var g = j.radius;\n\n      if (this._isPercent(g)) {\n        g = parseFloat(g) / 100 * l / 2;\n      }\n\n      if (isNaN(g)) {\n        g = l / 2 * 0.6;\n      }\n\n      var i = this._alignValuesWithTicks(f);\n\n      var o = this._get([j.startAngle, j.minAngle, 0]) - 90;\n\n      if (isNaN(o)) {\n        o = 0;\n      } else {\n        o = 2 * Math.PI * o / 360;\n      }\n\n      var n = this._get([j.endAngle, j.maxAngle, 360]) - 90;\n\n      if (isNaN(n)) {\n        n = 2 * Math.PI;\n      } else {\n        n = 2 * Math.PI * n / 360;\n      }\n\n      if (o > n) {\n        var m = o;\n        o = n;\n        n = m;\n      }\n\n      var u = a.jqx._rnd(Math.abs(o - n) / (Math.PI * 2), 0.001, true);\n\n      var r = Math.PI * 2 * g * u;\n\n      var h = this._calcGroupOffsets(f, b).xoffsets;\n\n      if (!h) {\n        return;\n      }\n\n      var k = !(Math.abs(Math.abs(n - o) - Math.PI * 2) > 0.00001);\n\n      if (j.spider) {\n        var e = this._getXAxisStats(f, this._getXAxis(f), r);\n\n        var s = e.interval;\n\n        if (isNaN(s) || s == 0) {\n          s = 1;\n        }\n\n        var d = (e.max - e.min) / s + (k ? 1 : 0);\n        d = Math.round(d);\n\n        if (d > 2) {\n          var c = Math.cos(Math.abs(n - o) / 2 / d);\n          c = a.jqx._rnd(c, 0.01);\n\n          if (c == 0) {\n            c = 1;\n          }\n\n          var t = g / c;\n\n          if (t > g && i) {\n            g = t;\n          }\n        }\n      }\n\n      g = a.jqx._ptrnd(g);\n      return {\n        x: q,\n        y: p,\n        r: g,\n        adjR: this._get([t, g]),\n        itemWidth: h.itemWidth,\n        rangeLength: h.rangeLength,\n        valuesOnTicks: i,\n        startAngle: o,\n        endAngle: n,\n        isClosedCircle: k,\n        axisSize: r\n      };\n    },\n    _toPolarCoord: function _toPolarCoord(j, f, h, e) {\n      var c = Math.abs(j.startAngle - j.endAngle) / (Math.PI * 2);\n      var b = (h - f.x) * 2 * Math.PI * c / Math.max(1, f.width) + j.startAngle;\n      var d = (f.height + f.y - e) * j.r / Math.max(1, f.height);\n      var i = j.x + d * Math.cos(b);\n      var g = j.y + d * Math.sin(b);\n      return {\n        x: a.jqx._ptrnd(i),\n        y: a.jqx._ptrnd(g)\n      };\n    },\n    _renderSpiderAxis: function _renderSpiderAxis(z, k) {\n      var ao = this;\n\n      var g = ao._getXAxis(z);\n\n      var aA = this._getAxisSettings(g);\n\n      if (!g || !aA.visible) {\n        return;\n      }\n\n      var W = ao.seriesGroups[z];\n\n      var R = ao._getPolarAxisCoords(z, k);\n\n      if (!R) {\n        return;\n      }\n\n      var L = a.jqx._ptrnd(R.x);\n\n      var K = a.jqx._ptrnd(R.y);\n\n      var t = R.adjR;\n      var X = R.startAngle;\n      var V = R.endAngle;\n\n      if (t < 1) {\n        return;\n      }\n\n      var av = a.jqx._rnd(Math.abs(X - V) / (Math.PI * 2), 0.001, true);\n\n      var h = Math.PI * 2 * t * av;\n      var c = R.isClosedCircle;\n      var w = this._renderData[z].xoffsets;\n\n      if (!w.rangeLength) {\n        return;\n      }\n\n      var S = w.axisStats.interval;\n\n      if (isNaN(S) || S < 1) {\n        S = 1;\n      }\n\n      var ar = W.orientation == \"horizontal\";\n      var Z = ar && g.position == \"right\" || !ar && g.position == \"top\";\n\n      while (ao._renderData.length < z + 1) {\n        ao._renderData.push({});\n      }\n\n      var at = {\n        rangeLength: w.rangeLength,\n        itemWidth: w.itemWidth,\n        data: w,\n        rect: k,\n        settings: aA\n      };\n      ao._renderData[z].xAxis = at;\n      ao._renderData[z].polarCoords = R;\n      var ay = true;\n\n      for (var Q = 0; Q < z; Q++) {\n        var A = ao._renderData[Q].xAxis;\n        var b = ao._renderData[Q].polarCoords;\n\n        var D = ao._getXAxis(Q);\n\n        var U = false;\n\n        for (var O in R) {\n          if (R[O] != b[O]) {\n            U = true;\n            break;\n          }\n        }\n\n        if (!U || D != g) {\n          ay = false;\n        }\n      }\n\n      var e = aA.gridLines;\n      var T = aA.tickMarks;\n      var y = aA.labels;\n\n      var ac = this._getInterval(e, S);\n\n      var aD = this._getInterval(T, S);\n\n      var am = this._getInterval(y, S);\n\n      var G = ao._alignValuesWithTicks(z);\n\n      var ad = ao.renderer;\n      var ah;\n      var ae = w.axisStats;\n      var aC = ae.min;\n      var r = ae.max;\n\n      var u = this._getPaddingSize(w.axisStats, g, G, h, true, c, false);\n\n      var ai = g.flip == true || ao.rtl;\n\n      if (g.type == \"date\") {\n        e.offsets = this._generateDTOffsets(aC, r, h, u, ac, S, g.baseUnit, true, 0, false, ai);\n        T.offsets = this._generateDTOffsets(aC, r, h, u, aD, S, g.baseUnit, true, 0, false, ai);\n        ah = this._generateDTOffsets(aC, r, h, u, am, S, g.baseUnit, true, 0, true, ai);\n      } else {\n        aA.gridLines.offsets = this._getOffsets(\"gridLines\", g, h, ae, aA, u, true, S);\n        aA.tickMarks.offsets = this._getOffsets(\"tickMarks\", g, h, ae, aA, u, true, S);\n        ah = this._getOffsets(\"labels\", g, h, ae, aA, u, true, S);\n      }\n\n      var aj = ao.renderer.getRect();\n      var aw = aj.width - k.x - k.width;\n\n      var ag = ao._getDataLen(z);\n\n      var s;\n\n      if (ao._elementRenderInfo && ao._elementRenderInfo.length > z) {\n        s = ao._elementRenderInfo[z].xAxis;\n      }\n\n      var aq = [];\n\n      var af = this._getDataLen(z);\n\n      for (var Q = 0; Q < ah.length; Q++) {\n        var F = ah[Q].offset;\n        var H = ah[Q].value;\n\n        if (g.type != \"date\" && ae.useIndeces && g.dataField) {\n          var ax = Math.round(H);\n\n          if (ax >= af) {\n            continue;\n          }\n\n          H = ao._getDataValue(ax, g.dataField);\n\n          if (H == undefined) {\n            H = \"\";\n          }\n        }\n\n        var ap = ao._formatValue(H, y.formatSettings, y.formatFunction, z, undefined, ax);\n\n        if (ap == undefined || ap.toString() == \"\") {\n          ap = ae.useIndeces ? (ae.min + Q).toString() : H == undefined ? \"\" : H.toString();\n        }\n\n        var d = {\n          key: H,\n          text: ap,\n          targetX: F,\n          x: F\n        };\n\n        if (s && s.itemOffsets[H]) {\n          d.x = s.itemOffsets[H].x;\n          d.y = s.itemOffsets[H].y;\n        }\n\n        aq.push(d);\n      }\n\n      var az = {\n        items: aq,\n        renderData: at\n      };\n      var l = {\n        stroke: e.color,\n        fill: \"none\",\n        \"stroke-width\": e.width,\n        \"stroke-dasharray\": e.dashStyle || \"\"\n      };\n\n      if (!W.spider) {\n        if (av == 1) {\n          ad.circle(L, K, t, l);\n        } else {\n          var E = -X / Math.PI * 180;\n          var aE = -V / Math.PI * 180;\n          this.renderer.pieslice(L, K, 0, t, Math.min(E, aE), Math.max(E, aE), undefined, l);\n        }\n      }\n\n      var M = aq.length;\n      var m = 2 * Math.PI / M;\n      var al = X;\n      var f, C;\n\n      if (e.visible && ay) {\n        if (!G && !c) {\n          e.offsets.unshift({\n            offset: -u.right\n          });\n        }\n\n        for (var Q = 0; Q < e.offsets.length; Q++) {\n          var n = e.offsets[Q].offset;\n\n          if (!G) {\n            if (c) {\n              n += u.right / 2;\n            } else {\n              n += u.right;\n            }\n          }\n\n          var B = al + n * 2 * Math.PI * av / Math.max(1, h);\n\n          if (B - V > 0.01) {\n            continue;\n          }\n\n          var q = a.jqx._ptrnd(L + t * Math.cos(B));\n\n          var p = a.jqx._ptrnd(K + t * Math.sin(B));\n\n          ad.line(L, K, q, p, l);\n        }\n      }\n\n      if (T.visible && ay) {\n        var P = 5;\n        var o = {\n          stroke: T.color,\n          fill: \"none\",\n          \"stroke-width\": T.width,\n          \"stroke-dasharray\": T.dashStyle || \"\"\n        };\n\n        if (!G && !c) {\n          T.offsets.unshift({\n            offset: -u.right\n          });\n        }\n\n        for (var Q = 0; Q < T.offsets.length; Q++) {\n          var n = T.offsets[Q].offset;\n\n          if (!G) {\n            if (c) {\n              n += u.right / 2;\n            } else {\n              n += u.right;\n            }\n          }\n\n          var B = al + n * 2 * Math.PI * av / Math.max(1, h);\n\n          if (B - V > 0.01) {\n            continue;\n          }\n\n          var ab = {\n            x: L + t * Math.cos(B),\n            y: K + t * Math.sin(B)\n          };\n          var aa = {\n            x: L + (t + P) * Math.cos(B),\n            y: K + (t + P) * Math.sin(B)\n          };\n          ad.line(a.jqx._ptrnd(ab.x), a.jqx._ptrnd(ab.y), a.jqx._ptrnd(aa.x), a.jqx._ptrnd(aa.y), o);\n        }\n      }\n\n      var an = [];\n\n      if (W.spider) {\n        var v = [];\n\n        if (g.type == \"date\") {\n          v = this._generateDTOffsets(aC, r, h, u, S, S, g.baseUnit, true, 0, false, ai);\n        } else {\n          v = this._getOffsets(\"\", g, h, ae, aA, u, true, S);\n        }\n\n        if (!G && !c) {\n          v.unshift({\n            offset: -u.right\n          });\n        }\n\n        for (var Q = 0; Q < v.length; Q++) {\n          var n = v[Q].offset;\n\n          if (!G) {\n            if (c) {\n              n += u.right / 2;\n            } else {\n              n += u.right;\n            }\n          }\n\n          var B = al + n * 2 * Math.PI * av / Math.max(1, h);\n\n          if (B - V > 0.01) {\n            continue;\n          }\n\n          an.push(B);\n        }\n\n        at.offsetAngles = an;\n      }\n\n      var Y = ao._renderSpiderValueAxis(z, k, G ? R.adjR : R.r, an);\n\n      if (!Y) {\n        Y = [];\n      }\n\n      if (W.spider) {\n        if (!G) {\n          for (var Q = 0; Q < Y.length; Q++) {\n            Y[Q] = Y[Q] * R.adjR / R.r;\n          }\n        }\n\n        Y.push(t);\n\n        this._renderSpiderLines(L, K, Y, R, an, l);\n      }\n\n      if (ay && y.visible) {\n        at.polarLabels = [];\n\n        for (var Q = 0; Q < aq.length; Q++) {\n          var n = aq[Q].x;\n          var B = al + n * 2 * Math.PI * av / Math.max(1, h);\n          B = (360 - B / (2 * Math.PI) * 360) % 360;\n\n          if (B < 0) {\n            B = 360 + B;\n          }\n\n          var ak = ad.measureText(aq[Q].text, 0, {\n            \"class\": aA.labels.style\n          });\n          var N = (G ? R.adjR : R.r) + (T.visible ? 7 : 2);\n          var au = aA.labels;\n          var aB;\n\n          if (au.autoRotate) {\n            var J = a.jqx._ptRotate(L - ak.width / 2, K - N - ak.height, L, K, -B / 180 * Math.PI);\n\n            var I = a.jqx._ptRotate(L + ak.width / 2, K - N, L, K, -B / 180 * Math.PI);\n\n            ak.width = Math.abs(J.x - I.x);\n            ak.height = Math.abs(J.y - I.y);\n            aB = {\n              x: Math.min(J.x, I.x),\n              y: Math.min(J.y, I.y)\n            };\n          } else {\n            aB = this._adjustTextBoxPosition(L, K, ak, N, B, false, false, false);\n          }\n\n          at.polarLabels.push({\n            x: aB.x,\n            y: aB.y,\n            value: aq[Q].text\n          });\n          ad.text(aq[Q].text, aB.x, aB.y, ak.width, ak.height, au.autoRotate ? 90 - B : au.angle, {\n            \"class\": au.style\n          }, false, au.halign, au.valign);\n        }\n      }\n    },\n    _renderSpiderLines: function _renderSpiderLines(h, f, u, m, e, b) {\n      var p = this.renderer;\n      var q = m.startAngle;\n      var o = m.endAngle;\n      var g = m.isClosedCircle;\n\n      for (var r = 0; r < u.length; r++) {\n        var d = u[r];\n        var c = undefined,\n            n = undefined;\n\n        for (var s = 0; s < e.length; s++) {\n          var t = e[s];\n\n          var l = a.jqx._ptrnd(h + d * Math.cos(t));\n\n          var k = a.jqx._ptrnd(f + d * Math.sin(t));\n\n          if (c) {\n            p.line(c.x, c.y, l, k, b);\n          }\n\n          c = {\n            x: l,\n            y: k\n          };\n\n          if (!n) {\n            n = {\n              x: l,\n              y: k\n            };\n          }\n        }\n\n        if (n && g) {\n          p.line(c.x, c.y, n.x, n.y, b);\n        }\n      }\n    },\n    _renderSpiderValueAxis: function _renderSpiderValueAxis(e, F, V, U) {\n      var k = this;\n      var w = this.seriesGroups[e];\n\n      var G = this._getPolarAxisCoords(e, F);\n\n      if (!G) {\n        return;\n      }\n\n      var R = a.jqx._ptrnd(G.x);\n\n      var Q = a.jqx._ptrnd(G.y);\n\n      V = V || G.r;\n      var h = G.startAngle;\n      var ac = G.endAngle;\n\n      var Z = a.jqx._rnd(Math.abs(h - ac) / (Math.PI * 2), 0.001, true);\n\n      if (V < 1) {\n        return;\n      }\n\n      V = a.jqx._ptrnd(V);\n\n      var g = this._getValueAxis(e);\n\n      var ab = this._getAxisSettings(g);\n\n      if (!g || false == ab.visible) {\n        return;\n      }\n\n      var N = this._stats.seriesGroups[e].mu;\n      var C = ab.labels;\n      var B = C.formatSettings;\n      var c = w.type.indexOf(\"stacked\") != -1 && w.type.indexOf(\"100\") != -1;\n\n      if (c && !B) {\n        B = {\n          sufix: \"%\"\n        };\n      }\n\n      var z = this._get([C.step, C.unitInterval / N]);\n\n      if (isNaN(z)) {\n        z = 1;\n      }\n\n      z = Math.max(1, Math.round(z));\n\n      this._calcValueAxisItems(e, V, z);\n\n      var d = ab.gridLines;\n      var D = ab.tickMarks;\n\n      var s = this._getInterval(d, N);\n\n      var S = this._getInterval(D, N);\n\n      var n = ab.labels;\n      var m = {\n        stroke: d.color,\n        fill: \"none\",\n        \"stroke-width\": 1,\n        \"stroke-dasharray\": d.dashStyle || \"\"\n      };\n      var q = this._renderData[e].valueAxis;\n      var A = q.items;\n      var v = h;\n\n      if (A.length && ab.line.visible) {\n        if (!isNaN(ab.line.angle)) {\n          v = 2 * Math.PI * ab.line.angle / 360;\n        }\n\n        var p = R + Math.cos(v) * V;\n        var af = Q + Math.sin(v) * V;\n\n        if (U.indexOf(v) == -1) {\n          var X = a.extend({}, m);\n          X[\"stroke-width\"] = ab.line.lineWidth;\n          X.stroke = ab.line.color;\n          X[\"stroke-dasharray\"] = ab.line.dashStyle;\n          this.renderer.line(R, Q, p, af, X);\n        }\n      }\n\n      A = A.reverse();\n      var K = this.renderer;\n      q.polarLabels = [];\n\n      for (var aa = 0; aa < A.length - 1; aa++) {\n        var T = A[aa];\n\n        if (isNaN(T)) {\n          continue;\n        }\n\n        var E = n.formatFunction ? n.formatFunction(T) : this._formatNumber(T, B);\n        var f = K.measureText(E, 0, {\n          \"class\": n.style\n        });\n        var P = R + (g.showTickMarks != false ? 3 : 2);\n        var O = Q - q.itemWidth * aa - f.height / 2;\n\n        var J = a.jqx._ptRotate(P, O, R, Q, v);\n\n        var I = a.jqx._ptRotate(P + f.width, O + f.height, R, Q, v);\n\n        P = Math.min(J.x, I.x);\n        O = Math.min(J.y, I.y);\n        f.width = Math.abs(J.x - I.x);\n        f.height = Math.abs(J.y - I.y);\n        P += ab.labels.textOffset.x;\n        O += ab.labels.textOffset.y;\n        q.polarLabels.push({\n          x: P,\n          y: O,\n          value: E\n        });\n        K.text(E, P, O, f.width, f.height, n.autoRotate ? 90 + h * 180 / Math.PI : n.angle, {\n          \"class\": n.style\n        }, false, n.halign, n.valign);\n      }\n\n      var r = g.logarithmicScale == true;\n      var u = r ? A.length : q.rangeLength;\n      var l = 2 * Math.PI / u;\n      var ae = g.valuesOnTicks != false;\n      var M = this._stats.seriesGroups[e];\n      var j = M.mu;\n      var L = g.logarithmicScale == true;\n      var H = g.logarithmicScaleBase || 10;\n\n      if (L) {\n        j = 1;\n      }\n\n      var ad = {\n        min: M.min,\n        max: M.max,\n        logAxis: {\n          enabled: L == true,\n          base: g.logarithmicScaleBase,\n          minPow: M.minPow,\n          maxPow: M.maxPow\n        }\n      };\n\n      if (d.visible || w.spider || g.alternatingBackgroundColor || g.alternatingBackgroundColor2) {\n        d.offsets = this._getOffsets(\"gridLines\", g, V, ad, ab, {\n          left: 0,\n          right: 0\n        }, ae, j);\n      }\n\n      var W = [];\n\n      if (d.visible || w.spider) {\n        var m = {\n          stroke: d.color,\n          fill: \"none\",\n          \"stroke-width\": 1,\n          \"stroke-dasharray\": d.dashStyle || \"\"\n        };\n\n        for (var aa = 0; aa < d.offsets.length; aa++) {\n          var O = a.jqx._ptrnd(d.offsets[aa].offset);\n\n          if (O == V) {\n            continue;\n          }\n\n          if (w.spider) {\n            W.push(O);\n            continue;\n          }\n\n          if (Z != 1) {\n            var o = -h / Math.PI * 180;\n            var Y = -ac / Math.PI * 180;\n            this.renderer.pieslice(R, Q, 0, O, Math.min(o, Y), Math.max(o, Y), undefined, m);\n          } else {\n            K.circle(R, Q, O, m);\n          }\n        }\n      }\n\n      if (!g.tickMarks || !g.tickMarks.visible && !g.showTickMarks) {\n        D.visible = false;\n      }\n\n      if (D.visible) {\n        D.offsets = this._getOffsets(\"tickMarks\", g, V, ad, ab, {\n          left: 0,\n          right: 0\n        }, ae, j);\n        var t = D.size * 2;\n        var m = {\n          stroke: D.color,\n          fill: \"none\",\n          \"stroke-width\": 1,\n          \"stroke-dasharray\": D.dashStyle || \"\"\n        };\n\n        for (var aa = 0; aa < D.offsets.length; aa++) {\n          var b = D.offsets[aa].offset;\n          var J = {\n            x: R + b * Math.cos(v) - t / 2 * Math.sin(v + Math.PI / 2),\n            y: Q + b * Math.sin(v) - t / 2 * Math.cos(v + Math.PI / 2)\n          };\n          var I = {\n            x: R + b * Math.cos(v) + t / 2 * Math.sin(v + Math.PI / 2),\n            y: Q + b * Math.sin(v) + t / 2 * Math.cos(v + Math.PI / 2)\n          };\n          K.line(a.jqx._ptrnd(J.x), a.jqx._ptrnd(J.y), a.jqx._ptrnd(I.x), a.jqx._ptrnd(I.y), m);\n        }\n      }\n\n      return W;\n    },\n    _renderAxis: function _renderAxis(H, D, Q, z, c, F, m, V, C, U, d) {\n      if (Q.customDraw && !U) {\n        return {\n          width: NaN,\n          height: NaN\n        };\n      }\n\n      var t = Q.title,\n          n = Q.labels,\n          e = Q.gridLines,\n          A = Q.tickMarks,\n          P = Q.padding;\n      var o = A.visible ? A.size : 0;\n      var R = 2;\n      var G = {\n        width: 0,\n        height: 0\n      };\n      var q = {\n        width: 0,\n        height: 0\n      };\n\n      if (H) {\n        G.height = q.height = z.height;\n      } else {\n        G.width = q.width = z.width;\n      }\n\n      if (!U && D) {\n        if (H) {\n          z.x -= z.width;\n        }\n      }\n\n      var l = C.renderData;\n      var b = l.itemWidth;\n\n      if (t.visible && t.text != undefined && t != \"\") {\n        var p = t.angle;\n        var f = this.renderer.measureText(t.text, p, {\n          \"class\": t.style\n        });\n        q.width = f.width;\n        q.height = f.height;\n\n        if (!U) {\n          this.renderer.text(t.text, z.x + t.offset.x + (H ? !D ? R + P.left : -P.right - R + 2 * z.width - q.width : 0), z.y + t.offset.y + (!H ? !D ? z.height - R - q.height - P.bottom : P.top + R : 0), H ? q.width : z.width, !H ? q.height : z.height, p, {\n            \"class\": t.style\n          }, true, t.halign, t.valign, t.rotationPoint);\n        }\n      }\n\n      var L = 0;\n      var u = V ? -b / 2 : 0;\n\n      if (V && !H) {\n        n.halign = \"center\";\n      }\n\n      var N = z.x;\n      var M = z.y;\n      var E = n.textOffset;\n\n      if (E) {\n        if (!isNaN(E.x)) {\n          N += E.x;\n        }\n\n        if (!isNaN(E.y)) {\n          M += E.y;\n        }\n      }\n\n      if (!H) {\n        N += u;\n\n        if (D) {\n          M += q.height > 0 ? q.height + 3 * R : 2 * R;\n          M += o - (V ? o : o / 4);\n        } else {\n          M += V ? o : o / 4;\n        }\n\n        M += P.top;\n      } else {\n        N += P.left + R + (q.width > 0 ? q.width + R : 0) + (D ? z.width - q.width : 0);\n        M += u;\n      }\n\n      var T = 0;\n      var K = 0;\n      var r = C.items;\n      l.itemOffsets = {};\n\n      if (this._isToggleRefresh || !this._isUpdate) {\n        d = 0;\n      }\n\n      var k = false;\n      var j = 0;\n\n      for (var S = 0; S < r.length && n.visible; S++, L += b) {\n        if (!r[S] || isNaN(b)) {\n          continue;\n        }\n\n        var v = r[S].text;\n\n        if (!isNaN(r[S].targetX)) {\n          L = r[S].targetX;\n        }\n\n        var f = this.renderer.measureText(v, n.angle, {\n          \"class\": n.style\n        });\n\n        if (f.width > K) {\n          K = f.width;\n        }\n\n        if (f.height > T) {\n          T = f.height;\n        }\n\n        j += H ? T : K;\n\n        if (!U) {\n          if (H && L > z.height + 2 || !H && L > z.width + 2) {\n            continue;\n          }\n\n          var J = H ? N + (D ? q.width == 0 ? o : o - R : 0) : N + L;\n          var I = H ? M + L : M;\n          l.itemOffsets[r[S].key] = {\n            x: J,\n            y: I\n          };\n\n          if (!k) {\n            if (!isNaN(r[S].x) || !isNaN(r[S].y) && d) {\n              k = true;\n            }\n          }\n\n          r[S].targetX = J;\n          r[S].targetY = I;\n          r[S].width = !H ? b : z.width - P.left - P.right - 2 * R - o - (q.width > 0 ? q.width + R : 0);\n          r[S].height = H ? b : z.height - P.top - P.bottom - 2 * R - o - (q.height > 0 ? q.height + R : 0);\n          r[S].visible = true;\n        }\n      }\n\n      l.avgWidth = r.length == 0 ? 0 : j / r.length;\n\n      if (!U) {\n        var s = {\n          items: r,\n          textSettings: n\n        };\n\n        if (isNaN(d) || !k) {\n          d = 0;\n        }\n\n        this._animateAxisText(s, d == 0 ? 1 : 0);\n\n        if (d != 0) {\n          var g = this;\n\n          this._enqueueAnimation(\"series\", undefined, undefined, d, function (i, h, w) {\n            g._animateAxisText(h, w);\n          }, s);\n        }\n      }\n\n      G.width += 2 * R + o + q.width + K + (H && q.width > 0 ? R : 0);\n      G.height += 2 * R + o + q.height + T + (!H && q.height > 0 ? R : 0);\n\n      if (!H) {\n        G.height += P.top + P.bottom;\n      } else {\n        G.width += P.left + P.right;\n      }\n\n      var B = {};\n\n      if (!U && Q.line.visible) {\n        var O = {\n          stroke: Q.line.color,\n          \"stroke-width\": Q.line.width,\n          \"stroke-dasharray\": Q.line.dashStyle || \"\"\n        };\n\n        if (H) {\n          var J = z.x + z.width + (D ? P.left : -P.right);\n          J = a.jqx._ptrnd(J);\n          this.renderer.line(J, z.y, J, z.y + z.height, O);\n        } else {\n          var I = a.jqx._ptrnd(z.y + (D ? z.height - P.bottom : P.top));\n\n          this.renderer.line(a.jqx._ptrnd(z.x), I, a.jqx._ptrnd(z.x + z.width + 1), I, O);\n        }\n      }\n\n      G.width = a.jqx._rup(G.width);\n      G.height = a.jqx._rup(G.height);\n      return G;\n    },\n    _drawPlotAreaLines: function _drawPlotAreaLines(j, z, f) {\n      var E = this.seriesGroups[j];\n      var c = E.orientation != \"horizontal\";\n\n      if (!this._renderData || this._renderData.length <= j) {\n        return;\n      }\n\n      var J = z ? \"valueAxis\" : \"xAxis\";\n      var v = this._renderData[j][J];\n\n      if (!v) {\n        return;\n      }\n\n      var n = this._renderData.axisDrawState;\n\n      if (!n) {\n        n = this._renderData.axisDrawState = {};\n      }\n\n      var A = \"\",\n          h;\n\n      if (z) {\n        A = \"valueAxis_\" + (E.valueAxis ? j : \"\") + (c ? \"swap\" : \"\");\n        h = this._getValueAxis(j);\n      } else {\n        A = \"xAxis_\" + (E.xAxis || E.categoryAxis ? j : \"\") + (c ? \"swap\" : \"\");\n        h = this._getXAxis(j);\n      }\n\n      if (n[A]) {\n        n = n[A];\n      } else {\n        n = n[A] = {};\n      }\n\n      if (!z) {\n        c = !c;\n      }\n\n      var H = v.settings;\n\n      if (!H) {\n        return;\n      }\n\n      if (H.customDraw) {\n        return;\n      }\n\n      var G = H.gridLines,\n          q = H.tickMarks,\n          u = H.padding;\n      var e = v.rect;\n      var l = this._plotRect;\n\n      if (!G || !q) {\n        return;\n      }\n\n      var p = 0.5;\n      var d = {};\n      var b = {\n        stroke: G.color,\n        \"stroke-width\": G.width,\n        \"stroke-dasharray\": G.dashStyle || \"\"\n      };\n      var D = z ? e.y + e.height : e.x;\n      var o = G.offsets;\n\n      if (z && !h.flip) {\n        o = a.extend([], o);\n        o = o.reverse();\n      }\n\n      if (o && o.length > 0) {\n        var k = NaN;\n        var C = o.length;\n\n        for (var B = 0; B < o.length; B++) {\n          if (c) {\n            var F = a.jqx._ptrnd(e.y + o[B].offset);\n\n            if (F < e.y - p) {\n              F = a.jqx._ptrnd(e.y);\n            }\n\n            if (F > e.y + e.height) {\n              F = e.y + e.height;\n            }\n          } else {\n            F = a.jqx._ptrnd(e.x + o[B].offset);\n\n            if (F > e.x + e.width + p) {\n              F = a.jqx._ptrnd(e.x + e.width);\n            }\n          }\n\n          if (isNaN(F)) {\n            continue;\n          }\n\n          if (!isNaN(k) && Math.abs(F - k) < 2) {\n            continue;\n          }\n\n          k = F;\n\n          if (f.gridLines && G.visible != false && n.gridLines != true) {\n            if (c) {\n              this.renderer.line(a.jqx._ptrnd(l.x), F, a.jqx._ptrnd(l.x + l.width), F, b);\n            } else {\n              this.renderer.line(F, a.jqx._ptrnd(l.y), F, a.jqx._ptrnd(l.y + l.height), b);\n            }\n          }\n\n          d[F] = true;\n\n          if (f.alternatingBackground && (G.alternatingBackgroundColor || G.alternatingBackgroundColor2) && n.alternatingBackground != true) {\n            var m = B % 2 == 0 ? G.alternatingBackgroundColor2 : G.alternatingBackgroundColor;\n\n            if (B > 0 && m) {\n              var I;\n\n              if (c) {\n                I = this.renderer.rect(a.jqx._ptrnd(l.x), D, a.jqx._ptrnd(l.width - 1), F - D, b);\n              } else {\n                I = this.renderer.rect(D, a.jqx._ptrnd(l.y), F - D, a.jqx._ptrnd(l.height), b);\n              }\n\n              this.renderer.attr(I, {\n                \"stroke-width\": 0,\n                fill: m,\n                opacity: G.alternatingBackgroundOpacity || 1\n              });\n            }\n          }\n\n          D = F;\n        }\n      }\n\n      var b = {\n        stroke: q.color,\n        \"stroke-width\": q.width,\n        \"stroke-dasharray\": q.dashStyle || \"\"\n      };\n\n      if (f.tickMarks && q.visible && n.tickMarks != true) {\n        var t = q.size;\n        var o = q.offsets;\n        var k = NaN;\n\n        for (var B = 0; B < o.length; B++) {\n          if (c) {\n            F = a.jqx._ptrnd(e.y + o[B].offset);\n\n            if (F < e.y - p) {\n              F = a.jqx._ptrnd(e.y);\n            }\n\n            if (F > e.y + e.height) {\n              F = e.y + e.height;\n            }\n          } else {\n            F = a.jqx._ptrnd(e.x + o[B].offset);\n\n            if (F > e.x + e.width + p) {\n              F = a.jqx._ptrnd(e.x + e.width);\n            }\n          }\n\n          if (isNaN(F)) {\n            continue;\n          }\n\n          if (!isNaN(k) && Math.abs(F - k) < 2) {\n            continue;\n          }\n\n          if (d[F - 1]) {\n            F--;\n          } else {\n            if (d[F + 1]) {\n              F++;\n            }\n          }\n\n          if (c) {\n            if (F > e.y + e.height + p) {\n              break;\n            }\n          } else {\n            if (F > e.x + e.width + p) {\n              break;\n            }\n          }\n\n          k = F;\n          var w = !v.isMirror ? -t : t;\n\n          if (c) {\n            var s = e.x + e.width + (h.position == \"right\" ? u.left : -u.right);\n\n            if (!z) {\n              s = e.x + (v.isMirror ? u.left : -u.right + e.width);\n            }\n\n            this.renderer.line(s, F, s + w, F, b);\n          } else {\n            var r = e.y + (v.isMirror ? e.height : 0);\n            r += v.isMirror ? -u.bottom : u.top;\n            r = a.jqx._ptrnd(r);\n            this.renderer.line(F, r, F, r - w, b);\n          }\n        }\n      }\n\n      n.tickMarks = n.tickMarks || f.tickMarks;\n      n.gridLines = n.gridLines || f.gridLines;\n      n.alternatingBackground = n.alternatingBackground || f.alternatingBackground;\n    },\n    _calcValueAxisItems: function _calcValueAxisItems(j, d, l) {\n      var n = this._stats.seriesGroups[j];\n\n      if (!n || !n.isValid) {\n        return false;\n      }\n\n      var w = this.seriesGroups[j];\n      var b = w.orientation == \"horizontal\";\n\n      var f = this._getValueAxis(j);\n\n      var m = f.valuesOnTicks != false;\n      var e = f.dataField;\n      var o = n.intervals;\n      var s = d / o;\n      var u = n.min;\n      var r = n.mu;\n      var c = f.logarithmicScale == true;\n      var k = f.logarithmicScaleBase || 10;\n      var h = w.type.indexOf(\"stacked\") != -1 && w.type.indexOf(\"100\") != -1;\n\n      if (c) {\n        r = !isNaN(f.unitInterval) ? f.unitInterval : 1;\n      }\n\n      if (!m) {\n        o = Math.max(o - 1, 1);\n      }\n\n      while (this._renderData.length < j + 1) {\n        this._renderData.push({});\n      }\n\n      this._renderData[j].valueAxis = {};\n      var q = this._renderData[j].valueAxis;\n      q.itemWidth = q.intervalWidth = s;\n      q.items = [];\n      var p = q.items;\n\n      for (var v = 0; v <= o; v++) {\n        var t = 0;\n\n        if (c) {\n          if (h) {\n            t = n.max / Math.pow(k, o - v);\n          } else {\n            t = u * Math.pow(k, v);\n          }\n        } else {\n          t = m ? u + v * r : u + (v + 0.5) * r;\n        }\n\n        if (v % l != 0) {\n          p.push(NaN);\n          continue;\n        }\n\n        p.push(t);\n      }\n\n      q.rangeLength = c && !h ? n.intervals : n.intervals * r;\n\n      if (f.flip != true) {\n        p = p.reverse();\n      }\n\n      return true;\n    },\n    _getDecimalPlaces: function _getDecimalPlaces(b, g, c) {\n      var h = 0;\n\n      if (isNaN(c)) {\n        c = 10;\n      }\n\n      for (var f = 0; f < b.length; f++) {\n        var k = g === undefined ? b[f] : b[f][g];\n\n        if (isNaN(k)) {\n          continue;\n        }\n\n        var d = k.toString();\n\n        for (var e = 0; e < d.length; e++) {\n          if (d[e] < \"0\" || d[e] > \"9\") {\n            h = d.length - (e + 1);\n\n            if (h >= 0) {\n              return Math.min(h, c);\n            }\n          }\n        }\n\n        if (h > 0) {\n          k *= Math.pow(10, h);\n        }\n\n        while (Math.round(k) != k && h < c) {\n          h++;\n          k *= 10;\n        }\n      }\n\n      return h;\n    },\n    _renderValueAxis: function _renderValueAxis(f, x, L, e) {\n      var K = this.seriesGroups[f];\n      var P = K.orientation == \"horizontal\";\n\n      var r = this._getValueAxis(f);\n\n      if (!r) {\n        throw \"SeriesGroup \" + f + \" is missing valueAxis definition\";\n      }\n\n      var E = {\n        width: 0,\n        height: 0\n      };\n\n      if (!this._isGroupVisible(f) || this._isPieOnlySeries() || K.type == \"spider\") {\n        return E;\n      }\n\n      var O = r.valuesOnTicks != false;\n      var F = this._stats.seriesGroups[f];\n      var j = F.mu;\n      var D = r.logarithmicScale == true;\n      var A = r.logarithmicScaleBase || 10;\n\n      if (D) {\n        j = !isNaN(r.unitInterval) ? r.unitInterval : 1;\n      }\n\n      if (j == 0) {\n        j = 1;\n      }\n\n      if (isNaN(j)) {\n        return E;\n      }\n\n      var I = this._getAxisSettings(r);\n\n      var q = I.title,\n          t = I.labels;\n      var k = r.labels || {};\n\n      var v = this._get([r.horizontalTextAlignment, k.horizontalAlignment]);\n\n      if (!v && t.angle == 0) {\n        t.halign = P ? \"center\" : r.position == \"right\" ? \"left\" : \"right\";\n      }\n\n      var o = this._get([t.step, t.unitInterval / j]);\n\n      if (isNaN(o)) {\n        o = 1;\n      }\n\n      o = Math.max(1, Math.round(o));\n\n      if (!this._calcValueAxisItems(f, P ? x.width : x.height, o) || !I.visible) {\n        return E;\n      }\n\n      if (!P) {\n        q.angle = !this.rtl ? -90 : 90;\n\n        if (q.rotationPoint == \"centercenter\") {\n          if (q.valign == \"top\") {\n            q.rotationPoint = \"rightcenter\";\n          } else {\n            if (q.valign == \"bottom\") {\n              q.rotationPoint = \"leftcenter\";\n            }\n          }\n        }\n      }\n\n      var l = this._renderData[f].valueAxis;\n      var h = t.formatSettings;\n      var c = K.type.indexOf(\"stacked\") != -1 && K.type.indexOf(\"100\") != -1;\n\n      if (c && !h) {\n        h = {\n          sufix: \"%\"\n        };\n      }\n\n      if (!t.formatFunction && (!h || !h.decimalPlaces)) {\n        h = h || {};\n        h.decimalPlaces = this._getDecimalPlaces([F.min, F.max, j], undefined, 3);\n      }\n\n      var d = I.gridLines;\n      var m = D ? j : this._getInterval(d, j);\n      var z = P ? x.width : x.height;\n      var M = r.flip == true;\n      r.flip = !M;\n      var N = {\n        min: F.min,\n        max: F.max,\n        logAxis: {\n          enabled: D == true,\n          base: A,\n          minPow: F.minPow,\n          maxPow: F.maxPow\n        }\n      };\n\n      if (d.visible || r.alternatingBackgroundColor || r.alternatingBackgroundColor2) {\n        d.offsets = this._getOffsets(\"gridLines\", r, z, N, I, {\n          left: 0,\n          right: 0\n        }, O, j);\n      }\n\n      var u = I.tickMarks;\n\n      if (u.visible) {\n        u.offsets = this._getOffsets(\"tickMarks\", r, z, N, I, {\n          left: 0,\n          right: 0\n        }, O, j);\n      }\n\n      var G = this._getOffsets(\"labels\", r, z, N, I, {\n        left: 0,\n        right: 0\n      }, O, j, !O);\n\n      r.flip = M;\n      var p = [];\n      var n;\n\n      if (this._elementRenderInfo && this._elementRenderInfo.length > f) {\n        n = this._elementRenderInfo[f].valueAxis;\n      }\n\n      for (var J = 0; J < G.length; J++) {\n        var H = G[J].value;\n\n        if (isNaN(G[J].offset)) {\n          p.push(undefined);\n          continue;\n        }\n\n        var w = t.formatFunction ? t.formatFunction(H) : !isNaN(H) ? this._formatNumber(H, h) : H;\n        var b = {\n          key: H,\n          text: w\n        };\n\n        if (n && n.itemOffsets[H]) {\n          b.x = n.itemOffsets[H].x;\n          b.y = n.itemOffsets[H].y;\n        }\n\n        b.targetX = G[J].offset;\n\n        if (!isNaN(b.targetX)) {\n          p.push(b);\n        }\n      }\n\n      var C = P && r.position == \"top\" || !P && r.position == \"right\" || !P && this.rtl && r.position != \"left\";\n      var y = {\n        items: p,\n        renderData: l\n      };\n\n      var B = this._getAnimProps(f);\n\n      var s = B.enabled && p.length < 500 ? B.duration : 0;\n\n      if (this.enableAxisTextAnimation == false) {\n        s = 0;\n      }\n\n      l.settings = I;\n      l.isMirror = C;\n      l.rect = x;\n      return this._renderAxis(!P, C, I, x, e, j, D, true, y, L, s);\n    },\n    _objectsArraysToArray: function _objectsArraysToArray(e, d) {\n      var b = [];\n\n      if (!a.isArray(e)) {\n        return b;\n      }\n\n      for (var c = 0; c < e.length; c++) {\n        b.push(e[c][d]);\n      }\n\n      return b;\n    },\n    _arraysToObjectsArray: function _arraysToObjectsArray(f, e) {\n      var c = [];\n\n      if (f.length != e.length) {\n        return c;\n      }\n\n      for (var d = 0; d < f.length; d++) {\n        for (var b = 0; b < f[d].length; b++) {\n          if (c.length <= b) {\n            c.push({});\n          }\n\n          c[b][e[d]] = f[d][b];\n        }\n      }\n\n      return c;\n    },\n    _valuesToOffsets: function _valuesToOffsets(q, e, l, r, p, f, c) {\n      var h = [];\n\n      if (!e || !a.isArray(q)) {\n        return h;\n      }\n\n      var d = l.logAxis.base;\n      var m = l.logAxis.enabled ? \"logarithmic\" : \"linear\";\n      var k = e.flip;\n      var o = r;\n      var b = 0,\n          g = 0;\n\n      if (p && !isNaN(p.left)) {\n        b = p.left;\n      }\n\n      if (p && !isNaN(p.right)) {\n        g = p.right;\n      }\n\n      o = r - b - g;\n      r = o;\n\n      for (var j = 0; j < q.length; j++) {\n        var n = this._jqxPlot.scale(q[j], {\n          min: l.min.valueOf(),\n          max: l.max.valueOf(),\n          type: m,\n          base: d\n        }, {\n          min: 0,\n          max: f ? r : o,\n          flip: k\n        }, {});\n\n        if (!isNaN(n)) {\n          if (!isNaN(c)) {\n            n += c;\n          }\n\n          if (n <= r + b + g + 1) {\n            h.push(a.jqx._ptrnd(n));\n          } else {\n            h.push(NaN);\n          }\n        } else {\n          h.push(NaN);\n        }\n      }\n\n      return h;\n    },\n    _generateIntervalValues: function _generateIntervalValues(n, c, b, d, e) {\n      var j = [];\n      var g = n.min;\n      var m = n.max;\n\n      if (n.logAxis && n.logAxis.enabled) {\n        g = n.logAxis.minPow;\n        m = n.logAxis.maxPow;\n      }\n\n      if (g == undefined || m == undefined) {\n        return j;\n      }\n\n      if (g == m) {\n        if (n.logAxis && n.logAxis.enabled) {\n          return [Math.pow(n.logAxis.base, g)];\n        } else {\n          return [g];\n        }\n      }\n\n      var l = 1;\n\n      if (b < 1) {\n        l = 1000000;\n        g *= l;\n        m *= l;\n        b *= l;\n      }\n\n      for (var h = g; h <= m; h += b) {\n        j.push(h / l + (e ? b / 2 : 0));\n      }\n\n      if (c > b) {\n        var f = [];\n        var k = Math.round(c / b);\n\n        for (var h = 0; h < j.length; h++) {\n          if (h % k == 0) {\n            f.push(j[h]);\n          }\n        }\n\n        j = f;\n      }\n\n      if (n.logAxis && n.logAxis.enabled) {\n        for (var h = 0; h < j.length; h++) {\n          j[h] = Math.pow(n.logAxis.base, j[h]);\n        }\n      }\n\n      return j;\n    },\n    _generateDTOffsets: function _generateDTOffsets(p, s, x, n, y, c, o, b, u, v, g) {\n      if (!o) {\n        o = \"day\";\n      }\n\n      var f = [];\n\n      if (p > s) {\n        return f;\n      }\n\n      if (p == s) {\n        if (v) {\n          f.push({\n            offset: b ? x / 2 : n.left,\n            value: p\n          });\n        } else {\n          if (b) {\n            f.push({\n              offset: x / 2,\n              value: p\n            });\n          }\n        }\n\n        return f;\n      }\n\n      var j = x - n.left - n.right;\n      var w = p;\n      var k = n.left;\n      var e = k;\n      c = Math.max(c, 1);\n      var m = c;\n      var d = Math.min(1, c);\n\n      if (c > 1 && o != \"millisecond\") {\n        c = 1;\n      }\n\n      while (a.jqx._ptrnd(e) <= a.jqx._ptrnd(n.left + j + (b ? 0 : n.right))) {\n        f.push({\n          offset: e,\n          value: w\n        });\n        var z = new Date(w.valueOf());\n\n        if (o == \"millisecond\") {\n          z.setMilliseconds(w.getMilliseconds() + c);\n        } else {\n          if (o == \"second\") {\n            z.setSeconds(w.getSeconds() + c);\n          } else {\n            if (o == \"minute\") {\n              z.setMinutes(w.getMinutes() + c);\n            } else {\n              if (o == \"hour\") {\n                var l = z.valueOf();\n                z.setHours(w.getHours() + c);\n\n                if (l == z.valueOf()) {\n                  z.setHours(w.getHours() + c + 1);\n                }\n              } else {\n                if (o == \"day\") {\n                  z.setDate(w.getDate() + c);\n                } else {\n                  if (o == \"month\") {\n                    z.setMonth(w.getMonth() + c);\n                  } else {\n                    if (o == \"year\") {\n                      z.setFullYear(w.getFullYear() + c);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        w = z;\n        e = k + (w.valueOf() - p.valueOf()) * d / (s.valueOf() - p.valueOf()) * j;\n      }\n\n      if (g) {\n        for (var r = 0; r < f.length; r++) {\n          f[r].offset = x - f[r].offset;\n        }\n      }\n\n      if (m > 1 && o != \"millisecond\") {\n        var q = [];\n\n        for (var r = 0; r < f.length; r += m) {\n          q.push({\n            offset: f[r].offset,\n            value: f[r].value\n          });\n        }\n\n        f = q;\n      }\n\n      if (!b && !v && f.length > 1) {\n        var q = [];\n        q.push({\n          offset: 0,\n          value: undefined\n        });\n\n        for (var r = 1; r < f.length; r++) {\n          q.push({\n            offset: f[r - 1].offset + (f[r].offset - f[r - 1].offset) / 2,\n            value: undefined\n          });\n        }\n\n        var t = q.length;\n\n        if (t > 1) {\n          q.push({\n            offset: q[t - 1].offset + (q[t - 1].offset - q[t - 2].offset)\n          });\n        } else {\n          q.push({\n            offset: x,\n            value: undefined\n          });\n        }\n\n        f = q;\n      }\n\n      if (y > c) {\n        var q = [];\n        var h = Math.round(y / m);\n\n        for (var r = 0; r < f.length; r++) {\n          if (r % h == 0) {\n            q.push({\n              offset: f[r].offset,\n              value: f[r].value\n            });\n          }\n        }\n\n        f = q;\n      }\n\n      return f;\n    },\n    _hasStackValueReversal: function _hasStackValueReversal(e, s) {\n      var g = this.seriesGroups[e];\n      var h = -1 != g.type.indexOf(\"stacked\");\n\n      if (!h) {\n        return false;\n      }\n\n      var b = -1 != g.type.indexOf(\"waterfall\");\n\n      var q = this._getDataLen(e);\n\n      var t = 0;\n      var l = false;\n      var v = [];\n\n      for (var o = 0; o < g.series.length; o++) {\n        v[o] = this._isSerieVisible(e, o);\n      }\n\n      for (var p = 0; p < q; p++) {\n        var m = b && p != 0 ? t : s;\n        var d = 0,\n            r = 0;\n        var c = undefined;\n\n        if (!b) {\n          l = false;\n        }\n\n        for (var n = 0; n < g.series.length; n++) {\n          if (!v[n]) {\n            continue;\n          }\n\n          var u = this._getDataValueAsNumber(p, g.series[n].dataField, e);\n\n          if (isNaN(u)) {\n            continue;\n          }\n\n          if (g.series[n].summary) {\n            var f = this._getDataValue(p, g.series[n].summary, e);\n\n            if (undefined !== f) {\n              continue;\n            }\n          }\n\n          var k = !l ? u < s : u < 0;\n          l = true;\n\n          if (c == undefined) {\n            c = k;\n          }\n\n          if (k != c) {\n            return true;\n          }\n\n          c = k;\n          t += u;\n        }\n      }\n\n      return false;\n    },\n    _getValueAxis: function _getValueAxis(b) {\n      var c = b == undefined ? this.valueAxis : this.seriesGroups[b].valueAxis || this.valueAxis;\n\n      if (!c) {\n        c = this.valueAxis = {};\n      }\n\n      return c;\n    },\n    _buildStats: function _buildStats(H) {\n      var U = {\n        seriesGroups: []\n      };\n      this._stats = U;\n\n      for (var s = 0; s < this.seriesGroups.length; s++) {\n        var A = this.seriesGroups[s];\n        U.seriesGroups[s] = {};\n\n        var D = this._getXAxis(s);\n\n        var n = this._getValueAxis(s);\n\n        var q = this._getXAxisStats(s, D, A.orientation != \"horizontal\" ? H.width : H.height);\n\n        var x = U.seriesGroups[s];\n        x.isValid = true;\n        var I = A.orientation == \"horizontal\" ? H.width : H.height;\n        var K = n.logarithmicScale == true;\n        var J = n.logarithmicScaleBase;\n\n        if (isNaN(J)) {\n          J = 10;\n        }\n\n        var E = -1 != A.type.indexOf(\"stacked\");\n        var e = E && -1 != A.type.indexOf(\"100\");\n        var G = -1 != A.type.indexOf(\"range\");\n        var Q = A.type.indexOf(\"waterfall\") != -1;\n\n        if (Q && !this._moduleWaterfall) {\n          throw \"Please include 'jqxchart.waterfall.js'\";\n        }\n\n        if (e) {\n          x.psums = [];\n          x.nsums = [];\n        }\n\n        var t = NaN,\n            M = NaN;\n        var d = NaN,\n            f = NaN;\n        var r = n ? n.baselineValue : NaN;\n\n        if (isNaN(r)) {\n          r = K && !e ? 1 : 0;\n        }\n\n        var g = false;\n\n        if (r != 0 && E) {\n          g = this._hasStackValueReversal(s, r);\n\n          if (g) {\n            r = 0;\n          }\n        }\n\n        if (E && Q) {\n          g = this._hasStackValueReversal(s, r);\n        }\n\n        var z = this._getDataLen(s);\n\n        var c = 0;\n        var V = NaN;\n        var m = [];\n\n        if (Q) {\n          for (var k = 0; k < A.series.length; k++) {\n            m.push(NaN);\n          }\n        }\n\n        var v = NaN;\n\n        for (var T = 0; T < z && x.isValid; T++) {\n          if (D.rangeSelector) {\n            var h = D.dataField ? this._getDataValue(T, D.dataField, s) : T;\n\n            if (h && q.isDateTime) {\n              h = this._castAsDate(h, D.dateFormat);\n            }\n\n            if (q.useIndeces) {\n              h = T;\n            }\n\n            if (h && (h.valueOf() < q.min.valueOf() || h.valueOf() > q.max.valueOf())) {\n              continue;\n            }\n          }\n\n          var W = n.minValue;\n          var C = n.maxValue;\n\n          if (n.baselineValue) {\n            if (isNaN(W)) {\n              W = r;\n            } else {\n              W = Math.min(r, W);\n            }\n\n            if (isNaN(C)) {\n              C = r;\n            } else {\n              C = Math.max(r, C);\n            }\n          }\n\n          var u = 0,\n              w = 0;\n\n          for (var k = 0; A.series && k < A.series.length; k++) {\n            if (!this._isSerieVisible(s, k)) {\n              continue;\n            }\n\n            var F = NaN,\n                P = NaN,\n                y = NaN;\n\n            if (A.type.indexOf(\"candle\") != -1 || A.type.indexOf(\"ohlc\") != -1) {\n              var b = [\"Open\", \"Low\", \"Close\", \"High\"];\n\n              for (var R in b) {\n                var l = this._getDataValueAsNumber(T, A.series[k][\"dataField\" + b[R]], s);\n\n                if (isNaN(l)) {\n                  continue;\n                }\n\n                y = isNaN(P) ? l : Math.min(y, l);\n                P = isNaN(P) ? l : Math.max(P, l);\n              }\n            } else {\n              if (G) {\n                var X = this._getDataValueAsNumber(T, A.series[k].dataFieldFrom, s);\n\n                var B = this._getDataValueAsNumber(T, A.series[k].dataFieldTo, s);\n\n                P = Math.max(X, B);\n                y = Math.min(X, B);\n              } else {\n                F = this._getDataValueAsNumber(T, A.series[k].dataField, s);\n\n                if (Q) {\n                  if (this._isSummary(s, T)) {\n                    var S = this._getDataValue(T, A.series[k].summary, s);\n\n                    if (S !== undefined) {\n                      continue;\n                    }\n                  }\n\n                  if (!E) {\n                    if (isNaN(m[k])) {\n                      m[k] = F;\n                    } else {\n                      F += m[k];\n                    }\n\n                    m[k] = F;\n                  } else {\n                    if (!isNaN(v)) {\n                      F += v;\n                    }\n\n                    v = F;\n                  }\n                }\n\n                if (isNaN(F) || K && F <= 0) {\n                  continue;\n                }\n\n                y = P = F;\n              }\n            }\n\n            if ((isNaN(C) || P > C) && (isNaN(n.maxValue) ? true : P <= n.maxValue)) {\n              C = P;\n            }\n\n            if ((isNaN(W) || y < W) && (isNaN(n.minValue) ? true : y >= n.minValue)) {\n              W = y;\n            }\n\n            if (!isNaN(F) && E && !Q) {\n              if (F > r) {\n                u += F;\n              } else {\n                if (F < r) {\n                  w += F;\n                }\n              }\n            }\n          }\n\n          if (!e) {\n            if (!isNaN(n.maxValue)) {\n              u = Math.min(n.maxValue, u);\n            }\n\n            if (!isNaN(n.minValue)) {\n              w = Math.max(n.minValue, w);\n            }\n          }\n\n          if (K && e) {\n            for (var k = 0; k < A.series.length; k++) {\n              if (!this._isSerieVisible(s, k)) {\n                V = 0.01;\n                continue;\n              }\n\n              var F = this._getDataValueAsNumber(T, A.series[k].dataField, s);\n\n              if (isNaN(F) || F <= 0) {\n                V = 0.01;\n                continue;\n              }\n\n              var N = u == 0 ? 0 : F / u;\n\n              if (isNaN(V) || N < V) {\n                V = N;\n              }\n            }\n          }\n\n          var o = u - w;\n\n          if (c < o) {\n            c = o;\n          }\n\n          if (e) {\n            x.psums[T] = u;\n            x.nsums[T] = w;\n          }\n\n          if (C > M || isNaN(M)) {\n            M = C;\n          }\n\n          if (W < t || isNaN(t)) {\n            t = W;\n          }\n\n          if (u > d || isNaN(d)) {\n            d = u;\n          }\n\n          if (w < f || isNaN(f)) {\n            f = w;\n          }\n        }\n\n        if (e) {\n          d = d == 0 ? 0 : Math.max(d, -f);\n          f = f == 0 ? 0 : Math.min(f, -d);\n        }\n\n        if (t == M) {\n          if (!isNaN(n.minValue) && isNaN(n.maxValue)) {\n            t = n.minValue;\n            M = K ? t * J : t + 1;\n          } else {\n            if (isNaN(n.minValue) && !isNaN(n.maxValue)) {\n              M = n.maxValue;\n              t = K ? M / J : M - 1;\n            }\n          }\n        }\n\n        if (t == M) {\n          if (t == 0) {\n            t = -1;\n            M = 1;\n          } else {\n            if (t < 0) {\n              M = 0;\n            } else {\n              if (!K) {\n                t = 0;\n              } else {\n                if (t == 1) {\n                  t = t / J;\n                  M = M * J;\n                }\n              }\n            }\n          }\n        }\n\n        var O = {\n          gmin: t,\n          gmax: M,\n          gsumP: d,\n          gsumN: f,\n          gbase: r,\n          isLogAxis: K,\n          logBase: J,\n          minPercent: V,\n          gMaxRange: c,\n          isStacked: E,\n          isStacked100: e,\n          isWaterfall: Q,\n          hasStackValueReversal: g,\n          valueAxis: n,\n          valueAxisSize: I\n        };\n\n        if (O.isStacked) {\n          if (O.gsumN < 0) {\n            O.gmin = Math.min(O.gmin, O.gbase + O.gsumN);\n          }\n\n          if (O.gsumP > 0) {\n            O.gmax = Math.max(O.gmax, O.gbase + O.gsumP);\n          }\n        }\n\n        x.context = O;\n      }\n\n      this._mergeCommonValueAxisStats();\n\n      for (var T = 0; T < U.seriesGroups.length; T++) {\n        var x = U.seriesGroups[T];\n\n        if (!x.isValid) {\n          continue;\n        }\n\n        var L = this._calcOutputGroupStats(x.context);\n\n        for (var R in L) {\n          x[R] = L[R];\n        }\n\n        delete x.context;\n      }\n    },\n    _mergeCommonValueAxisStats: function _mergeCommonValueAxisStats() {\n      var f = {};\n\n      for (var e = 0; e < this.seriesGroups.length; e++) {\n        if (!this._isGroupVisible(e)) {\n          continue;\n        }\n\n        if (this.seriesGroups[e].valueAxis) {\n          continue;\n        }\n\n        var d = this._stats.seriesGroups[e].context;\n        f.gbase = d.gbase;\n\n        if (isNaN(f.gmin) || d.gmin < f.gmin) {\n          f.gmin = d.gmin;\n        }\n\n        if (isNaN(f.gmax) || d.gmax > f.gmax) {\n          f.gmax = d.gmax;\n        }\n\n        if (isNaN(f.gsumP) || d.gsumP > f.gsumP) {\n          f.gsumP = d.gsumP;\n        }\n\n        if (isNaN(f.gsumN) || d.gsumN < f.gsumN) {\n          f.gsumN = d.gsumN;\n        }\n\n        if (isNaN(f.logBase) || d.logBase < f.logBase) {\n          f.logBase = d.logBase;\n        }\n\n        if (isNaN(f.minPercent) || d.minPercent < f.minPercent) {\n          f.minPercent = d.minPercent;\n        }\n\n        if (f.gsumN > 0) {\n          f.gmin = Math.min(f.gmin, f.gbase + f.gsumN);\n        }\n\n        if (f.gsumP > 0) {\n          f.gmax = Math.max(f.gmax, f.gbase + f.gsumP);\n        }\n      }\n\n      for (var e = 0; e < this.seriesGroups.length; e++) {\n        if (this.seriesGroups[e].valueAxis) {\n          continue;\n        }\n\n        var b = this._stats.seriesGroups[e].context;\n\n        for (var c in f) {\n          b[c] = f[c];\n        }\n      }\n    },\n    _calcOutputGroupStats: function _calcOutputGroupStats(g) {\n      var c = g.gmin,\n          f = g.gmax,\n          y = g.gsumP,\n          z = g.gsumN,\n          x = g.gbase,\n          d = g.isLogAxis,\n          j = g.logBase,\n          t = g.minPercent,\n          k = g.gMaxRange,\n          l = g.isStacked,\n          h = g.isStacked100,\n          e = g.isWaterfall,\n          n = g.hasStackValueReversal,\n          w = g.valueAxis,\n          u = g.valueAxisSize;\n      var s = g.valueAxis.unitInterval;\n\n      if (!s) {\n        s = this._calcInterval(c, f, Math.max(u / 80, 2));\n      }\n\n      if (c == f) {\n        c = x;\n        f = 2 * f;\n      }\n\n      var i = NaN;\n      var b = 0;\n      var q = 0;\n\n      if (d) {\n        if (h) {\n          i = 0;\n          var r = 1;\n          b = q = a.jqx.log(100, j);\n\n          while (r > t) {\n            r /= j;\n            b--;\n            i++;\n          }\n\n          c = Math.pow(j, b);\n        } else {\n          if (l && !e) {\n            f = Math.max(f, y);\n          }\n\n          q = a.jqx._rnd(a.jqx.log(f, j), 1, true);\n          f = Math.pow(j, q);\n          b = a.jqx._rnd(a.jqx.log(c, j), 1, false);\n          c = Math.pow(j, b);\n        }\n\n        s = j;\n      }\n\n      if (c < z) {\n        z = c;\n      }\n\n      if (f > y) {\n        y = f;\n      }\n\n      var v = c;\n      var o = f;\n\n      if (!d) {\n        if (0 != Math.abs(o - v) % s) {\n          v = a.jqx._rnd(c, s, false);\n          o = a.jqx._rnd(f, s, true);\n        }\n      }\n\n      if (h && o > 100) {\n        o = 100;\n      }\n\n      if (h && !d) {\n        o = o > 0 ? 100 : 0;\n        v = v < 0 ? -100 : 0;\n        s = w.unitInterval;\n\n        if (isNaN(s) || s <= 0 || s >= 100) {\n          s = 10;\n        }\n\n        if (100 % s != 0) {\n          for (; s >= 1; s--) {\n            if (100 % s == 0) {\n              break;\n            }\n          }\n        }\n      }\n\n      if (isNaN(o) || isNaN(v) || isNaN(s)) {\n        return {};\n      }\n\n      if (isNaN(i)) {\n        i = parseInt(((o - v) / (s == 0 ? 1 : s)).toFixed());\n      }\n\n      if (d && !h) {\n        i = q - b;\n        k = Math.pow(j, i);\n      }\n\n      if (i < 1) {\n        return {};\n      }\n\n      var m = {\n        min: v,\n        max: o,\n        logarithmic: d,\n        logBase: j,\n        base: d ? v : x,\n        minPow: b,\n        maxPow: q,\n        sumP: y,\n        sumN: z,\n        mu: s,\n        maxRange: k,\n        intervals: i,\n        hasStackValueReversal: n\n      };\n      return m;\n    },\n    _getDataLen: function _getDataLen(c) {\n      var b = this.source;\n\n      if (c != undefined && c != -1 && this.seriesGroups[c].source) {\n        b = this.seriesGroups[c].source;\n      }\n\n      if (b instanceof a.jqx.dataAdapter) {\n        b = b.records;\n      }\n\n      if (b) {\n        return b.length;\n      }\n\n      return 0;\n    },\n    _getDataValue: function _getDataValue(b, e, d) {\n      var c = this.source;\n\n      if (d != undefined && d != -1) {\n        c = this.seriesGroups[d].source || c;\n      }\n\n      if (c instanceof a.jqx.dataAdapter) {\n        c = c.records;\n      }\n\n      if (!c || b < 0 || b > c.length - 1) {\n        return undefined;\n      }\n\n      if (a.isFunction(e)) {\n        return e(b, c);\n      }\n\n      return e && e != \"\" ? c[b][e] : c[b];\n    },\n    _getDataValueAsNumber: function _getDataValueAsNumber(b, e, c) {\n      var d = this._getDataValue(b, e, c);\n\n      if (this._isDate(d)) {\n        return d.valueOf();\n      }\n\n      if (typeof d != \"number\") {\n        d = parseFloat(d);\n      }\n\n      if (typeof d != \"number\") {\n        d = undefined;\n      }\n\n      return d;\n    },\n    _isPieGroup: function _isPieGroup(b) {\n      var c = this.seriesGroups[b];\n\n      if (!c || !c.type) {\n        return false;\n      }\n\n      return c.type.indexOf(\"pie\") != -1 || c.type.indexOf(\"donut\") != -1;\n    },\n    _renderPieSeries: function _renderPieSeries(e, c) {\n      var f = this._getDataLen(e);\n\n      var g = this.seriesGroups[e];\n\n      var m = this._calcGroupOffsets(e, c).offsets;\n\n      for (var p = 0; p < g.series.length; p++) {\n        var k = g.series[p];\n\n        if (k.customDraw) {\n          continue;\n        }\n\n        var v = this._getSerieSettings(e, p);\n\n        var h = k.colorScheme || g.colorScheme || this.colorScheme;\n\n        var r = this._getAnimProps(e, p);\n\n        var b = r.enabled && f < 5000 && !this._isToggleRefresh && this._isVML != true ? r.duration : 0;\n\n        if (a.jqx.mobile.isMobileBrowser() && this.renderer instanceof a.jqx.HTML5Renderer) {\n          b = 0;\n        }\n\n        var t = this._get([k.minAngle, k.startAngle]);\n\n        if (isNaN(t) || t < 0 || t > 360) {\n          t = 0;\n        }\n\n        var x = this._get([k.maxAngle, k.endAngle]);\n\n        if (isNaN(x) || x < 0 || x > 360) {\n          x = 360;\n        }\n\n        var o = {\n          rect: c,\n          minAngle: t,\n          maxAngle: x,\n          groupIndex: e,\n          serieIndex: p,\n          settings: v,\n          items: []\n        };\n\n        for (var u = 0; u < f; u++) {\n          var n = m[p][u];\n\n          if (!n.visible) {\n            continue;\n          }\n\n          var q = n.fromAngle;\n          var d = n.toAngle;\n          var w = this.renderer.pieslice(n.x, n.y, n.innerRadius, n.outerRadius, q, b == 0 ? d : q, n.centerOffset);\n\n          this._setRenderInfo(e, p, u, {\n            element: w\n          });\n\n          var j = {\n            displayValue: n.displayValue,\n            itemIndex: u,\n            visible: n.visible,\n            x: n.x,\n            y: n.y,\n            innerRadius: n.innerRadius,\n            outerRadius: n.outerRadius,\n            fromAngle: q,\n            toAngle: d,\n            centerOffset: n.centerOffset\n          };\n          o.items.push(j);\n        }\n\n        this._animatePieSlices(o, 0);\n\n        var l = this;\n\n        this._enqueueAnimation(\"series\", undefined, undefined, b, function (s, i, y) {\n          l._animatePieSlices(i, y);\n        }, o);\n      }\n    },\n    _sliceSortFunction: function _sliceSortFunction(d, c) {\n      return d.fromAngle - c.fromAngle;\n    },\n    _animatePieSlices: function _animatePieSlices(o, c) {\n      var j;\n\n      if (this._elementRenderInfo && this._elementRenderInfo.length > o.groupIndex && this._elementRenderInfo[o.groupIndex].series && this._elementRenderInfo[o.groupIndex].series.length > o.serieIndex) {\n        j = this._elementRenderInfo[o.groupIndex].series[o.serieIndex];\n      }\n\n      var f = 360 * c;\n      var u = this.seriesGroups[o.groupIndex];\n\n      var n = this._getLabelsSettings(o.groupIndex, o.serieIndex, NaN);\n\n      var m = n.visible;\n      var b = [];\n\n      for (var t = 0; t < o.items.length; t++) {\n        var w = o.items[t];\n\n        if (!w.visible) {\n          continue;\n        }\n\n        var p = w.fromAngle;\n        var e = w.fromAngle + c * (w.toAngle - w.fromAngle);\n\n        if (j && j[w.displayValue]) {\n          var l = j[w.displayValue].fromAngle;\n          var d = j[w.displayValue].toAngle;\n          p = l + (p - l) * c;\n          e = d + (e - d) * c;\n        }\n\n        b.push({\n          index: t,\n          from: p,\n          to: e\n        });\n      }\n\n      if (j) {\n        b.sort(this._sliceSortFunction);\n      }\n\n      var x = NaN;\n\n      for (var t = 0; t < b.length; t++) {\n        var w = o.items[b[t].index];\n\n        var q = this._getRenderInfo(o.groupIndex, o.serieIndex, w.itemIndex);\n\n        var p = b[t].from;\n        var e = b[t].to;\n\n        if (j) {\n          if (!isNaN(x) && p > x) {\n            p = x;\n          }\n\n          x = e;\n\n          if (t == b.length - 1 && e != b[0].from) {\n            e = o.maxAngle + b[0].from;\n          }\n        }\n\n        var r = this.renderer.pieSlicePath(w.x, w.y, w.innerRadius, w.outerRadius, p, e, w.centerOffset);\n        this.renderer.attr(q.element, {\n          d: r\n        });\n\n        var h = this._getColors(o.groupIndex, o.serieIndex, w.itemIndex, \"radialGradient\", w.outerRadius);\n\n        var v = o.settings;\n        q.colors = h;\n        q.settings = v;\n        this.renderer.attr(q.element, {\n          fill: h.fillColor,\n          stroke: h.lineColor,\n          \"stroke-width\": v.stroke,\n          \"fill-opacity\": v.opacity,\n          \"stroke-opacity\": v.opacity,\n          \"stroke-dasharray\": \"none\" || v.dashStyle\n        });\n        var k = u.series[o.serieIndex];\n\n        if (m) {\n          this._showPieLabel(o.groupIndex, o.serieIndex, w.itemIndex, n);\n        }\n\n        if (c == 1) {\n          this._installHandlers(q.element, \"pieslice\", o.groupIndex, o.serieIndex, w.itemIndex);\n        }\n      }\n    },\n    _showPieLabel: function _showPieLabel(e, f, A, p, h) {\n      var k = this._renderData[e].offsets[f][A];\n\n      if (k.elementInfo.labelElement) {\n        this.renderer.removeElement(k.elementInfo.labelElement);\n      }\n\n      if (!p) {\n        p = this._getLabelsSettings(e, f, NaN);\n      }\n\n      if (!p.visible) {\n        return;\n      }\n\n      var B = k.fromAngle,\n          D = k.toAngle;\n      var l = Math.abs(B - D);\n      var q = l > 180 ? 1 : 0;\n\n      if (l > 360) {\n        B = 0;\n        D = 360;\n      }\n\n      var r = B * Math.PI * 2 / 360;\n      var i = D * Math.PI * 2 / 360;\n      var j = l / 2 + B;\n      j = j % 360;\n      var C = j * Math.PI * 2 / 360;\n      var v;\n\n      if (p.autoRotate == true) {\n        v = j < 90 || j > 270 ? 360 - j : 180 - j;\n      }\n\n      var u = p.linesEnabled;\n\n      var o = this._showLabel(e, f, A, {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      }, \"center\", \"center\", true, false, false, v);\n\n      var d = p.radius || k.outerRadius + Math.max(o.width, o.height);\n\n      if (this._isPercent(d)) {\n        d = parseFloat(d) / 100 * Math.min(this._plotRect.width, this._plotRect.height) / 2;\n      }\n\n      d += k.centerOffset;\n\n      if (isNaN(h)) {\n        h = 0;\n      }\n\n      d += h;\n      var x = this.seriesGroups[e];\n      var n = x.series[f];\n      var z = a.jqx.getNum([n.offsetX, x.offsetX, this._plotRect.width / 2]);\n      var y = a.jqx.getNum([n.offsetY, x.offsetY, this._plotRect.height / 2]);\n      var c = this._plotRect.x + z;\n      var b = this._plotRect.y + y;\n\n      var w = this._adjustTextBoxPosition(c, b, o, d, j, k.outerRadius > d, p.linesAngles != false, p.autoRotate == true);\n\n      var m = {};\n      k.elementInfo.labelElement = this._showLabel(e, f, A, {\n        x: w.x,\n        y: w.y,\n        width: o.width,\n        height: o.height\n      }, \"left\", \"top\", false, false, false, v, m);\n\n      if (d > k.outerRadius + 5 && u != false) {\n        var t = {\n          lineColor: k.elementInfo.colors.lineColor,\n          stroke: k.elementInfo.settings.stroke,\n          opacity: k.elementInfo.settings.opacity,\n          dashStyle: k.elementInfo.settings.dashStyle\n        };\n        k.elementInfo.labelArrowPath = this._updateLebelArrowPath(k.elementInfo.labelArrowPath, c, b, d, k.outerRadius + h, C, p.linesAngles != false, t, m);\n      }\n    },\n    _updateLebelArrowPath: function _updateLebelArrowPath(d, j, f, h, l, g, o, e, r) {\n      var c = a.jqx._ptrnd(j + (h - 0) * Math.cos(g));\n\n      var n = a.jqx._ptrnd(f - (h - 0) * Math.sin(g));\n\n      var b = a.jqx._ptrnd(j + (l + 2) * Math.cos(g));\n\n      var m = a.jqx._ptrnd(f - (l + 2) * Math.sin(g));\n\n      var p = [];\n      p.push({\n        x: r.x + r.width / 2,\n        y: r.y\n      });\n      p.push({\n        x: r.x + r.width / 2,\n        y: r.y + r.height\n      });\n      p.push({\n        x: r.x,\n        y: r.y + r.height / 2\n      });\n      p.push({\n        x: r.x + r.width,\n        y: r.y + r.height / 2\n      });\n\n      if (!o) {\n        p.push({\n          x: r.x,\n          y: r.y\n        });\n        p.push({\n          x: r.x + r.width,\n          y: r.y\n        });\n        p.push({\n          x: r.x + r.width,\n          y: r.y + r.height\n        });\n        p.push({\n          x: r.x,\n          y: r.y + r.height\n        });\n      }\n\n      p = p.sort(function (s, i) {\n        return a.jqx._ptdist(s.x, s.y, j, f) - a.jqx._ptdist(i.x, i.y, j, f);\n      });\n      p = p.sort(function (s, i) {\n        return Math.abs(s.x - j) + Math.abs(s.y - f) - (Math.abs(i.x - j) + Math.abs(i.y - f));\n      });\n\n      for (var k = 0; k < p.length; k++) {\n        p[k].x = a.jqx._ptrnd(p[k].x);\n        p[k].y = a.jqx._ptrnd(p[k].y);\n      }\n\n      c = p[0].x;\n      n = p[0].y;\n      var q = \"M \" + c + \",\" + n + \" L\" + b + \",\" + m;\n\n      if (o) {\n        q = \"M \" + c + \",\" + n + \" L\" + b + \",\" + n + \" L\" + b + \",\" + m;\n      }\n\n      if (d) {\n        this.renderer.attr(d, {\n          d: q\n        });\n      } else {\n        d = this.renderer.path(q, {});\n      }\n\n      this.renderer.attr(d, {\n        fill: \"none\",\n        stroke: e.lineColor,\n        \"stroke-width\": e.stroke,\n        \"stroke-opacity\": e.opacity,\n        \"stroke-dasharray\": \"none\" || e.dashStyle\n      });\n      return d;\n    },\n    _adjustTextBoxPosition: function _adjustTextBoxPosition(f, e, n, g, s, c, i, o) {\n      var d = s * Math.PI * 2 / 360;\n\n      var k = a.jqx._ptrnd(f + g * Math.cos(d));\n\n      var j = a.jqx._ptrnd(e - g * Math.sin(d));\n\n      if (o) {\n        var l = n.width;\n        var p = n.height;\n        var t = Math.atan(p / l) % (Math.PI * 2);\n        var u = d % (Math.PI * 2);\n        var r = 0,\n            q = 0;\n        var m = 0;\n\n        if (u <= t) {\n          m = l / 2 * Math.cos(d);\n        } else {\n          if (u >= t && u < Math.PI - t) {\n            m = p / 2 * Math.sin(d);\n          } else {\n            if (u >= Math.PI - t && u < Math.PI + t) {\n              m = l / 2 * Math.cos(d);\n            } else {\n              if (u >= Math.PI + t && u < 2 * Math.PI - t) {\n                m = p / 2 * Math.sin(d);\n              } else {\n                if (u >= 2 * Math.PI - t && u < 2 * Math.PI) {\n                  m = l / 2 * Math.cos(d);\n                }\n              }\n            }\n          }\n        }\n\n        g += Math.abs(m) + 3;\n\n        var k = a.jqx._ptrnd(f + g * Math.cos(d));\n\n        var j = a.jqx._ptrnd(e - g * Math.sin(d));\n\n        k -= n.width / 2;\n        j -= n.height / 2;\n        return {\n          x: k,\n          y: j\n        };\n      }\n\n      if (!c) {\n        if (!i) {\n          if (s >= 0 && s < 45 || s >= 315 && s < 360) {\n            j -= n.height / 2;\n          } else {\n            if (s >= 45 && s < 135) {\n              j -= n.height;\n              k -= n.width / 2;\n            } else {\n              if (s >= 135 && s < 225) {\n                j -= n.height / 2;\n                k -= n.width;\n              } else {\n                if (s >= 225 && s < 315) {\n                  k -= n.width / 2;\n                }\n              }\n            }\n          }\n        } else {\n          if (s >= 90 && s < 270) {\n            j -= n.height / 2;\n            k -= n.width;\n          } else {\n            j -= n.height / 2;\n          }\n        }\n      } else {\n        k -= n.width / 2;\n        j -= n.height / 2;\n      }\n\n      return {\n        x: k,\n        y: j\n      };\n    },\n    _isColumnType: function _isColumnType(b) {\n      return b.indexOf(\"column\") != -1 || b.indexOf(\"waterfall\") != -1;\n    },\n    _getColumnGroupsCount: function _getColumnGroupsCount(c) {\n      var e = 0;\n      c = c || \"vertical\";\n      var f = this.seriesGroups;\n\n      for (var d = 0; d < f.length; d++) {\n        var b = f[d].orientation || \"vertical\";\n\n        if (this._isColumnType(f[d].type) && b == c) {\n          e++;\n        }\n      }\n\n      if (this.columnSeriesOverlap) {\n        e = 1;\n      }\n\n      return e;\n    },\n    _getColumnGroupIndex: function _getColumnGroupIndex(g) {\n      var b = 0;\n      var c = this.seriesGroups[g].orientation || \"vertical\";\n\n      for (var e = 0; e < g; e++) {\n        var f = this.seriesGroups[e];\n        var d = f.orientation || \"vertical\";\n\n        if (this._isColumnType(f.type) && d == c) {\n          b++;\n        }\n      }\n\n      return b;\n    },\n    _renderAxisBands: function _renderAxisBands(e, A, I) {\n      var x = I ? this._getXAxis(e) : this._getValueAxis(e);\n      var t = this.seriesGroups[e];\n      var v = I ? undefined : t.bands;\n\n      if (!v) {\n        for (var N = 0; N < e; N++) {\n          var n = I ? this._getXAxis(N) : this._getValueAxis(N);\n\n          if (n == x) {\n            return;\n          }\n        }\n\n        v = x.bands;\n      }\n\n      if (!a.isArray(v)) {\n        return;\n      }\n\n      var o = A;\n      var V = t.orientation == \"horizontal\";\n\n      if (V) {\n        o = {\n          x: A.y,\n          y: A.x,\n          width: A.height,\n          height: A.width\n        };\n      }\n\n      this._calcGroupOffsets(e, o);\n\n      for (var N = 0; N < v.length; N++) {\n        var c = v[N];\n\n        var T = this._get([c.minValue, c.from]);\n\n        var w = this._get([c.maxValue, c.to]);\n\n        var s = I ? this.getXAxisDataPointOffset(T, e) : this.getValueAxisDataPointOffset(T, e);\n        var U = I ? this.getXAxisDataPointOffset(w, e) : this.getValueAxisDataPointOffset(w, e);\n\n        if (isNaN(s) || isNaN(U)) {\n          continue;\n        }\n\n        var y = Math.abs(s - U);\n        var H;\n\n        if (t.polar || t.spider) {\n          var r = this._renderData[e];\n          var d = r.polarCoords;\n\n          if (!I) {\n            var D = this._toPolarCoord(d, A, A.x, r.baseOffset);\n\n            var C = this._toPolarCoord(d, A, A.x, s);\n\n            var B = this._toPolarCoord(d, A, A.x, U);\n\n            var q = a.jqx._ptdist(D.x, D.y, C.x, C.y);\n\n            var p = a.jqx._ptdist(D.x, D.y, B.x, B.y);\n\n            var h = Math.round(-d.startAngle * 360 / (2 * Math.PI));\n            var O = Math.round(-d.endAngle * 360 / (2 * Math.PI));\n\n            if (h > O) {\n              var G = h;\n              h = O;\n              O = G;\n            }\n\n            if (t.spider) {\n              var E = r.xAxis.offsetAngles;\n              var F = \"\";\n              var K = [p, q];\n              var z = E;\n\n              if (d.isClosedCircle) {\n                z = a.extend([], E);\n                z.push(z[0]);\n              }\n\n              for (var J in K) {\n                for (var L = 0; L < z.length; L++) {\n                  var S = J == 0 ? L : E.length - L - 1;\n                  var l = d.x + K[J] * Math.cos(z[S]);\n                  var g = d.y + K[J] * Math.sin(z[S]);\n\n                  if (F == \"\") {\n                    F += \"M \";\n                  } else {\n                    F += \" L\";\n                  }\n\n                  F += a.jqx._ptrnd(l) + \",\" + a.jqx._ptrnd(g);\n                }\n\n                if (J == 0) {\n                  var l = d.x + K[1] * Math.cos(z[S]);\n                  var g = d.y + K[1] * Math.sin(z[S]);\n                  F += \" L\" + a.jqx._ptrnd(l) + \",\" + a.jqx._ptrnd(g);\n                }\n              }\n\n              F += \" Z\";\n              H = this.renderer.path(F);\n            } else {\n              H = this.renderer.pieslice(d.x, d.y, q, p, h, O);\n            }\n          } else {\n            if (t.spider) {\n              var Q = this.getPolarDataPointOffset(T, this._stats.seriesGroups[e].max, e);\n              var P = this.getPolarDataPointOffset(w, this._stats.seriesGroups[e].max, e);\n              var F = \"M \" + d.x + \",\" + d.y;\n              F += \" L \" + Q.x + \",\" + Q.y;\n              F += \" L \" + P.x + \",\" + P.y;\n              H = this.renderer.path(F);\n            } else {\n              var f = {};\n              var m = {\n                x: Math.min(s, U),\n                y: A.y,\n                width: y,\n                height: A.height\n              };\n\n              this._columnAsPieSlice(f, A, d, m);\n\n              H = f.element;\n            }\n          }\n        } else {\n          var b = {\n            x: Math.min(s, U),\n            y: o.y,\n            width: y,\n            height: o.height\n          };\n\n          if (!I) {\n            b = {\n              x: o.x,\n              y: Math.min(s, U),\n              width: o.width,\n              height: y\n            };\n          }\n\n          if (V) {\n            var G = b.x;\n            b.x = b.y;\n            b.y = G;\n            G = b.width;\n            b.width = b.height;\n            b.height = G;\n          }\n\n          if (y == 0 || y == 1) {\n            H = this.renderer.line(a.jqx._ptrnd(b.x), a.jqx._ptrnd(b.y), a.jqx._ptrnd(b.x + (V ? 0 : b.width)), a.jqx._ptrnd(b.y + (V ? b.height : 0)));\n          } else {\n            H = this.renderer.rect(b.x, b.y, b.width, b.height);\n          }\n        }\n\n        var W = c.fillColor || c.color || \"#AAAAAA\";\n        var R = c.lineColor || W;\n        var u = c.lineWidth;\n\n        if (isNaN(u)) {\n          u = 1;\n        }\n\n        var M = c.opacity;\n\n        if (isNaN(M) || M < 0 || M > 1) {\n          M = 1;\n        }\n\n        this.renderer.attr(H, {\n          fill: W,\n          \"fill-opacity\": M,\n          stroke: R,\n          \"stroke-opacity\": M,\n          \"stroke-width\": u,\n          \"stroke-dasharray\": c.dashStyle\n        });\n      }\n    },\n    _getColumnGroupWidth: function _getColumnGroupWidth(m, h, o) {\n      var e = this.seriesGroups[m];\n      var l = e.type.indexOf(\"stacked\") != -1;\n      var d = l ? 1 : e.series.length;\n\n      var k = this._getColumnGroupsCount(e.orientation);\n\n      if (isNaN(k) || 0 == k) {\n        k = 1;\n      }\n\n      var n = h.rangeLength >= 1 ? h.itemWidth : o * 0.9;\n      var c = e.columnsMinWidth;\n\n      if (isNaN(c)) {\n        c = 1;\n      }\n\n      if (!isNaN(e.columnsMaxWidth)) {\n        c = Math.min(e.columnsMaxWidth, c);\n      }\n\n      if (c > n && h.length > 0) {\n        n = Math.max(n, o * 0.9 / h.length);\n      }\n\n      var i = c;\n\n      if (!l) {\n        var f = e.seriesGapPercent;\n\n        if (isNaN(f) || f < 0) {\n          f = 10;\n        }\n\n        f /= 100;\n        var b = c;\n        b *= 1 + f;\n        i += e.series.length * b;\n      }\n\n      var j = Math.max(n / k, i);\n      return {\n        requiredWidth: i,\n        availableWidth: n,\n        targetWidth: j\n      };\n    },\n    _getColumnSerieWidthAndOffset: function _getColumnSerieWidthAndOffset(d, e) {\n      var m = this.seriesGroups[d];\n      var u = m.series[e];\n      var c = m.orientation == \"horizontal\";\n      var b = this._plotRect;\n\n      if (c) {\n        b = {\n          x: b.y,\n          y: b.x,\n          width: b.height,\n          height: b.width\n        };\n      }\n\n      var v = this._calcGroupOffsets(d, b);\n\n      if (!v || v.xoffsets.length == 0) {\n        return;\n      }\n\n      var l = true;\n\n      var w = this._getColumnGroupsCount(m.orientation);\n\n      if (m.type == \"candlestick\" || m.type == \"ohlc\") {\n        w = 1;\n      }\n\n      var q = this._getColumnGroupIndex(d);\n\n      var r = this._getColumnGroupWidth(d, v.xoffsets, c ? b.height : b.width);\n\n      var h = 0;\n      var f = r.targetWidth;\n\n      if (this.columnSeriesOverlap == true || Math.round(f) > Math.round(r.availableWidth / w)) {\n        w = 1;\n        q = 0;\n      }\n\n      if (l) {\n        h -= f * w / 2;\n      }\n\n      h += f * q;\n      var B = m.columnsGapPercent;\n\n      if (B <= 0) {\n        B = 0;\n      }\n\n      if (isNaN(B) || B >= 100) {\n        B = 25;\n      }\n\n      B /= 100;\n      var k = f * B;\n\n      if (k + r.requiredWidth > r.targetWidth) {\n        k = Math.max(0, r.targetWidth - r.requiredWidth);\n      }\n\n      if (Math.round(f) > Math.round(r.availableWidth)) {\n        k = 0;\n      }\n\n      f -= k;\n      h += k / 2;\n      var x = m.seriesGapPercent;\n\n      if (isNaN(x) || x < 0) {\n        x = 10;\n      }\n\n      var n = m.type.indexOf(\"stacked\") != -1;\n      var t = f;\n\n      if (!n) {\n        t /= m.series.length;\n      }\n\n      var y = this._get([m.seriesGap, f * x / 100 / (m.series.length - 1)]);\n\n      if (m.polar == true || m.spider == true || n || m.series.length <= 1) {\n        y = 0;\n      }\n\n      var o = y * (m.series.length - 1);\n\n      if (m.series.length > 1 && o > f - m.series.length * 1) {\n        o = f - m.series.length * 1;\n        y = o / Math.max(1, m.series.length - 1);\n      }\n\n      var g = t - o / m.series.length;\n      var A = 0;\n      var i = m.columnsMaxWidth;\n\n      if (!isNaN(i)) {\n        if (g > i) {\n          A = g - i;\n          g = i;\n        }\n      }\n\n      var z = A / 2;\n      var j = 0;\n\n      if (!n) {\n        var C = (f - g * m.series.length - o) / 2;\n        var p = Math.max(0, e);\n        j = C + g * e + p * y;\n      } else {\n        j = A / 2;\n      }\n\n      return {\n        width: g,\n        offset: h + j\n      };\n    },\n    _renderColumnSeries: function _renderColumnSeries(f, c) {\n      var j = this.seriesGroups[f];\n\n      if (!j.series || j.series.length == 0) {\n        return;\n      }\n\n      var h = this._getDataLen(f);\n\n      var e = j.orientation == \"horizontal\";\n      var y = c;\n\n      if (e) {\n        y = {\n          x: c.y,\n          y: c.x,\n          width: c.height,\n          height: c.width\n        };\n      }\n\n      var p = this._calcGroupOffsets(f, y);\n\n      if (!p || p.xoffsets.length == 0) {\n        return;\n      }\n\n      var m;\n\n      if (j.polar == true || j.spider == true) {\n        m = this._getPolarAxisCoords(f, y);\n      }\n\n      var r = {\n        groupIndex: f,\n        rect: c,\n        vertical: !e,\n        seriesCtx: [],\n        renderData: p,\n        polarAxisCoords: m\n      };\n      r.columnGroupWidth = this._getColumnGroupWidth(f, p.xoffsets, e ? y.height : y.width);\n\n      var g = this._getGroupGradientType(f);\n\n      for (var t = 0; t < j.series.length; t++) {\n        var n = j.series[t];\n\n        if (n.customDraw) {\n          continue;\n        }\n\n        var w = n.dataField;\n\n        var u = this._getAnimProps(f, t);\n\n        var b = u.enabled && !this._isToggleRefresh && p.xoffsets.length < 100 ? u.duration : 0;\n\n        var k = this._getColumnSerieWidthAndOffset(f, t);\n\n        var q = this._isSerieVisible(f, t);\n\n        var l = this._getSerieSettings(f, t);\n\n        var z = this._getColors(f, t, NaN, this._getGroupGradientType(f), 4);\n\n        var d = [];\n\n        if (a.isFunction(n.colorFunction) && !m) {\n          for (var x = p.xoffsets.first; x <= p.xoffsets.last; x++) {\n            d.push(this._getColors(f, t, x, g, 4));\n          }\n        }\n\n        var v = {\n          seriesIndex: t,\n          serieColors: z,\n          itemsColors: d,\n          settings: l,\n          columnWidth: k.width,\n          xAdjust: k.offset,\n          isVisible: q\n        };\n        r.seriesCtx.push(v);\n      }\n\n      this._animColumns(r, b == 0 ? 1 : 0);\n\n      var o = this;\n\n      this._enqueueAnimation(\"series\", undefined, undefined, b, function (s, i, A) {\n        o._animColumns(i, A);\n      }, r);\n    },\n    _getPercent: function _getPercent(d, c, b, e) {\n      if (isNaN(d)) {\n        d = c;\n      }\n\n      if (!isNaN(b) && !isNaN(d) && d < b) {\n        d = b;\n      }\n\n      if (!isNaN(e) && !isNaN(d) && d > e) {\n        d = e;\n      }\n\n      if (isNaN(d)) {\n        return NaN;\n      }\n\n      return d;\n    },\n    _getColumnVOffsets: function _getColumnVOffsets(n, j, e, B, u, c) {\n      var p = this.seriesGroups[j];\n\n      var F = this._getPercent(p.columnsTopWidthPercent, 100, 0, 100);\n\n      var v = this._getPercent(p.columnsBottomWidthPercent, 100, 0, 100);\n\n      if (F == 0 && v == 0) {\n        v = 100;\n      }\n\n      var H = this._getPercent(p.columnsNeckHeightPercent, NaN, 0, 100) / 100;\n      var C = this._getPercent(p.columnsNeckWidthPercent, 100, 0, 100) / 100;\n      var r = [];\n      var G = NaN;\n\n      for (var q = 0; q < e.length; q++) {\n        var L = e[q];\n        var k = L.seriesIndex;\n        var E = p.series[k];\n        var o = n.offsets[k][B].from;\n        var N = n.offsets[k][B].to;\n        var x = n.xoffsets.data[B];\n        var g;\n        var h = L.isVisible;\n\n        if (!h) {\n          N = o;\n        }\n\n        var b = this._elementRenderInfo;\n\n        if (h && b && b.length > j && b[j].series.length > k) {\n          var D = n.xoffsets.xvalues[B];\n          g = b[j].series[k][D];\n\n          if (g && !isNaN(g.from) && !isNaN(g.to)) {\n            o = g.from + (o - g.from) * c;\n            N = g.to + (N - g.to) * c;\n            x = g.xoffset + (x - g.xoffset) * c;\n          }\n        }\n\n        if (!g) {\n          N = o + (N - o) * (u ? 1 : c);\n        }\n\n        if (isNaN(o)) {\n          o = isNaN(G) ? n.baseOffset : G;\n        }\n\n        if (!isNaN(N) && u) {\n          G = N;\n        } else {\n          G = o;\n        }\n\n        if (isNaN(N)) {\n          N = o;\n        }\n\n        var A = {\n          from: o,\n          to: N,\n          xOffset: x\n        };\n\n        if (F != 100 || v != 100) {\n          A.funnel = true;\n          A.toWidthPercent = F;\n          A.fromWidthPercent = v;\n        }\n\n        r.push(A);\n      }\n\n      if (u && r.length > 1 && !(this._elementRenderInfo && this._elementRenderInfo.length > j)) {\n        var l = 0,\n            m = 0,\n            I = -Infinity,\n            w = Infinity,\n            J = Infinity,\n            z = -Infinity;\n\n        for (var K = 0; K < r.length; K++) {\n          var L = e[K];\n\n          if (L.isVisible) {\n            if (r[K].to >= r[K].from) {\n              m += r[K].to - r[K].from;\n              J = Math.min(J, r[K].from);\n              z = Math.max(z, r[K].to);\n            } else {\n              l += r[K].from - r[K].to;\n              I = Math.max(I, r[K].from);\n              w = Math.min(w, r[K].to);\n            }\n          }\n        }\n\n        var M = l;\n        var t = m;\n        l *= c;\n        m *= c;\n        var d = 0,\n            f = 0;\n\n        for (var K = 0; K < r.length; K++) {\n          if (r[K].to >= r[K].from) {\n            var y = r[K].to - r[K].from;\n\n            if (y + f > m) {\n              y = Math.max(0, m - f);\n              r[K].to = r[K].from + y;\n            }\n\n            if (F != 100 || v != 100) {\n              r[K].funnel = true;\n\n              if (!isNaN(H) && t * H >= f) {\n                r[K].fromWidthPercent = C * 100;\n              } else {\n                r[K].fromWidthPercent = Math.abs(r[K].from - J) / t * (F - v) + v;\n              }\n\n              if (!isNaN(H) && t * H >= 0 + (f + y)) {\n                r[K].toWidthPercent = C * 100;\n              } else {\n                r[K].toWidthPercent = Math.abs(r[K].to - J) / t * (F - v) + v;\n              }\n            }\n\n            f += y;\n          } else {\n            var y = r[K].from - r[K].to;\n\n            if (y + d > l) {\n              y = Math.max(0, l - d);\n              r[K].to = r[K].from - y;\n            }\n\n            if (F != 100 || v != 100) {\n              r[K].funnel = true;\n\n              if (!isNaN(H) && M * H >= d) {\n                r[K].fromWidthPercent = C * 100;\n              } else {\n                r[K].fromWidthPercent = Math.abs(r[K].from - I) / M * (F - v) + v;\n              }\n\n              if (!isNaN(H) && M * H >= 0 + (d + y)) {\n                r[K].toWidthPercent = C * 100;\n              } else {\n                r[K].toWidthPercent = Math.abs(r[K].to - I) / M * (F - v) + v;\n              }\n            }\n\n            d += y;\n          }\n        }\n      }\n\n      return r;\n    },\n    _columnAsPieSlice: function _columnAsPieSlice(d, k, m, o) {\n      var e = this._toPolarCoord(m, k, o.x, o.y);\n\n      var f = this._toPolarCoord(m, k, o.x, o.y + o.height);\n\n      var l = a.jqx._ptdist(m.x, m.y, f.x, f.y);\n\n      var i = a.jqx._ptdist(m.x, m.y, e.x, e.y);\n\n      var c = k.width;\n      var n = Math.abs(m.startAngle - m.endAngle) * 180 / Math.PI;\n      var b = -((o.x - k.x) * n) / c;\n      var h = -((o.x + o.width - k.x) * n) / c;\n      var j = m.startAngle;\n      j = 360 * j / (Math.PI * 2);\n      b -= j;\n      h -= j;\n\n      if (d) {\n        if (d.element != undefined) {\n          var g = this.renderer.pieSlicePath(m.x, m.y, l, i, h, b, 0);\n          g += \" Z\";\n          this.renderer.attr(d.element, {\n            d: g\n          });\n        } else {\n          d.element = this.renderer.pieslice(m.x, m.y, l, i, h, b, 0);\n        }\n      }\n\n      return {\n        fromAngle: h,\n        toAngle: b,\n        innerRadius: l,\n        outerRadius: i\n      };\n    },\n    _setRenderInfo: function _setRenderInfo(e, b, d, c) {\n      this._renderData[e].offsets[b][d].elementInfo = c;\n    },\n    _getRenderInfo: function _getRenderInfo(d, b, c) {\n      return this._renderData[d].offsets[b][c].elementInfo || {};\n    },\n    _animColumns: function _animColumns(ai, d) {\n      var p = this;\n      var q = ai.groupIndex;\n      var A = this.seriesGroups[q];\n      var v = ai.renderData;\n      var aa = A.type.indexOf(\"waterfall\") != -1;\n\n      var G = this._getXAxis(q);\n\n      var I = A.type.indexOf(\"stacked\") != -1;\n      var e = ai.polarAxisCoords;\n\n      var z = this._getGroupGradientType(q);\n\n      var s = ai.columnGroupWidth.targetWidth;\n      var y = -1;\n\n      for (var ab = 0; ab < A.series.length; ab++) {\n        if (this._isSerieVisible(q, ab)) {\n          y = ab;\n          break;\n        }\n      }\n\n      var aj = NaN,\n          t = NaN;\n\n      for (var ab = 0; ab < ai.seriesCtx.length; ab++) {\n        var ah = ai.seriesCtx[ab];\n\n        if (isNaN(aj) || aj > ah.xAdjust) {\n          aj = ah.xAdjust;\n        }\n\n        if (isNaN(t) || t < ah.xAdjust + ah.columnWidth) {\n          t = ah.xAdjust + ah.columnWidth;\n        }\n      }\n\n      var r = Math.abs(t - aj);\n      var C = this._get([A.columnsGapPercent, 25]) / 100;\n\n      if (isNaN(C) < 0 || C >= 1) {\n        C = 0.25;\n      }\n\n      var f = C * r;\n      var Z = ai.renderData.xoffsets;\n      var S = -1;\n      var O = {};\n      var R = A.skipOverlappingPoints == true;\n\n      for (var ad = Z.first; ad <= Z.last; ad++) {\n        var V = Z.data[ad];\n\n        if (isNaN(V)) {\n          continue;\n        }\n\n        if (S != -1 && Math.abs(V - S) < r - 1 + f && R) {\n          continue;\n        } else {\n          S = V;\n        }\n\n        var F = this._getColumnVOffsets(v, q, ai.seriesCtx, ad, I, d);\n\n        var L = false;\n\n        if (aa) {\n          for (var B = 0; B < A.series.length; B++) {\n            if (A.series[B].summary && Z.xvalues[ad][A.series[B].summary]) {\n              L = true;\n            }\n          }\n        }\n\n        for (var B = 0; B < ai.seriesCtx.length; B++) {\n          var ah = ai.seriesCtx[B];\n          var m = ah.seriesIndex;\n          var E = A.series[m];\n          var w = F[B].from;\n          var ak = F[B].to;\n          var K = F[B].xOffset;\n          var g = (ai.vertical ? ai.rect.x : ai.rect.y) + ah.xAdjust;\n          var ae = ah.settings;\n          var W = ah.itemsColors.length != 0 ? ah.itemsColors[ad - v.xoffsets.first] : ah.serieColors;\n\n          var h = this._isSerieVisible(q, m);\n\n          if (!h) {\n            continue;\n          }\n\n          var V = a.jqx._ptrnd(g + K);\n\n          var Q = {\n            x: V,\n            width: ah.columnWidth\n          };\n\n          if (F[B].funnel) {\n            Q.fromWidthPercent = F[B].fromWidthPercent;\n            Q.toWidthPercent = F[B].toWidthPercent;\n          }\n\n          var k = true;\n\n          if (ai.vertical) {\n            Q.y = w;\n            Q.height = ak - w;\n\n            if (Q.height < 0) {\n              Q.y += Q.height;\n              Q.height = -Q.height;\n              k = false;\n            }\n          } else {\n            Q.x = w < ak ? w : ak;\n            Q.width = Math.abs(w - ak);\n            k = w - ak < 0;\n            Q.y = V;\n            Q.height = ah.columnWidth;\n          }\n\n          var n = w - ak;\n\n          if (isNaN(n)) {\n            continue;\n          }\n\n          n = Math.abs(n);\n          var H = undefined;\n\n          var c = p._getRenderInfo(q, m, ad);\n\n          var u = c.element;\n          var P = c.labelElement;\n          var N = u == undefined;\n\n          if (P) {\n            p.renderer.removeElement(P);\n            P = undefined;\n          }\n\n          if (!e) {\n            if (F[B].funnel) {\n              var Y = this._getTrapezoidPath(a.extend({}, Q), ai.vertical, k);\n\n              if (N) {\n                u = this.renderer.path(Y, {});\n              } else {\n                this.renderer.attr(u, {\n                  d: Y\n                });\n              }\n            } else {\n              if (N) {\n                u = this.renderer.rect(Q.x, Q.y, ai.vertical ? Q.width : 0, ai.vertical ? 0 : Q.height);\n              } else {\n                if (ai.vertical == true) {\n                  this.renderer.attr(u, {\n                    x: Q.x,\n                    y: Q.y,\n                    height: n\n                  });\n                } else {\n                  this.renderer.attr(u, {\n                    x: Q.x,\n                    y: Q.y,\n                    width: n\n                  });\n                }\n              }\n            }\n          } else {\n            var l = {\n              element: u\n            };\n            H = this._columnAsPieSlice(l, ai.rect, e, Q);\n            u = l.element;\n\n            var W = this._getColors(q, m, undefined, \"radialGradient\", H.outerRadius);\n          }\n\n          if (n < 1 && (d != 1 || e)) {\n            this.renderer.attr(u, {\n              display: \"none\"\n            });\n          } else {\n            this.renderer.attr(u, {\n              display: \"block\"\n            });\n          }\n\n          if (N) {\n            this.renderer.attr(u, {\n              fill: W.fillColor,\n              \"fill-opacity\": ae.opacity,\n              \"stroke-opacity\": ae.opacity,\n              stroke: W.lineColor,\n              \"stroke-width\": ae.stroke,\n              \"stroke-dasharray\": ae.dashStyle\n            });\n          }\n\n          if (P) {\n            this.renderer.removeElement(P);\n          }\n\n          if (!h || n == 0 && d < 1) {\n            c = {\n              element: u,\n              labelElement: P\n            };\n\n            p._setRenderInfo(q, m, ad, c);\n\n            continue;\n          }\n\n          if (aa && this._get([E.showWaterfallLines, A.showWaterfallLines]) != false) {\n            if (!I || I && B == y) {\n              var ac = I ? -1 : B;\n\n              if (d == 1 && !isNaN(v.offsets[B][ad].from) && !isNaN(v.offsets[B][ad].to)) {\n                var M = O[ac];\n\n                if (M != undefined) {\n                  var ag = {\n                    x: M.x,\n                    y: a.jqx._ptrnd(M.y)\n                  };\n                  var af = {\n                    x: V,\n                    y: ag.y\n                  };\n                  var T = A.columnsTopWidthPercent / 100;\n\n                  if (isNaN(T)) {\n                    T = 1;\n                  } else {\n                    if (T > 1 || T < 0) {\n                      T = 1;\n                    }\n                  }\n\n                  var X = A.columnsBottomWidthPercent / 100;\n\n                  if (isNaN(X)) {\n                    X = 1;\n                  } else {\n                    if (X > 1 || X < 0) {\n                      X = 1;\n                    }\n                  }\n\n                  var o = ai.vertical ? Q.width : Q.height;\n                  ag.x = ag.x - o / 2 + o / 2 * T;\n\n                  if (L) {\n                    var b = o * T / 2;\n                    af.x = af.x + o / 2 - (G.flip ? -b : b);\n                  } else {\n                    var b = o * X / 2;\n                    af.x = af.x + o / 2 - (G.flip ? -b : b);\n                  }\n\n                  if (!ai.vertical) {\n                    this._swapXY([ag]);\n\n                    this._swapXY([af]);\n                  }\n\n                  this.renderer.line(ag.x, ag.y, af.x, af.y, {\n                    stroke: M.color,\n                    \"stroke-width\": ae.stroke,\n                    \"stroke-opacity\": ae.opacity,\n                    \"fill-opacity\": ae.opacity,\n                    \"stroke-dasharray\": ae.dashStyle\n                  });\n                }\n              }\n            }\n\n            if (d == 1 && n != 0) {\n              O[I ? -1 : B] = {\n                y: ak,\n                x: ai.vertical ? Q.x + Q.width : Q.y + Q.height,\n                color: W.lineColor\n              };\n            }\n          }\n\n          if (e) {\n            var U = this._toPolarCoord(e, ai.rect, Q.x + Q.width / 2, Q.y);\n\n            var o = this._showLabel(q, m, ad, Q, undefined, undefined, true);\n\n            var J = H.outerRadius + 10;\n\n            var D = this._adjustTextBoxPosition(e.x, e.y, o, J, (H.fromAngle + H.toAngle) / 2, true, false, false);\n\n            P = this._showLabel(q, m, ad, {\n              x: D.x,\n              y: D.y\n            }, undefined, undefined, false, false, false);\n          } else {\n            P = this._showLabel(q, m, ad, Q, undefined, undefined, false, false, k);\n          }\n\n          c = {\n            element: u,\n            labelElement: P\n          };\n\n          p._setRenderInfo(q, m, ad, c);\n\n          if (d == 1) {\n            this._installHandlers(u, \"column\", q, m, ad);\n          }\n        }\n      }\n    },\n    _getTrapezoidPath: function _getTrapezoidPath(g, h, f) {\n      var l = \"\";\n      var b = g.fromWidthPercent / 100;\n      var c = g.toWidthPercent / 100;\n\n      if (!h) {\n        var e = g.width;\n        g.width = g.height;\n        g.height = e;\n        e = g.x;\n        g.x = g.y;\n        g.y = e;\n      }\n\n      var j = g.x + g.width / 2;\n      var k = [{\n        x: j - g.width * (!f ? b : c) / 2,\n        y: g.y + g.height\n      }, {\n        x: j - g.width * (!f ? c : b) / 2,\n        y: g.y\n      }, {\n        x: j + g.width * (!f ? c : b) / 2,\n        y: g.y\n      }, {\n        x: j + g.width * (!f ? b : c) / 2,\n        y: g.y + g.height\n      }];\n\n      if (!h) {\n        this._swapXY(k);\n      }\n\n      l += \"M \" + a.jqx._ptrnd(k[0].x) + \",\" + a.jqx._ptrnd(k[0].y);\n\n      for (var d = 1; d < k.length; d++) {\n        l += \" L \" + a.jqx._ptrnd(k[d].x) + \",\" + a.jqx._ptrnd(k[d].y);\n      }\n\n      l += \" Z\";\n      return l;\n    },\n    _swapXY: function _swapXY(d) {\n      for (var c = 0; c < d.length; c++) {\n        var b = d[c].x;\n        d[c].x = d[c].y;\n        d[c].y = b;\n      }\n    },\n    _renderCandleStickSeries: function _renderCandleStickSeries(e, c, t) {\n      var m = this;\n      var h = m.seriesGroups[e];\n\n      if (!h.series || h.series.length == 0) {\n        return;\n      }\n\n      var d = h.orientation == \"horizontal\";\n      var v = c;\n\n      if (d) {\n        v = {\n          x: c.y,\n          y: c.x,\n          width: c.height,\n          height: c.width\n        };\n      }\n\n      var n = m._calcGroupOffsets(e, v);\n\n      if (!n || n.xoffsets.length == 0) {\n        return;\n      }\n\n      var w = v.width;\n      var k;\n\n      if (h.polar || h.spider) {\n        k = m._getPolarAxisCoords(e, v);\n        w = 2 * k.r;\n      }\n\n      var g = m._alignValuesWithTicks(e);\n\n      var f = m._getGroupGradientType(e);\n\n      var i = [];\n\n      for (var p = 0; p < h.series.length; p++) {\n        i[p] = m._getColumnSerieWidthAndOffset(e, p);\n      }\n\n      for (var p = 0; p < h.series.length; p++) {\n        if (!this._isSerieVisible(e, p)) {\n          continue;\n        }\n\n        var u = m._getSerieSettings(e, p);\n\n        var l = h.series[p];\n\n        if (l.customDraw) {\n          continue;\n        }\n\n        var j = a.isFunction(l.colorFunction) ? undefined : m._getColors(e, p, NaN, f);\n        var o = {\n          rect: c,\n          inverse: d,\n          groupIndex: e,\n          seriesIndex: p,\n          symbolType: l.symbolType,\n          symbolSize: l.symbolSize,\n          \"fill-opacity\": u.opacity,\n          \"stroke-opacity\": u.opacity,\n          \"stroke-width\": u.stroke,\n          \"stroke-dasharray\": u.dashStyle,\n          gradientType: f,\n          colors: j,\n          renderData: n,\n          polarAxisCoords: k,\n          columnsInfo: i,\n          isOHLC: t,\n          items: [],\n          self: m\n        };\n\n        var q = m._getAnimProps(e, p);\n\n        var b = q.enabled && !m._isToggleRefresh && n.xoffsets.length < 5000 ? q.duration : 0;\n\n        m._animCandleStick(o, 0);\n\n        var r;\n\n        m._enqueueAnimation(\"series\", undefined, undefined, b, function (y, s, x) {\n          m._animCandleStick(s, x);\n        }, o);\n      }\n    },\n    _animCandleStick: function _animCandleStick(t, b) {\n      var q = [\"Open\", \"Low\", \"Close\", \"High\"];\n      var e = t.columnsInfo[t.seriesIndex].width;\n      var g = t.self.seriesGroups[t.groupIndex];\n      var v = t.renderData.xoffsets;\n      var E = -1;\n      var n = Math.abs(v.data[v.last] - v.data[v.first]);\n      n *= b;\n      var c = NaN,\n          r = NaN;\n\n      for (var z = 0; z < t.columnsInfo.length; z++) {\n        var w = t.columnsInfo[z];\n\n        if (isNaN(c) || c > w.offset) {\n          c = w.offset;\n        }\n\n        if (isNaN(r) || r < w.offset + w.width) {\n          r = w.offset + w.width;\n        }\n      }\n\n      var m = Math.abs(r - c);\n      var B = g.skipOverlappingPoints != false;\n\n      for (var A = v.first; A <= v.last; A++) {\n        var l = v.data[A];\n\n        if (isNaN(l)) {\n          continue;\n        }\n\n        if (E != -1 && Math.abs(l - E) < m && B) {\n          continue;\n        }\n\n        var C = Math.abs(v.data[A] - v.data[v.first]);\n\n        if (C > n) {\n          break;\n        }\n\n        E = l;\n        var D = t.items[A] = t.items[A] || {};\n\n        for (var z in q) {\n          var F = t.self._getDataValueAsNumber(A, g.series[t.seriesIndex][\"dataField\" + q[z]], t.groupIndex);\n\n          if (isNaN(F)) {\n            break;\n          }\n\n          var k = t.renderData.offsets[t.seriesIndex][A][q[z]];\n\n          if (isNaN(k)) {\n            break;\n          }\n\n          D[q[z]] = k;\n        }\n\n        l += t.inverse ? t.rect.y : t.rect.x;\n\n        if (t.polarAxisCoords) {\n          var s = this._toPolarCoord(t.polarAxisCoords, this._plotRect, l, k);\n\n          l = s.x;\n          k = s.y;\n        }\n\n        l = a.jqx._ptrnd(l);\n\n        for (var f in q) {\n          D[f] = a.jqx._ptrnd(D[f]);\n        }\n\n        var h = t.colors;\n\n        if (!h) {\n          h = t.self._getColors(t.groupIndex, t.seriesIndex, A, t.gradientType);\n        }\n\n        if (!t.isOHLC) {\n          var u = D.lineElement;\n\n          if (!u) {\n            u = t.inverse ? this.renderer.line(D.Low, l, D.High, l) : this.renderer.line(l, D.Low, l, D.High);\n            this.renderer.attr(u, {\n              fill: h.fillColor,\n              \"fill-opacity\": t[\"fill-opacity\"],\n              \"stroke-opacity\": t[\"fill-opacity\"],\n              stroke: h.lineColor,\n              \"stroke-width\": t[\"stroke-width\"],\n              \"stroke-dasharray\": t[\"stroke-dasharray\"]\n            });\n            D.lineElement = u;\n          }\n\n          var p = D.stickElement;\n          l -= e / 2;\n\n          if (!p) {\n            var d = h.fillColor;\n\n            if (D.Close <= D.Open && h.fillColorAlt) {\n              d = h.fillColorAlt;\n            }\n\n            p = t.inverse ? this.renderer.rect(Math.min(D.Open, D.Close), l, Math.abs(D.Close - D.Open), e) : this.renderer.rect(l, Math.min(D.Open, D.Close), e, Math.abs(D.Close - D.Open));\n            this.renderer.attr(p, {\n              fill: d,\n              \"fill-opacity\": t[\"fill-opacity\"],\n              \"stroke-opacity\": t[\"fill-opacity\"],\n              stroke: h.lineColor,\n              \"stroke-width\": t[\"stroke-width\"],\n              \"stroke-dasharray\": t[\"stroke-dasharray\"]\n            });\n            D.stickElement = p;\n          }\n\n          if (b == 1) {\n            this._installHandlers(p, \"column\", t.groupIndex, t.seriesIndex, A);\n          }\n        } else {\n          var o = \"M\" + l + \",\" + D.Low + \" L\" + l + \",\" + D.High + \" M\" + (l - e / 2) + \",\" + D.Open + \" L\" + l + \",\" + D.Open + \" M\" + (l + e / 2) + \",\" + D.Close + \" L\" + l + \",\" + D.Close;\n\n          if (t.inverse) {\n            o = \"M\" + D.Low + \",\" + l + \" L\" + D.High + \",\" + l + \" M\" + D.Open + \",\" + (l - e / 2) + \" L\" + D.Open + \",\" + l + \" M\" + D.Close + \",\" + l + \" L\" + D.Close + \",\" + (l + e / 2);\n          }\n\n          var u = D.lineElement;\n\n          if (!u) {\n            u = this.renderer.path(o, {});\n            this.renderer.attr(u, {\n              fill: h.fillColor,\n              \"fill-opacity\": t[\"fill-opacity\"],\n              \"stroke-opacity\": t[\"fill-opacity\"],\n              stroke: h.lineColor,\n              \"stroke-width\": t[\"stroke-width\"],\n              \"stroke-dasharray\": t[\"stroke-dasharray\"]\n            });\n            D.lineElement = u;\n          }\n\n          if (b == 1) {\n            this._installHandlers(u, \"column\", t.groupIndex, t.seriesIndex, A);\n          }\n        }\n      }\n    },\n    _renderScatterSeries: function _renderScatterSeries(e, D, F) {\n      var u = this.seriesGroups[e];\n\n      if (!u.series || u.series.length == 0) {\n        return;\n      }\n\n      var f = u.type.indexOf(\"bubble\") != -1;\n      var v = u.orientation == \"horizontal\";\n      var m = D;\n\n      if (v) {\n        m = {\n          x: D.y,\n          y: D.x,\n          width: D.height,\n          height: D.width\n        };\n      }\n\n      var n = this._calcGroupOffsets(e, m);\n\n      if (!n || n.xoffsets.length == 0) {\n        return;\n      }\n\n      var N = m.width;\n      var c;\n\n      if (u.polar || u.spider) {\n        c = this._getPolarAxisCoords(e, m);\n        N = 2 * c.r;\n      }\n\n      var V = this._alignValuesWithTicks(e);\n\n      var t = this._getGroupGradientType(e);\n\n      if (!F) {\n        F = \"to\";\n      }\n\n      for (var g = 0; g < u.series.length; g++) {\n        var T = this._getSerieSettings(e, g);\n\n        var K = u.series[g];\n\n        if (K.customDraw) {\n          continue;\n        }\n\n        var A = K.dataField;\n        var l = a.isFunction(K.colorFunction);\n\n        var L = this._getColors(e, g, NaN, t);\n\n        var U = NaN,\n            z = NaN;\n\n        if (f) {\n          for (var S = n.xoffsets.first; S <= n.xoffsets.last; S++) {\n            var C = this._getDataValueAsNumber(S, K.radiusDataField || K.sizeDataField, e);\n\n            if (typeof C != \"number\") {\n              throw \"Invalid radiusDataField value at [\" + S + \"]\";\n            }\n\n            if (!isNaN(C)) {\n              if (isNaN(U) || C < U) {\n                U = C;\n              }\n\n              if (isNaN(z) || C > z) {\n                z = C;\n              }\n            }\n          }\n        }\n\n        var j = K.minRadius || K.minSymbolSize;\n\n        if (isNaN(j)) {\n          j = N / 50;\n        }\n\n        var E = K.maxRadius || K.maxSymbolSize;\n\n        if (isNaN(E)) {\n          E = N / 25;\n        }\n\n        if (j > E) {\n          E = j;\n        }\n\n        var M = K.radius;\n\n        if (isNaN(M) && !isNaN(K.symbolSize)) {\n          M = K.symbolType == \"circle\" ? K.symbolSize / 2 : K.symbolSize;\n        } else {\n          M = 5;\n        }\n\n        var G = this._getAnimProps(e, g);\n\n        var B = G.enabled && !this._isToggleRefresh && n.xoffsets.length < 5000 ? G.duration : 0;\n        var w = {\n          groupIndex: e,\n          seriesIndex: g,\n          symbolType: K.symbolType,\n          symbolSize: K.symbolSize,\n          \"fill-opacity\": T.opacity,\n          \"stroke-opacity\": T.opacity,\n          \"stroke-width\": T.stroke,\n          \"stroke-width-symbol\": T.strokeSymbol,\n          \"stroke-dasharray\": T.dashStyle,\n          items: [],\n          polarAxisCoords: c\n        };\n        var o = undefined;\n\n        for (var S = n.xoffsets.first; S <= n.xoffsets.last; S++) {\n          var C = this._getDataValueAsNumber(S, A, e);\n\n          if (typeof C != \"number\") {\n            continue;\n          }\n\n          var J = n.xoffsets.data[S];\n          var H = n.xoffsets.xvalues[S];\n          var I = n.offsets[g][S][F];\n\n          if (I < m.y || I > m.y + m.height) {\n            continue;\n          }\n\n          if (isNaN(J) || isNaN(I)) {\n            continue;\n          }\n\n          if (v) {\n            var Q = J;\n            J = I;\n            I = Q + D.y;\n          } else {\n            J += D.x;\n          }\n\n          if (!l && o && this.enableSampling && a.jqx._ptdist(o.x, o.y, J, I) < 1) {\n            continue;\n          }\n\n          o = {\n            x: J,\n            y: I\n          };\n          var O = M;\n\n          if (f) {\n            var p = this._getDataValueAsNumber(S, K.radiusDataField || K.sizeDataField, e);\n\n            if (typeof p != \"number\") {\n              continue;\n            }\n\n            O = j + (E - j) * (p - U) / Math.max(1, z - U);\n\n            if (isNaN(O)) {\n              O = j;\n            }\n          }\n\n          n.offsets[g][S].radius = O;\n          var k = NaN,\n              P = NaN;\n          var q = 0;\n          var b = this._elementRenderInfo;\n\n          if (H != undefined && b && b.length > e && b[e].series.length > g) {\n            var d = b[e].series[g][H];\n\n            if (d && !isNaN(d.to)) {\n              k = d.to;\n              P = d.xoffset;\n              q = M;\n\n              if (v) {\n                var Q = P;\n                P = k;\n                k = Q + D.y;\n              } else {\n                P += D.x;\n              }\n\n              if (f) {\n                q = j + (E - j) * (d.valueRadius - U) / Math.max(1, z - U);\n\n                if (isNaN(q)) {\n                  q = j;\n                }\n              }\n            }\n          }\n\n          if (l) {\n            L = this._getColors(e, g, S, t);\n          }\n\n          w.items.push({\n            from: q,\n            to: O,\n            itemIndex: S,\n            fill: L.fillColor,\n            stroke: L.lineColor,\n            x: J,\n            y: I,\n            xFrom: P,\n            yFrom: k\n          });\n        }\n\n        this._animR(w, 0);\n\n        var h = this;\n        var R;\n\n        this._enqueueAnimation(\"series\", undefined, undefined, B, function (s, i, r) {\n          h._animR(i, r);\n        }, w);\n      }\n    },\n    _animR: function _animR(o, g) {\n      var j = o.items;\n      var p = o.symbolType || \"circle\";\n      var c = o.symbolSize;\n\n      for (var e = 0; e < j.length; e++) {\n        var n = j[e];\n        var l = n.x;\n        var k = n.y;\n        var b = Math.round((n.to - n.from) * g + n.from);\n\n        if (!isNaN(n.yFrom)) {\n          k = n.yFrom + (k - n.yFrom) * g;\n        }\n\n        if (!isNaN(n.xFrom)) {\n          l = n.xFrom + (l - n.xFrom) * g;\n        }\n\n        if (o.polarAxisCoords) {\n          var m = this._toPolarCoord(o.polarAxisCoords, this._plotRect, l, k);\n\n          l = m.x;\n          k = m.y;\n        }\n\n        l = a.jqx._ptrnd(l);\n        k = a.jqx._ptrnd(k);\n        b = a.jqx._ptrnd(b);\n\n        var f = this._getRenderInfo(o.groupIndex, o.seriesIndex, j[e].itemIndex);\n\n        var d = f.element;\n        var h = f.labelElement;\n\n        if (p == \"circle\") {\n          if (!d) {\n            d = this.renderer.circle(l, k, b);\n            this.renderer.attr(d, {\n              fill: n.fill,\n              \"fill-opacity\": o[\"fill-opacity\"],\n              \"stroke-opacity\": o[\"fill-opacity\"],\n              stroke: n.stroke,\n              \"stroke-width\": o[\"stroke-width\"],\n              \"stroke-dasharray\": o[\"stroke-dasharray\"]\n            });\n          }\n\n          if (this._isVML) {\n            this.renderer.updateCircle(d, undefined, undefined, b);\n          } else {\n            this.renderer.attr(d, {\n              r: b,\n              cy: k,\n              cx: l\n            });\n          }\n        } else {\n          if (d) {\n            this.renderer.removeElement(d);\n          }\n\n          d = this._drawSymbol(p, l, k, n.fill, o[\"fill-opacity\"], n.stroke, o[\"stroke-opacity\"] || o[\"fill-opacity\"], o[\"stroke-width-symbol\"], o[\"stroke-dasharray\"], c || b);\n        }\n\n        if (h) {\n          this.renderer.removeElement(h);\n        }\n\n        h = this._showLabel(o.groupIndex, o.seriesIndex, n.itemIndex, {\n          x: l - b,\n          y: k - b,\n          width: 2 * b,\n          height: 2 * b\n        });\n\n        if (g >= 1) {\n          this._installHandlers(d, \"circle\", o.groupIndex, o.seriesIndex, n.itemIndex);\n        }\n\n        this._setRenderInfo(o.groupIndex, o.seriesIndex, j[e].itemIndex, {\n          element: d,\n          labelElement: h\n        });\n      }\n    },\n    _showMultiSeriesToolTip: function _showMultiSeriesToolTip(n, l, e) {\n      var s = this;\n      var w = '<div style=\"text-align:left\">';\n      var h = \"\";\n\n      for (var B = 0; B < s.seriesGroups.length; B++) {\n        if (s._isPieGroup(B)) {\n          continue;\n        }\n\n        var j = s._getXAxis(B);\n\n        var c = s._getValueAxis(B);\n\n        var i = s.seriesGroups[B];\n\n        var f = this._getAxisSettings(j);\n\n        var A = f.toolTipFormatSettings;\n        var d = f.toolTipFormatFunction;\n\n        var q = s._getDataValue(e, j.dataField, B);\n\n        if (j.dataField == undefined || j.dataField == \"\") {\n          q = e;\n        }\n\n        if (j.type == \"date\") {\n          q = s._castAsDate(q, (A ? A.dateFormat : undefined) || j.dateFormat);\n        }\n\n        if (!d && !A && j.type == \"date\") {\n          d = this._getDefaultDTFormatFn(j.baseUnit || \"day\");\n        }\n\n        var r = j.displayText || j.dataField || \"\";\n\n        if (r != \"\") {\n          r += \": \";\n        }\n\n        var b = r + s._formatValue(q, A, d, B, v, e);\n\n        if (h != b) {\n          if (h != \"\") {\n            w += \"<br />\";\n          }\n\n          w += b + \"<br /><br />\";\n          h = b;\n        }\n\n        for (var v = 0; v < i.series.length; v++) {\n          var t = i.series[v];\n\n          if (i.showToolTips == false || t.showToolTips == false) {\n            continue;\n          }\n\n          if (!s._isSerieVisible(B, v)) {\n            continue;\n          }\n\n          var g = s._get([t.toolTipFormatSettings, i.toolTipFormatSettings, c.toolTipFormatSettings, s.toolTipFormatSettings]);\n\n          var p = s._get([t.toolTipFormatFunction, i.toolTipFormatFunction, c.toolTipFormatFunction, s.toolTipFormatFunction]);\n\n          var o = s._getFormattedValue(B, v, e, g, p);\n\n          var k = s._getColors(B, v, e);\n\n          w += \"<span style='color:\" + k.lineColor + \";'>\" + o + \"</span><br />\\n\";\n        }\n      }\n\n      var z = this._get([s.toolTipClass, this.toThemeProperty(\"jqx-chart-tooltip-text\", null)]);\n\n      var C = this._get([s.toolTipBackground, \"#FFFFFF\"]);\n\n      var D = this._get([s.toolTipLineColor, s._defaultLineColor]);\n\n      var m = this._get([s.toolTipOpacity, 1]);\n\n      w += \"</div>\";\n      var u = this.getItemCoord(s._ttEl.gidx, s._ttEl.sidx, s._ttEl.iidx);\n\n      s._createTooltip(u, s.seriesGroups[s._ttEl.gidx], w, {\n        css: z,\n        fill: C,\n        stroke: D,\n        fillOpacity: m,\n        symbolSize: 3\n      });\n    },\n    _showToolTip: function _showToolTip(K, I, n, e, b) {\n      var h = this;\n\n      var w = h._getXAxis(n);\n\n      var l = h._getValueAxis(n);\n\n      if (h._ttEl && n == h._ttEl.gidx && e == h._ttEl.sidx && b == h._ttEl.iidx) {\n        return;\n      }\n\n      var s = h.seriesGroups[n];\n      var g = s.series[e];\n      var G = h.enableCrosshairs;\n\n      if (h._pointMarker) {\n        K = parseInt(h._pointMarker.x + 5);\n        I = parseInt(h._pointMarker.y - 5);\n      } else {\n        G = false;\n      }\n\n      var X = G && h.showToolTips == false;\n      K = a.jqx._ptrnd(K);\n      I = a.jqx._ptrnd(I);\n      var m = h._ttEl == undefined;\n\n      if (s.showToolTips == false || g.showToolTips == false) {\n        return;\n      }\n\n      if (!h._ttEl) {\n        h._ttEl = {};\n      }\n\n      h._ttEl.sidx = e;\n      h._ttEl.gidx = n;\n      h._ttEl.iidx = b;\n      var f = 0;\n\n      for (var T = 0; T < h.seriesGroups.length; T++) {\n        for (var S = 0; S < h.seriesGroups[T].series.length; S++) {\n          f++;\n        }\n      }\n\n      if (h.showToolTipsOnAllSeries && !h._isPieGroup(n) && f > 1) {\n        h._showMultiSeriesToolTip(K, I, b);\n\n        return;\n      }\n\n      var z = h._get([g.toolTipFormatSettings, s.toolTipFormatSettings, l.toolTipFormatSettings, h.toolTipFormatSettings]);\n\n      var F = h._get([g.toolTipFormatFunction, s.toolTipFormatFunction, l.toolTipFormatFunction, h.toolTipFormatFunction]);\n\n      var O = h._getColors(n, e, b);\n\n      var d = h._getDataValue(b, w.dataField, n);\n\n      if (w.dataField == undefined || w.dataField == \"\") {\n        d = b;\n      }\n\n      if (w.type == \"date\") {\n        d = h._castAsDate(d, (z ? z.dateFormat : undefined) || w.dateFormat);\n      }\n\n      var C = \"\";\n\n      if (a.isFunction(F)) {\n        var M = {};\n        var v = 0;\n\n        for (var k in g) {\n          if (k.indexOf(\"dataField\") == 0) {\n            M[k.substring(9, k.length).toLowerCase()] = h._getDataValue(b, g[k], n);\n            v++;\n          }\n        }\n\n        if (v == 0) {\n          M = h._getDataValue(b, undefined, n);\n        } else {\n          if (v == 1) {\n            M = M[\"\"];\n          }\n        }\n\n        C = F(M, b, g, s, d, w);\n      } else {\n        C = h._getFormattedValue(n, e, b, z, F);\n\n        var L = this._getAxisSettings(w);\n\n        var P = L.toolTipFormatSettings;\n        var U = L.toolTipFormatFunction;\n\n        if (!U && !P && w.type == \"date\") {\n          U = this._getDefaultDTFormatFn(w.baseUnit || \"day\");\n        }\n\n        var o = h._formatValue(d, P, U, n, e, b);\n\n        if (!h._isPieGroup(n)) {\n          var N = w.displayText || w.dataField || \"\";\n\n          if (N.length > 0) {\n            C = N + \": \" + o + \"<br>\" + C;\n          } else {\n            C = o + \"<br>\" + C;\n          }\n        } else {\n          d = h._getDataValue(b, g.displayText || g.dataField, n);\n          o = h._formatValue(d, P, U, n, e, b);\n          C = o + \": \" + C;\n        }\n      }\n\n      var D = h.renderer.getRect();\n\n      if (G) {\n        var J = a.jqx._ptrnd(h._pointMarker.x);\n\n        var H = a.jqx._ptrnd(h._pointMarker.y);\n\n        var B = h.crosshairsColor || h._defaultLineColor;\n\n        if (s.polar || s.spider) {\n          var E = this._getPolarAxisCoords(n, this._plotRect);\n\n          var c = a.jqx._ptdist(J, H, E.x, E.y);\n\n          if (c > E.r) {\n            return;\n          }\n\n          var A = Math.atan2(H - E.y, J - E.x);\n          var p = Math.cos(A) * E.r + E.x;\n          var W = Math.sin(A) * E.r + E.y;\n\n          if (h._ttEl.vLine) {\n            h.renderer.attr(h._ttEl.vLine, {\n              x1: E.x,\n              y1: E.y,\n              x2: p,\n              y2: W\n            });\n          } else {\n            h._ttEl.vLine = h.renderer.line(E.x, E.y, p, W, {\n              stroke: B,\n              \"stroke-width\": h.crosshairsLineWidth || 1,\n              \"stroke-dasharray\": h.crosshairsDashStyle || \"\"\n            });\n          }\n        } else {\n          if (h._ttEl.vLine && h._ttEl.hLine) {\n            h.renderer.attr(h._ttEl.vLine, {\n              x1: J,\n              x2: J\n            });\n            h.renderer.attr(h._ttEl.hLine, {\n              y1: H,\n              y2: H\n            });\n          } else {\n            h._ttEl.vLine = h.renderer.line(J, h._plotRect.y, J, h._plotRect.y + h._plotRect.height, {\n              stroke: B,\n              \"stroke-width\": h.crosshairsLineWidth || 1,\n              \"stroke-dasharray\": h.crosshairsDashStyle || \"\"\n            });\n            h._ttEl.hLine = h.renderer.line(h._plotRect.x, H, h._plotRect.x + h._plotRect.width, H, {\n              stroke: B,\n              \"stroke-width\": h.crosshairsLineWidth || 1,\n              \"stroke-dasharray\": h.crosshairsDashStyle || \"\"\n            });\n          }\n        }\n      }\n\n      if (!X && h.showToolTips != false) {\n        var Q = this._get([g.toolTipClass, s.toolTipClass, h.toolTipClass, this.toThemeProperty(\"jqx-chart-tooltip-text\", null)]);\n\n        var u = this._get([g.toolTipBackground, s.toolTipBackground, h.toolTipBackground, \"#FFFFFF\"]);\n\n        var r = this._get([g.toolTipLineColor, s.toolTipLineColor, h.toolTipLineColor, O.lineColor]);\n\n        var R = this._get([g.toolTipOpacity, s.toolTipOpacity, h.toolTipOpacity, 1]);\n\n        var q = this.getItemCoord(n, e, b);\n        var V = 0;\n\n        if (h._pointMarker && h._pointMarker.element) {\n          V = g.symbolSizeSelected;\n\n          if (isNaN(V)) {\n            V = g.symbolSize;\n          }\n\n          if (isNaN(V) || V > 50 || V < 0) {\n            V = s.symbolSize;\n          }\n\n          if (isNaN(V) || V > 50 || V < 0) {\n            V = 8;\n          }\n        }\n\n        h._createTooltip(q, s, C, {\n          css: Q,\n          fill: u,\n          stroke: r,\n          fillOpacity: R,\n          symbolSize: V\n        });\n      }\n    },\n    _fitTooltip: function _fitTooltip(c, h, j, k, e) {\n      var d = {};\n      var b = 2 + e / 2;\n      var f = 7;\n\n      if (h.x - j.width - f - b > c.x && h.y + h.height / 2 - j.height / 2 > c.y && h.y + h.height / 2 + j.height / 2 < c.y + c.height) {\n        d.left = {\n          arrowLocation: \"right\",\n          x: h.x - j.width - f - b,\n          y: h.y + h.height / 2 - j.height / 2,\n          width: j.width + f,\n          height: j.height\n        };\n      }\n\n      if (h.x + h.width + j.width + f + b < c.x + c.width && h.y + h.height / 2 - j.height / 2 > c.y && h.y + h.height / 2 + j.height / 2 < c.y + c.height) {\n        d.right = {\n          arrowLocation: \"left\",\n          x: h.x + h.width + b,\n          y: h.y + h.height / 2 - j.height / 2,\n          width: j.width + f,\n          height: j.height\n        };\n      }\n\n      if (h.y - j.height - b - f > c.y && h.x + h.width / 2 - j.width / 2 > c.x && h.x + h.width / 2 + j.width / 2 < c.x + c.width) {\n        d.top = {\n          arrowLocation: \"bottom\",\n          x: h.x + h.width / 2 - j.width / 2,\n          y: h.y - j.height - b - f,\n          width: j.width,\n          height: j.height + f\n        };\n      }\n\n      if (h.y + h.height + j.height + f + b < c.y + c.height && h.x + h.width / 2 - j.width / 2 > c.x && h.x + h.width / 2 + j.width / 2 < c.x + c.width) {\n        d.bottom = {\n          arrowLocation: \"top\",\n          x: h.x + h.width / 2 - j.width / 2,\n          y: h.y + h.height + b,\n          width: j.width,\n          height: j.height + f\n        };\n      }\n\n      if (h.width > h.height || (k.type.indexOf(\"stackedcolumn\") != -1 || k.type.indexOf(\"stackedwaterfall\") != -1) && k.orientation != \"horizontal\") {\n        if (d.left) {\n          return d.left;\n        }\n\n        if (d.right) {\n          return d.right;\n        }\n      } else {\n        if (d.top) {\n          return d.top;\n        }\n\n        if (d.bottom) {\n          return d.bottom;\n        }\n      }\n\n      for (var g in d) {\n        if (d[g]) {\n          return d[g];\n        }\n      }\n\n      return {\n        arrowLocation: \"\"\n      };\n    },\n    _createTooltip: function _createTooltip(G, l, A, B) {\n      var u = this;\n      var z = l.type;\n      var E = false;\n      var F = u._ttEl.box;\n\n      if (!F) {\n        E = true;\n        F = u._ttEl.box = document.createElement(\"div\");\n        var f = 10000000;\n        F.style.position = \"absolute\";\n        F.style.cursor = \"default\";\n        a(b).css({\n          \"z-index\": f,\n          \"box-sizing\": \"content-box\"\n        });\n        a(F).css({\n          \"z-index\": f\n        });\n        a(document.body).append(F);\n        var b = document.createElement(\"div\");\n        b.id = \"arrowOuterDiv\";\n        b.style.width = \"0px\";\n        b.style.height = \"0px\";\n        b.style.position = \"absolute\";\n        a(b).css({\n          \"z-index\": f + 1,\n          \"box-sizing\": \"content-box\"\n        });\n        var h = document.createElement(\"div\");\n        h.id = \"arrowInnerDiv\";\n        h.style.width = \"0px\";\n        h.style.height = \"0px\";\n        h.style.position = \"absolute\";\n        var w = document.createElement(\"div\");\n        w.id = \"contentDiv\";\n        w.style.position = \"absolute\";\n        a(w).css({\n          \"box-sizing\": \"content-box\",\n          outline: \"none\",\n          border: \"1px solid transparent\",\n          padding: \"3px\",\n          \"text-align\": \"center\",\n          \"vertical-align\": \"middle\",\n          margin: \"0 0 0 0\",\n          cursor: \"default\"\n        });\n        a(w).addClass(\"jqx-rc-all\");\n        a(w).appendTo(a(F));\n        a(b).appendTo(a(F));\n        a(h).appendTo(a(F));\n        a(h).css({\n          \"z-index\": f + 2,\n          \"box-sizing\": \"content-box\"\n        });\n      }\n\n      if (!A || A.length == 0) {\n        a(F).fadeTo(0, 0);\n        return;\n      }\n\n      w = a(F).find(\"#contentDiv\")[0];\n      b = a(F).find(\"#arrowOuterDiv\")[0];\n      h = a(F).find(\"#arrowInnerDiv\")[0];\n      h.style.opacity = b.style.opacity = B.fillOpacity;\n      w.style.backgroundColor = B.fill;\n      w.style.borderColor = B.stroke;\n      w.style.opacity = B.fillOpacity;\n      var p = \"<span class='\" + B.css + \"'>\" + A + \"</span>\";\n      a(w).html(p);\n\n      var t = this._measureHtml(p, \"jqx-rc-all jqx-button\");\n\n      var c = u._plotRect;\n\n      if (t.width > c.width || t.height > c.height) {\n        return;\n      }\n\n      var r = {\n        width: t.width,\n        height: t.height\n      };\n      var j = \"\";\n      var D = 5;\n      var s = 7;\n\n      var v = u._isColumnType(z);\n\n      var o = Math.max(G.x, c.x);\n      var m = Math.max(G.y, c.y);\n\n      if (u.toolTipAlignment == \"dataPoint\") {\n        if (z.indexOf(\"pie\") != -1 || z.indexOf(\"donut\") != -1) {\n          var n = (G.fromAngle + G.toAngle) / 2;\n          n = n * (Math.PI / 180);\n          var g = !isNaN(G.innerRadius) && G.innerRadius > 0 ? (G.innerRadius + G.outerRadius) / 2 : G.outerRadius * 0.75;\n          o = G.x = G.center.x + Math.cos(n) * g;\n          m = G.y = G.center.y - Math.sin(n) * g;\n          G.width = G.height = 1;\n        } else {\n          if (v && (l.polar || l.spider)) {\n            G.width = G.height = 1;\n          }\n        }\n\n        var C = this._fitTooltip(this._plotRect, G, r, l, B.symbolSize);\n\n        if (C.arrowLocation != \"\") {\n          j = C.arrowLocation;\n          o = C.x;\n          m = C.y;\n          r.width = C.width;\n          r.height = C.height;\n        }\n      } else {\n        j = \"\";\n      }\n\n      if (j == \"top\" || j == \"bottom\") {\n        r.height += s;\n        o -= s / 2;\n\n        if (j == \"bottom\") {\n          m -= s;\n        }\n      } else {\n        if (j == \"left\" || j == \"right\") {\n          r.width += s;\n          m -= s / 2;\n\n          if (j == \"right\") {\n            o -= s;\n          }\n        }\n      }\n\n      if (o + r.width > c.x + c.width) {\n        j = \"\";\n        o = c.x + c.width - r.width;\n      }\n\n      if (m + r.height > c.y + c.height) {\n        j = \"\";\n        m = c.y + c.height - r.height;\n      }\n\n      var i = {\n        x: 0,\n        y: 0\n      },\n          e = {\n        x: 0,\n        y: 0\n      };\n      a(w).css({\n        width: t.width,\n        height: t.height,\n        left: 0,\n        top: 0\n      });\n      b.style[\"margin-top\"] = b.style[\"margin-left\"] = 0;\n      h.style[\"margin-top\"] = h.style[\"margin-left\"] = 0;\n      w.style[\"margin-top\"] = w.style[\"margin-left\"] = 0;\n      var k = s + \"px solid\";\n      var d = s + \"px solid transparent\";\n\n      switch (j) {\n        case \"left\":\n          i = {\n            x: 0,\n            y: (t.height - s) / 2\n          };\n          e = {\n            x: s,\n            y: 0\n          };\n          w.style[\"margin-left\"] = s + \"px\";\n          b.style[\"margin-left\"] = 0 + \"px\";\n          b.style[\"margin-top\"] = i.y + \"px\";\n          b.style[\"border-left\"] = \"\";\n          b.style[\"border-right\"] = k + \" \" + B.stroke;\n          b.style[\"border-top\"] = d;\n          b.style[\"border-bottom\"] = d;\n          h.style[\"margin-left\"] = 1 + \"px\";\n          h.style[\"margin-top\"] = i.y + \"px\";\n          h.style[\"border-left\"] = \"\";\n          h.style[\"border-right\"] = k + \" \" + B.fill;\n          h.style[\"border-top\"] = d;\n          h.style[\"border-bottom\"] = d;\n          break;\n\n        case \"right\":\n          i = {\n            x: r.width - s,\n            y: (t.height - s) / 2\n          };\n          e = {\n            x: 0,\n            y: 0\n          };\n          b.style[\"margin-left\"] = i.x + \"px\";\n          b.style[\"margin-top\"] = i.y + \"px\";\n          b.style[\"border-left\"] = k + \" \" + B.stroke;\n          b.style[\"border-right\"] = \"\";\n          b.style[\"border-top\"] = d;\n          b.style[\"border-bottom\"] = d;\n          h.style[\"margin-left\"] = i.x - 1 + \"px\";\n          h.style[\"margin-top\"] = i.y + \"px\";\n          h.style[\"border-left\"] = k + \" \" + B.fill;\n          h.style[\"border-right\"] = \"\";\n          h.style[\"border-top\"] = d;\n          h.style[\"border-bottom\"] = d;\n          break;\n\n        case \"top\":\n          i = {\n            x: r.width / 2 - s / 2,\n            y: 0\n          };\n          e = {\n            x: 0,\n            y: s\n          };\n          w.style[\"margin-top\"] = e.y + \"px\";\n          b.style[\"margin-left\"] = i.x + \"px\";\n          b.style[\"border-top\"] = \"\";\n          b.style[\"border-bottom\"] = k + \" \" + B.stroke;\n          b.style[\"border-left\"] = d;\n          b.style[\"border-right\"] = d;\n          h.style[\"margin-left\"] = i.x + \"px\";\n          h.style[\"margin-top\"] = 1 + \"px\";\n          h.style[\"border-top\"] = \"\";\n          h.style[\"border-bottom\"] = k + \" \" + B.fill;\n          h.style[\"border-left\"] = d;\n          h.style[\"border-right\"] = d;\n          break;\n\n        case \"bottom\":\n          i = {\n            x: r.width / 2 - s / 2,\n            y: r.height - s\n          };\n          e = {\n            x: 0,\n            y: 0\n          };\n          b.style[\"margin-left\"] = i.x + \"px\";\n          b.style[\"margin-top\"] = i.y + \"px\";\n          b.style[\"border-top\"] = k + \" \" + B.stroke;\n          b.style[\"border-bottom\"] = \"\";\n          b.style[\"border-left\"] = d;\n          b.style[\"border-right\"] = d;\n          h.style[\"margin-left\"] = i.x + \"px\";\n          h.style[\"margin-top\"] = i.y - 1 + \"px\";\n          h.style[\"border-top\"] = k + \" \" + B.fill;\n          h.style[\"border-bottom\"] = \"\";\n          h.style[\"border-left\"] = d;\n          h.style[\"border-right\"] = d;\n          break;\n      }\n\n      if (j == \"\") {\n        a(b).hide();\n        a(h).hide();\n      } else {\n        a(b).show();\n        a(h).show();\n      }\n\n      a(F).css({\n        width: r.width + \"px\",\n        height: r.height + \"px\"\n      });\n      var q = u.host.coord();\n\n      if (E) {\n        a(F).fadeOut(0, 0);\n        F.style.left = o + q.left + \"px\";\n        F.style.top = m + q.top + \"px\";\n      }\n\n      a(F).clearQueue();\n      a(F).animate({\n        left: o + q.left,\n        top: m + q.top,\n        opacity: 1\n      }, u.toolTipMoveDuration, \"easeInOutCirc\");\n      a(F).fadeTo(400, 1);\n    },\n    _measureHtml: function _measureHtml(c, b) {\n      var e = this._measureDiv;\n\n      if (!e) {\n        this._measureDiv = e = document.createElement(\"div\");\n        e.style.position = \"absolute\";\n        e.style.cursor = \"default\";\n        e.style.overflow = \"hidden\";\n        e.style.display = \"none\";\n        a(e).addClass(b);\n        this.host.append(e);\n      }\n\n      a(e).html(c);\n      var d = {\n        width: a(e).width() + 2,\n        height: a(e).height() + 2\n      };\n\n      if (a.jqx.browser && a.jqx.browser.mozilla) {\n        d.height += 3;\n      }\n\n      return d;\n    },\n    _hideToolTip: function _hideToolTip(b) {\n      if (!this._ttEl) {\n        return;\n      }\n\n      if (this._ttEl.box) {\n        if (b == 0) {\n          a(this._ttEl.box).hide();\n        } else {\n          a(this._ttEl.box).fadeOut();\n        }\n      }\n\n      this._hideCrosshairs();\n\n      this._ttEl.gidx = undefined;\n    },\n    _hideCrosshairs: function _hideCrosshairs() {\n      if (!this._ttEl) {\n        return;\n      }\n\n      if (this._ttEl.vLine) {\n        this.renderer.removeElement(this._ttEl.vLine);\n        this._ttEl.vLine = undefined;\n      }\n\n      if (this._ttEl.hLine) {\n        this.renderer.removeElement(this._ttEl.hLine);\n        this._ttEl.hLine = undefined;\n      }\n    },\n    _get: function _get(b) {\n      return a.jqx.getByPriority(b);\n    },\n    _getAxisSettings: function _getAxisSettings(f) {\n      if (!f) {\n        return {};\n      }\n\n      var l = this;\n      var k = f.gridLines || {};\n      var n = {\n        visible: this._get([k.visible, f.showGridLines, true]),\n        color: l._get([k.color, f.gridLinesColor, l._defaultLineColor]),\n        unitInterval: l._get([k.unitInterval, k.interval, f.gridLinesInterval]),\n        step: l._get([k.step, f.gridLinesStep]),\n        dashStyle: l._get([k.dashStyle, f.gridLinesDashStyle]),\n        width: l._get([k.lineWidth, 1]),\n        offsets: [],\n        alternatingBackgroundColor: f.alternatingBackgroundColor,\n        alternatingBackgroundColor2: f.alternatingBackgroundColor2,\n        alternatingBackgroundOpacity: f.alternatingBackgroundOpacity\n      };\n      var d = f.tickMarks || {};\n      var h = {\n        visible: this._get([d.visible, f.showTickMarks, true]),\n        color: l._get([d.color, f.tickMarksColor, l._defaultLineColor]),\n        unitInterval: l._get([d.unitInterval, d.interval, f.tickMarksInterval]),\n        step: l._get([d.step, f.tickMarksStep]),\n        dashStyle: l._get([d.dashStyle, f.tickMarksDashStyle]),\n        width: l._get([d.lineWidth, 1]),\n        size: l._get([d.size, 4]),\n        offsets: []\n      };\n      var e = f.title || {};\n      var c = {\n        visible: l._get([e.visible, true]),\n        text: l._get([f.description, e.text]),\n        style: l._get([f.descriptionClass, e[\"class\"], l.toThemeProperty(\"jqx-chart-axis-description\", null)]),\n        halign: l._get([f.horizontalDescriptionAlignment, e.horizontalAlignment, \"center\"]),\n        valign: l._get([f.verticalDescriptionAlignment, e.verticalAlignment, \"center\"]),\n        angle: 0,\n        rotationPoint: l._get([e.rotationPoint, \"centercenter\"]),\n        offset: l._get([e.offset, {\n          x: 0,\n          y: 0\n        }])\n      };\n      var i = f.line || {};\n      var b = {\n        visible: l._get([i.visible, true]),\n        color: l._get([i.color, n.color, l._defaultLineColor]),\n        dashStyle: l._get([i.dashStyle, n.dashStyle, \"\"]),\n        width: l._get([i.lineWidth, 1]),\n        angle: l._get([i.angle, NaN])\n      };\n      var j = f.padding || {};\n      j = {\n        left: j.left || 0,\n        right: j.right || 0,\n        top: j.top || 0,\n        bottom: j.bottom || 0\n      };\n\n      var g = this._getAxisLabelsSettings(f);\n\n      var m = {\n        visible: this._get([f.visible, f.showValueAxis, f.showXAxis, f.showCategoryAxis, true]),\n        customDraw: this._get([f.customDraw, false]),\n        gridLines: n,\n        tickMarks: h,\n        line: b,\n        title: c,\n        labels: g,\n        padding: j,\n        toolTipFormatFunction: this._get([f.toolTipFormatFunction, f.formatFunction, g.formatFunction]),\n        toolTipFormatSettings: this._get([f.toolTipFormatSettings, f.formatSettings, g.formatSettings])\n      };\n      return m;\n    },\n    _getAxisLabelsSettings: function _getAxisLabelsSettings(d) {\n      var b = this;\n      var e = d.labels || {};\n      var c = {\n        visible: b._get([d.showLabels, e.visible, true]),\n        unitInterval: b._get([e.unitInterval, e.interval, d.labelsInterval]),\n        step: b._get([e.step, d.labelsStep]),\n        angle: b._get([d.textRotationAngle, e.angle, 0]),\n        style: b._get([d[\"class\"], e[\"class\"], b.toThemeProperty(\"jqx-chart-axis-text\", null)]),\n        halign: b._get([d.horizontalTextAlignment, e.horizontalAlignment, \"center\"]),\n        valign: b._get([d.verticalTextAlignment, e.verticalAlignment, \"center\"]),\n        textRotationPoint: b._get([d.textRotationPoint, e.rotationPoint, \"auto\"]),\n        textOffset: b._get([d.textOffset, e.offset, {\n          x: 0,\n          y: 0\n        }]),\n        autoRotate: b._get([d.labelsAutoRotate, e.autoRotate, false]),\n        formatSettings: b._get([d.formatSettings, e.formatSettings, undefined]),\n        formatFunction: b._get([d.formatFunction, e.formatFunction, undefined])\n      };\n      return c;\n    },\n    _getLabelsSettings: function _getLabelsSettings(p, l, h, t) {\n      var j = this.seriesGroups[p];\n      var r = j.series[l];\n      var m = isNaN(h) ? undefined : this._getDataValue(h, r.dataField, p);\n      var k = t || [\"Visible\", \"Offset\", \"Angle\", \"HorizontalAlignment\", \"VerticalAlignment\", \"Class\", \"BackgroundColor\", \"BorderColor\", \"BorderOpacity\", \"Padding\", \"Opacity\", \"BackgroundOpacity\", \"LinesAngles\", \"LinesEnabled\", \"AutoRotate\", \"Radius\"];\n      var q = {};\n\n      for (var f = 0; f < k.length; f++) {\n        var n = k[f];\n        var c = \"labels\" + n;\n        var b = \"label\" + n;\n        var o = n.substring(0, 1).toLowerCase() + n.substring(1);\n        var d = undefined;\n\n        if (j.labels && typeof j.labels == \"object\") {\n          d = j.labels[o];\n        }\n\n        if (r.labels && typeof r.labels == \"object\" && undefined != r.labels[o]) {\n          d = r.labels[o];\n        }\n\n        d = this._get([r[c], r[b], d, j[c], j[b]]);\n\n        if (a.isFunction(d)) {\n          q[o] = d(m, h, r, j);\n        } else {\n          q[o] = d;\n        }\n      }\n\n      q[\"class\"] = q[\"class\"] || this.toThemeProperty(\"jqx-chart-label-text\", null);\n      q.visible = this._get([q.visible, r.showLabels, j.showLabels, r.labels != undefined ? true : undefined, j.labels != undefined ? true : undefined]);\n      var e = q.padding || 1;\n      q.padding = {\n        left: this._get([e.left, isNaN(e) ? 1 : e]),\n        right: this._get([e.right, isNaN(e) ? 1 : e]),\n        top: this._get([e.top, isNaN(e) ? 1 : e]),\n        bottom: this._get([e.bottom, isNaN(e) ? 1 : e])\n      };\n      return q;\n    },\n    _showLabel: function _showLabel(J, E, f, b, t, i, e, k, c, F, B) {\n      var m = this.seriesGroups[J];\n      var r = m.series[E];\n      var C = {\n        width: 0,\n        height: 0\n      },\n          q;\n\n      if (isNaN(f)) {\n        return;\n      }\n\n      var I = this._getLabelsSettings(J, E, f);\n\n      if (!I.visible) {\n        return e ? C : undefined;\n      }\n\n      if (b.width < 0 || b.height < 0) {\n        return e ? C : undefined;\n      }\n\n      var g = I.angle;\n\n      if (!isNaN(F)) {\n        g = F;\n      }\n\n      var j = I.offset || {};\n      var G = {\n        x: j.x,\n        y: j.y\n      };\n\n      if (isNaN(G.x)) {\n        G.x = 0;\n      }\n\n      if (isNaN(G.y)) {\n        G.y = 0;\n      }\n\n      t = t || I.horizontalAlignment || \"center\";\n      i = i || I.verticalAlignment || \"center\";\n\n      var v = this._getFormattedValue(J, E, f, undefined, undefined, true);\n\n      var s = b.width;\n      var H = b.height;\n\n      if (k == true && t != \"center\") {\n        t = t == \"right\" ? \"left\" : \"right\";\n      }\n\n      if (c == true && i != \"center\" && i != \"middle\") {\n        i = i == \"top\" ? \"bottom\" : \"top\";\n        G.y *= -1;\n      }\n\n      C = this.renderer.measureText(v, g, {\n        \"class\": I[\"class\"]\n      });\n\n      if (e) {\n        return C;\n      }\n\n      var p = 0,\n          n = 0;\n\n      if (s > 0) {\n        if (t == \"\" || t == \"center\") {\n          p += (s - C.width) / 2;\n        } else {\n          if (t == \"right\") {\n            p += s - C.width;\n          }\n        }\n      }\n\n      if (H > 0) {\n        if (i == \"\" || i == \"center\") {\n          n += (H - C.height) / 2;\n        } else {\n          if (i == \"bottom\") {\n            n += H - C.height;\n          }\n        }\n      }\n\n      p += b.x + G.x;\n      n += b.y + G.y;\n      var o = this._plotRect;\n\n      if (p <= o.x) {\n        p = o.x + 2;\n      }\n\n      if (n <= o.y) {\n        n = o.y + 2;\n      }\n\n      var l = {\n        width: Math.max(C.width, 1),\n        height: Math.max(C.height, 1)\n      };\n\n      if (n + l.height >= o.y + o.height) {\n        n = o.y + o.height - (q ? (l.height + q.height) / 2 : l.height) - 2;\n      }\n\n      if (p + l.width >= o.x + o.width) {\n        p = o.x + o.width - l.width - 2;\n      }\n\n      var d;\n      var A = I.backgroundColor;\n      var D = I.borderColor;\n      var z = I.padding;\n\n      if (A || D) {\n        d = this.renderer.beginGroup();\n        var b = this.renderer.rect(p - z.left, n - z.top, C.width + z.left + z.right, C.height + z.bottom + z.bottom, {\n          fill: A || \"transparent\",\n          \"fill-opacity\": I.backgroundOpacity || 1,\n          stroke: D || \"transparent\",\n          \"stroke-opacity\": I.borderOpacity,\n          \"stroke-width\": 1\n        });\n      }\n\n      var u = this.renderer.text(v, p, n, C.width, C.height, g, {\n        \"class\": I[\"class\"],\n        opacity: I.opacity || 1\n      }, false, \"center\", \"center\");\n\n      if (B) {\n        B.x = p - z.left;\n        B.y = n - z.top;\n        B.width = C.width + z.left + z.right;\n        B.height = C.height + z.bottom + z.bottom;\n      }\n\n      if (this._isVML) {\n        this.renderer.removeElement(u);\n        this.renderer.getContainer()[0].appendChild(u);\n      }\n\n      if (d) {\n        this.renderer.endGroup();\n      }\n\n      return d || u;\n    },\n    _getAnimProps: function _getAnimProps(j, f) {\n      var e = this.seriesGroups[j];\n      var c = !isNaN(f) ? e.series[f] : undefined;\n      var b = this.enableAnimations == true;\n\n      if (e.enableAnimations) {\n        b = e.enableAnimations == true;\n      }\n\n      if (c && c.enableAnimations) {\n        b = c.enableAnimations == true;\n      }\n\n      var i = this.animationDuration;\n\n      if (isNaN(i)) {\n        i = 1000;\n      }\n\n      var d = e.animationDuration;\n\n      if (!isNaN(d)) {\n        i = d;\n      }\n\n      if (c) {\n        var h = c.animationDuration;\n\n        if (!isNaN(h)) {\n          i = h;\n        }\n      }\n\n      if (i > 5000) {\n        i = 1000;\n      }\n\n      return {\n        enabled: b,\n        duration: i\n      };\n    },\n    _isColorTransition: function _isColorTransition(f, d, e, g) {\n      if (g - 1 < e.xoffsets.first) {\n        return false;\n      }\n\n      var b = this._getColors(f, d, g, this._getGroupGradientType(f));\n\n      var c = this._getColors(f, d, g - 1, this._getGroupGradientType(f));\n\n      return b.fillColor != c.fillColor;\n    },\n    _renderLineSeries: function _renderLineSeries(k, Q) {\n      var H = this.seriesGroups[k];\n\n      if (!H.series || H.series.length == 0) {\n        return;\n      }\n\n      var s = H.type.indexOf(\"area\") != -1;\n      var K = H.type.indexOf(\"stacked\") != -1;\n      var e = K && H.type.indexOf(\"100\") != -1;\n      var ae = H.type.indexOf(\"spline\") != -1;\n      var t = H.type.indexOf(\"step\") != -1;\n      var O = H.type.indexOf(\"range\") != -1;\n      var af = H.polar == true || H.spider == true;\n\n      if (af) {\n        t = false;\n      }\n\n      if (t && ae) {\n        return;\n      }\n\n      var z = this._getDataLen(k);\n\n      var ac = Q.width / z;\n      var aj = H.orientation == \"horizontal\";\n      var B = this._getXAxis(k).flip == true;\n      var y = Q;\n\n      if (aj) {\n        y = {\n          x: Q.y,\n          y: Q.x,\n          width: Q.height,\n          height: Q.width\n        };\n      }\n\n      var C = this._calcGroupOffsets(k, y);\n\n      if (!C || C.xoffsets.length == 0) {\n        return;\n      }\n\n      if (!this._linesRenderInfo) {\n        this._linesRenderInfo = {};\n      }\n\n      this._linesRenderInfo[k] = {};\n\n      for (var n = H.series.length - 1; n >= 0; n--) {\n        var g = this._getSerieSettings(k, n);\n\n        var ah = {\n          groupIndex: k,\n          rect: y,\n          serieIndex: n,\n          swapXY: aj,\n          isArea: s,\n          isSpline: ae,\n          isRange: O,\n          isPolar: af,\n          settings: g,\n          segments: [],\n          pointsLength: 0\n        };\n\n        var j = this._isSerieVisible(k, n);\n\n        if (!j) {\n          this._linesRenderInfo[k][n] = ah;\n          continue;\n        }\n\n        var J = H.series[n];\n\n        if (J.customDraw) {\n          continue;\n        }\n\n        var w = a.isFunction(J.colorFunction);\n        var U = C.xoffsets.first;\n        var G = U;\n\n        var N = this._getColors(k, n, NaN, this._getGroupGradientType(k));\n\n        var ab = false;\n        var u;\n\n        do {\n          var W = [];\n          var T = [];\n          var r = [];\n          var P = -1;\n          var p = 0,\n              o = 0;\n          var R = NaN;\n          var E = NaN;\n          var ai = NaN;\n\n          if (C.xoffsets.length < 1) {\n            continue;\n          }\n\n          var S = this._getAnimProps(k, n);\n\n          var L = S.enabled && !this._isToggleRefresh && C.xoffsets.length < 10000 && this._isVML != true ? S.duration : 0;\n          var v = U;\n          u = false;\n\n          var d = this._getColors(k, n, U, this._getGroupGradientType(k));\n\n          var D = undefined;\n\n          for (var ad = U; ad <= C.xoffsets.last; ad++) {\n            U = ad;\n            var X = C.xoffsets.data[ad];\n            var V = C.xoffsets.xvalues[ad];\n\n            if (isNaN(X)) {\n              continue;\n            }\n\n            X = Math.max(X, 1);\n            p = X;\n            o = C.offsets[n][ad].to;\n\n            if (!w && D && this.enableSampling && a.jqx._ptdist(D.x, D.y, p, o) < 1) {\n              continue;\n            }\n\n            D = {\n              x: p,\n              y: o\n            };\n            var aa = C.offsets[n][ad].from;\n\n            if (isNaN(o) || isNaN(aa)) {\n              if (J.emptyPointsDisplay == \"connect\") {\n                continue;\n              } else {\n                if (J.emptyPointsDisplay == \"zero\") {\n                  if (isNaN(o)) {\n                    o = C.baseOffset;\n                  }\n\n                  if (isNaN(aa)) {\n                    aa = C.baseOffset;\n                  }\n                } else {\n                  u = true;\n                  break;\n                }\n              }\n            }\n\n            if (w && this._isColorTransition(k, n, C, U)) {\n              if (W.length > 1) {\n                U--;\n                break;\n              }\n            }\n\n            var c = this._elementRenderInfo;\n\n            if (c && c.length > k && c[k].series.length > n) {\n              var f = c[k].series[n][V];\n\n              var ai = a.jqx._ptrnd(f ? f.to : undefined);\n\n              var I = a.jqx._ptrnd(y.x + (f ? f.xoffset : undefined));\n\n              r.push(aj ? {\n                y: I,\n                x: ai,\n                index: ad\n              } : {\n                x: I,\n                y: ai,\n                index: ad\n              });\n            }\n\n            G = ad;\n\n            if (g.stroke < 2) {\n              if (o - y.y <= 1) {\n                o = y.y + 1;\n              }\n\n              if (aa - y.y <= 1) {\n                aa = y.y + 1;\n              }\n\n              if (y.y + y.height - o <= 1) {\n                o = y.y + y.height - 1;\n              }\n\n              if (y.y + y.height - aa <= 1) {\n                aa = y.y + y.height - 1;\n              }\n            }\n\n            if (!s && e) {\n              if (o <= y.y) {\n                o = y.y + 1;\n              }\n\n              if (o >= y.y + y.height) {\n                o = y.y + y.height - 1;\n              }\n\n              if (aa <= y.y) {\n                aa = y.y + 1;\n              }\n\n              if (aa >= y.y + y.height) {\n                aa = y.y + y.height - 1;\n              }\n            }\n\n            X = Math.max(X, 1);\n            p = X + y.x;\n\n            if (H.skipOverlappingPoints == true && !isNaN(R) && Math.abs(R - p) <= 1) {\n              continue;\n            }\n\n            if (t && !isNaN(R) && !isNaN(E)) {\n              if (E != o) {\n                W.push(aj ? {\n                  y: p,\n                  x: a.jqx._ptrnd(E)\n                } : {\n                  x: p,\n                  y: a.jqx._ptrnd(E)\n                });\n              }\n            }\n\n            W.push(aj ? {\n              y: p,\n              x: a.jqx._ptrnd(o),\n              index: ad\n            } : {\n              x: p,\n              y: a.jqx._ptrnd(o),\n              index: ad\n            });\n            T.push(aj ? {\n              y: p,\n              x: a.jqx._ptrnd(aa),\n              index: ad\n            } : {\n              x: p,\n              y: a.jqx._ptrnd(aa),\n              index: ad\n            });\n            R = p;\n            E = o;\n\n            if (isNaN(ai)) {\n              ai = o;\n            }\n          }\n\n          if (W.length == 0) {\n            U++;\n            continue;\n          }\n\n          var F = W[W.length - 1].index;\n\n          if (w) {\n            N = this._getColors(k, n, F, this._getGroupGradientType(k));\n          }\n\n          var l = y.x + C.xoffsets.data[v];\n          var Z = y.x + C.xoffsets.data[G];\n\n          if (s && H.alignEndPointsWithIntervals == true) {\n            var A = B ? -1 : 1;\n\n            if (l > y.x) {\n              l = y.x;\n            }\n\n            if (Z < y.x + y.width) {\n              Z = y.x + y.width;\n            }\n\n            if (B) {\n              var Y = l;\n              l = Z;\n              Z = Y;\n            }\n          }\n\n          Z = a.jqx._ptrnd(Z);\n          l = a.jqx._ptrnd(l);\n          var m = C.baseOffset;\n          ai = a.jqx._ptrnd(ai);\n          var h = a.jqx._ptrnd(o) || m;\n\n          if (O) {\n            W = W.concat(T.reverse());\n          }\n\n          ah.pointsLength += W.length;\n          var b = {\n            lastItemIndex: F,\n            colorSettings: N,\n            pointsArray: W,\n            pointsStart: r,\n            left: l,\n            right: Z,\n            pyStart: ai,\n            pyEnd: h,\n            yBase: m,\n            labelElements: [],\n            symbolElements: []\n          };\n          ah.segments.push(b);\n        } while (U < C.xoffsets.first + C.xoffsets.length - 1 || u);\n\n        this._linesRenderInfo[k][n] = ah;\n      }\n\n      var M = this._linesRenderInfo[k];\n      var ag = [];\n\n      for (var ad in M) {\n        ag.push(M[ad]);\n      }\n\n      ag = ag.sort(function (x, i) {\n        return x.serieIndex - i.serieIndex;\n      });\n\n      if (s && K) {\n        ag.reverse();\n      }\n\n      for (var ad = 0; ad < ag.length; ad++) {\n        var ah = ag[ad];\n\n        this._animateLine(ah, L == 0 ? 1 : 0);\n\n        var q = this;\n\n        this._enqueueAnimation(\"series\", undefined, undefined, L, function (x, i, ak) {\n          q._animateLine(i, ak);\n        }, ah);\n      }\n    },\n    _animateLine: function _animateLine(w, b) {\n      var A = w.settings;\n      var f = w.groupIndex;\n      var g = w.serieIndex;\n      var j = this.seriesGroups[f];\n      var s = j.series[g];\n\n      var v = this._getSymbol(f, g);\n\n      var p = this._getLabelsSettings(f, g, NaN, [\"Visible\"]).visible;\n\n      var o = true;\n\n      if (w.isPolar) {\n        if (!isNaN(j.endAngle) && Math.round(Math.abs((isNaN(j.startAngle) ? 0 : j.startAngle) - j.endAngle)) != 360) {\n          o = false;\n        }\n      }\n\n      if (s.endPointsConnect == false) {\n        o = false;\n      }\n\n      var q = 0;\n\n      for (var d = 0; d < w.segments.length; d++) {\n        var u = w.segments[d];\n\n        var x = this._calculateLine(f, w.pointsLength, q, u.pointsArray, u.pointsStart, u.yBase, b, w.isArea, w.swapXY);\n\n        q += u.pointsArray.length;\n\n        if (x == \"\") {\n          continue;\n        }\n\n        var r = x.split(\" \");\n        var y = r.length;\n        var h = x;\n\n        if (h != \"\") {\n          h = this._buildLineCmd(x, w.isRange, u.left, u.right, u.pyStart, u.pyEnd, u.yBase, w.isArea, w.isPolar, o, w.isSpline, w.swapXY);\n        } else {\n          h = \"M 0 0\";\n        }\n\n        var l = u.colorSettings;\n\n        if (!u.pathElement) {\n          u.pathElement = this.renderer.path(h, {\n            \"stroke-width\": A.stroke,\n            stroke: l.lineColor,\n            \"stroke-opacity\": A.opacity,\n            \"fill-opacity\": A.opacity,\n            \"stroke-dasharray\": A.dashStyle,\n            fill: w.isArea ? l.fillColor : \"none\"\n          });\n\n          this._installHandlers(u.pathElement, \"path\", f, g, u.lastItemIndex);\n        } else {\n          this.renderer.attr(u.pathElement, {\n            d: h\n          });\n        }\n\n        if (u.labelElements) {\n          for (var z = 0; z < u.labelElements.length; z++) {\n            this.renderer.removeElement(u.labelElements[z]);\n          }\n\n          u.labelElements = [];\n        }\n\n        if (u.symbolElements) {\n          for (var z = 0; z < u.symbolElements.length; z++) {\n            this.renderer.removeElement(u.symbolElements[z]);\n          }\n\n          u.symbolElements = [];\n        }\n\n        if (u.pointsArray.length == r.length) {\n          if (v != \"none\" || p) {\n            var C = s.symbolSize;\n            var B = this._plotRect;\n\n            for (var z = 0; z < r.length; z++) {\n              var t = r[z].split(\",\");\n              t = {\n                x: parseFloat(t[0]),\n                y: parseFloat(t[1])\n              };\n\n              if (t.x < B.x || t.x > B.x + B.width || t.y < B.y || t.y > B.y + B.height) {\n                continue;\n              }\n\n              if (v != \"none\") {\n                var n = this._getColors(f, g, u.pointsArray[z].index, this._getGroupGradientType(f));\n\n                var e = this._drawSymbol(v, t.x, t.y, n.fillColorSymbol, A.opacity, n.lineColorSymbol, A.opacity, A.strokeSymbol, undefined, C);\n\n                u.symbolElements.push(e);\n              }\n\n              if (p) {\n                var k = (z > 0 ? r[z - 1] : r[z]).split(\",\");\n                k = {\n                  x: parseFloat(k[0]),\n                  y: parseFloat(k[1])\n                };\n                var m = (z < r.length - 1 ? r[z + 1] : r[z]).split(\",\");\n                m = {\n                  x: parseFloat(m[0]),\n                  y: parseFloat(m[1])\n                };\n                t = this._adjustLineLabelPosition(f, g, u.pointsArray[z].index, t, k, m);\n\n                if (t) {\n                  var c = this._showLabel(f, g, u.pointsArray[z].index, {\n                    x: t.x,\n                    y: t.y,\n                    width: 0,\n                    height: 0\n                  });\n\n                  u.labelElements.push(c);\n                }\n              }\n            }\n          }\n        }\n\n        if (b == 1 && v != \"none\") {\n          for (var z = 0; z < u.symbolElements.length; z++) {\n            if (isNaN(u.pointsArray[z].index)) {\n              continue;\n            }\n\n            this._installHandlers(u.symbolElements[z], \"symbol\", f, g, u.pointsArray[z].index);\n          }\n        }\n      }\n    },\n    _adjustLineLabelPosition: function _adjustLineLabelPosition(i, g, d, h, f, e) {\n      var b = this._showLabel(i, g, d, {\n        width: 0,\n        height: 0\n      }, \"\", \"\", true);\n\n      if (!b) {\n        return;\n      }\n\n      var c = {\n        x: h.x - b.width / 2,\n        y: 0\n      };\n      c.y = h.y - 1.5 * b.height;\n      return c;\n    },\n    _calculateLine: function _calculateLine(h, v, p, o, n, f, e, z, c) {\n      var w = this.seriesGroups[h];\n      var m;\n\n      if (w.polar == true || w.spider == true) {\n        m = this._getPolarAxisCoords(h, this._plotRect);\n      }\n\n      var s = \"\";\n      var t = o.length;\n\n      if (!z && n.length == 0) {\n        var r = v * e;\n        t = r - p;\n      }\n\n      var j = NaN;\n\n      for (var u = 0; u < t + 1 && u < o.length; u++) {\n        if (u > 0) {\n          s += \" \";\n        }\n\n        var k = o[u].y;\n        var l = o[u].x;\n        var b = !z ? k : f;\n        var d = l;\n\n        if (n && n.length > u) {\n          b = n[u].y;\n          d = n[u].x;\n\n          if (isNaN(b) || isNaN(d)) {\n            b = k;\n            d = l;\n          }\n        }\n\n        j = d;\n\n        if (t <= o.length && u > 0 && u == t) {\n          d = o[u - 1].x;\n          b = o[u - 1].y;\n        }\n\n        if (c) {\n          l = a.jqx._ptrnd((l - b) * (z ? e : 1) + b);\n          k = a.jqx._ptrnd(k);\n        } else {\n          l = a.jqx._ptrnd((l - d) * e + d);\n          k = a.jqx._ptrnd((k - b) * e + b);\n        }\n\n        if (m) {\n          var q = this._toPolarCoord(m, this._plotRect, l, k);\n\n          l = q.x;\n          k = q.y;\n        }\n\n        s += l + \",\" + k;\n      }\n\n      return s;\n    },\n    _buildLineCmd: function _buildLineCmd(k, o, g, s, e, m, d, r, c, j, f, b) {\n      var p = k;\n      var l = b ? d + \",\" + g : g + \",\" + d;\n      var h = b ? d + \",\" + s : s + \",\" + d;\n\n      if (r && !c && !o) {\n        p = l + \" \" + k + \" \" + h;\n      }\n\n      if (f) {\n        p = this._getBezierPoints(p);\n      }\n\n      var n = p.split(\" \");\n\n      if (n.length == 0) {\n        return \"\";\n      }\n\n      if (n.length == 1) {\n        var q = n[0].split(\",\");\n        return \"M \" + n[0] + \" L\" + (parseFloat(q[0]) + 1) + \",\" + (parseFloat(q[1]) + 1);\n      }\n\n      var i = n[0].replace(\"M\", \"\");\n\n      if (r && !c) {\n        if (!o) {\n          p = \"M \" + l + \" L \" + i + \" \" + p;\n        } else {\n          p = \"M \" + i + \" L \" + i + (f ? \"\" : \" L \" + i + \" \") + p;\n        }\n      } else {\n        if (!f) {\n          p = \"M \" + i + \" L \" + i + \" \" + p;\n        }\n      }\n\n      if (c && j || o) {\n        p += \" Z\";\n      }\n\n      return p;\n    },\n    _getSerieSettings: function _getSerieSettings(i, c) {\n      var h = this.seriesGroups[i];\n      var g = h.type.indexOf(\"area\") != -1;\n      var f = h.type.indexOf(\"line\") != -1;\n      var d = h.series[c];\n      var k = d.dashStyle || h.dashStyle || \"\";\n      var e = d.opacity || h.opacity;\n\n      if (isNaN(e) || e < 0 || e > 1) {\n        e = 1;\n      }\n\n      var j = d.lineWidth;\n\n      if (isNaN(j) && j != \"auto\") {\n        j = h.lineWidth;\n      }\n\n      if (j == \"auto\" || isNaN(j) || j < 0 || j > 15) {\n        if (g) {\n          j = 2;\n        } else {\n          if (f) {\n            j = 3;\n          } else {\n            j = 1;\n          }\n        }\n      }\n\n      var b = d.lineWidthSymbol;\n\n      if (isNaN(b)) {\n        b = 1;\n      }\n\n      return {\n        stroke: j,\n        strokeSymbol: b,\n        opacity: e,\n        dashStyle: k\n      };\n    },\n    _getColors: function _getColors(u, p, d, e, b) {\n      var k = this.seriesGroups[u];\n      var o = k.series[p];\n\n      var c = this._get([o.useGradientColors, k.useGradientColors, k.useGradient, true]);\n\n      var l = this._getSeriesColors(u, p, d);\n\n      if (!l.fillColor) {\n        l.fillColor = r;\n        l.fillColorSelected = a.jqx.adjustColor(r, 1.1);\n        l.fillColorAlt = a.jqx.adjustColor(r, 4);\n        l.fillColorAltSelected = a.jqx.adjustColor(r, 3);\n        l.lineColor = l.symbolColor = a.jqx.adjustColor(r, 0.9);\n        l.lineColorSelected = l.symbolColorSelected = a.jqx.adjustColor(r, 0.9);\n      }\n\n      var h = [[0, 1.4], [100, 1]];\n      var f = [[0, 1], [25, 1.1], [50, 1.4], [100, 1]];\n      var n = [[0, 1.3], [90, 1.2], [100, 1]];\n      var j = NaN;\n\n      if (!isNaN(b)) {\n        j = b == 2 ? h : f;\n      }\n\n      if (c) {\n        var q = {};\n\n        for (var s in l) {\n          q[s] = l[s];\n        }\n\n        l = q;\n\n        if (e == \"verticalLinearGradient\" || e == \"horizontalLinearGradient\") {\n          var g = e == \"verticalLinearGradient\" ? j || h : j || f;\n          var m = [\"fillColor\", \"fillColorSelected\", \"fillColorAlt\", \"fillColorAltSelected\"];\n\n          for (var v in m) {\n            var r = l[m[v]];\n\n            if (r) {\n              l[m[v]] = this.renderer._toLinearGradient(r, e == \"verticalLinearGradient\", g);\n            }\n          }\n        } else {\n          if (e == \"radialGradient\") {\n            var t;\n            var j = h;\n\n            if ((k.type == \"pie\" || k.type == \"donut\" || k.polar) && d != undefined && this._renderData[u] && this._renderData[u].offsets[p]) {\n              t = this._renderData[u].offsets[p][d];\n              j = n;\n            }\n\n            l.fillColor = this.renderer._toRadialGradient(l.fillColor, j, t);\n            l.fillColorSelected = this.renderer._toRadialGradient(l.fillColorSelected, j, t);\n          }\n        }\n      }\n\n      return l;\n    },\n    _installHandlers: function _installHandlers(c, f, i, h, d) {\n      if (!this.enableEvents) {\n        return false;\n      }\n\n      var j = this;\n      var e = this.seriesGroups[i];\n      var k = this.seriesGroups[i].series[h];\n      var b = e.type.indexOf(\"line\") != -1 || e.type.indexOf(\"area\") != -1;\n\n      if (!b && !(e.enableSelection == false || k.enableSelection == false)) {\n        this.renderer.addHandler(c, \"mousemove\", function (m) {\n          var l = j._selected;\n\n          if (l && l.isLineType && l.linesUnselectMode == \"click\" && !(l.group == i && l.series == h)) {\n            return;\n          }\n\n          var g = m.pageX || m.clientX || m.screenX;\n          var o = m.pageY || m.clientY || m.screenY;\n          var n = j.host.offset();\n          g -= n.left;\n          o -= n.top;\n\n          if (j._mouseX == g && j._mouseY == o) {\n            return;\n          }\n\n          if (j._ttEl) {\n            if (j._ttEl.gidx == i && j._ttEl.sidx == h && j._ttEl.iidx == d) {\n              return;\n            }\n          }\n\n          j._startTooltipTimer(i, h, d);\n        });\n      }\n\n      if (!(e.enableSelection == false || k.enableSelection == false)) {\n        this.renderer.addHandler(c, \"mouseover\", function (l) {\n          var g = j._selected;\n\n          if (g && g.isLineType && g.linesUnselectMode == \"click\" && !(g.group == i && g.series == h)) {\n            return;\n          }\n\n          j._select(c, f, i, h, d, d);\n        });\n      }\n\n      this.renderer.addHandler(c, \"click\", function (g) {\n        clearTimeout(j._hostClickTimer);\n        j._lastClickTs = new Date().valueOf();\n\n        if (b && f != \"symbol\" && f != \"pointMarker\") {\n          return;\n        }\n\n        if (j._isColumnType(e.type)) {\n          j._unselect();\n        }\n\n        if (isNaN(d)) {\n          return;\n        }\n\n        g.stopImmediatePropagation();\n\n        j._raiseItemEvent(\"click\", e, k, d);\n      });\n    },\n    _getHorizontalOffset: function _getHorizontalOffset(A, s, k, j) {\n      var c = this._plotRect;\n\n      var h = this._getDataLen(A);\n\n      if (h == 0) {\n        return {\n          index: undefined,\n          value: k\n        };\n      }\n\n      var p = this._calcGroupOffsets(A, this._plotRect);\n\n      if (p.xoffsets.length == 0) {\n        return {\n          index: undefined,\n          value: undefined\n        };\n      }\n\n      var n = k;\n      var m = j;\n      var w = this.seriesGroups[A];\n      var l;\n\n      if (w.polar || w.spider) {\n        l = this._getPolarAxisCoords(A, c);\n      }\n\n      var e = this._getXAxis(A).flip == true;\n      var b, o, v, f;\n\n      for (var t = p.xoffsets.first; t <= p.xoffsets.last; t++) {\n        var u = p.xoffsets.data[t];\n        var d = p.offsets[s][t].to;\n        var q = 0;\n\n        if (l) {\n          var r = this._toPolarCoord(l, c, u + c.x, d);\n\n          u = r.x;\n          d = r.y;\n          q = a.jqx._ptdist(n, m, u, d);\n        } else {\n          if (w.orientation == \"horizontal\") {\n            u += c.y;\n            var z = d;\n            d = u;\n            u = z;\n            q = a.jqx._ptdist(n, m, u, d);\n          } else {\n            u += c.x;\n            q = Math.abs(n - u);\n          }\n        }\n\n        if (isNaN(b) || b > q) {\n          b = q;\n          o = t;\n          v = u;\n          f = d;\n        }\n      }\n\n      return {\n        index: o,\n        value: p.xoffsets.data[o],\n        polarAxisCoords: l,\n        x: v,\n        y: f\n      };\n    },\n    onmousemove: function onmousemove(k, j) {\n      if (this._mouseX == k && this._mouseY == j) {\n        return;\n      }\n\n      this._mouseX = k;\n      this._mouseY = j;\n\n      if (!this._selected) {\n        return;\n      }\n\n      var B = this._selected.group;\n      var q = this._selected.series;\n      var v = this.seriesGroups[B];\n      var n = v.series[q];\n      var b = this._plotRect;\n\n      if (this.renderer) {\n        b = this.renderer.getRect();\n        b.x += 5;\n        b.y += 5;\n        b.width -= 10;\n        b.height -= 10;\n      }\n\n      if (k < b.x || k > b.x + b.width || j < b.y || j > b.y + b.height) {\n        this._hideToolTip();\n\n        this._unselect();\n\n        return;\n      }\n\n      var e = v.orientation == \"horizontal\";\n      var b = this._plotRect;\n\n      if (v.type.indexOf(\"line\") != -1 || v.type.indexOf(\"area\") != -1) {\n        var f = this._getHorizontalOffset(B, this._selected.series, k, j);\n\n        var u = f.index;\n\n        if (u == undefined) {\n          return;\n        }\n\n        if (this._selected.item != u) {\n          var p = this._linesRenderInfo[B][q].segments;\n          var r = 0;\n\n          while (u > p[r].lastItemIndex) {\n            r++;\n\n            if (r >= p.length) {\n              return;\n            }\n          }\n\n          var c = p[r].pathElement;\n          var C = p[r].lastItemIndex;\n\n          this._unselect(false);\n\n          this._select(c, \"path\", B, q, u, C);\n        }\n\n        var m = this._getSymbol(this._selected.group, this._selected.series);\n\n        if (m == \"none\") {\n          m = \"circle\";\n        }\n\n        var o = this._calcGroupOffsets(B, b);\n\n        var d = o.offsets[this._selected.series][u].to;\n        var t = d;\n\n        if (v.type.indexOf(\"range\") != -1) {\n          t = o.offsets[this._selected.series][u].from;\n        }\n\n        var l = e ? k : j;\n\n        if (!isNaN(t) && Math.abs(l - t) < Math.abs(l - d)) {\n          j = t;\n        } else {\n          j = d;\n        }\n\n        if (isNaN(j)) {\n          return;\n        }\n\n        k = f.value;\n\n        if (e) {\n          var z = k;\n          k = j;\n          j = z + b.y;\n        } else {\n          k += b.x;\n        }\n\n        if (f.polarAxisCoords) {\n          k = f.x;\n          j = f.y;\n        }\n\n        j = a.jqx._ptrnd(j);\n        k = a.jqx._ptrnd(k);\n\n        if (this._pointMarker && this._pointMarker.element) {\n          this.renderer.removeElement(this._pointMarker.element);\n          this._pointMarker.element = undefined;\n        }\n\n        if (isNaN(k) || isNaN(j)) {\n          return;\n        }\n\n        var h = this._getSeriesColors(B, q, u);\n\n        var w = this._getSerieSettings(B, q);\n\n        var A = n.symbolSizeSelected;\n\n        if (isNaN(A)) {\n          A = n.symbolSize;\n        }\n\n        if (isNaN(A) || A > 50 || A < 0) {\n          A = v.symbolSize;\n        }\n\n        if (isNaN(A) || A > 50 || A < 0) {\n          A = 8;\n        }\n\n        if (this.showToolTips || this.enableCrosshairs) {\n          this._pointMarker = {\n            type: m,\n            x: k,\n            y: j,\n            gidx: B,\n            sidx: q,\n            iidx: u\n          };\n          this._pointMarker.element = this._drawSymbol(m, k, j, h.fillColorSymbolSelected, w.opacity, h.lineColorSymbolSelected, w.opacity, w.strokeSymbol, w.dashStyle, A);\n\n          this._installHandlers(this._pointMarker.element, \"pointMarker\", B, q, u);\n        }\n\n        this._startTooltipTimer(B, this._selected.series, u);\n      }\n    },\n    _drawSymbol: function _drawSymbol(i, l, j, c, m, k, f, g, b, o) {\n      var e;\n      var h = o || 6;\n      var d = h / 2;\n\n      switch (i) {\n        case \"none\":\n          return undefined;\n\n        case \"circle\":\n          e = this.renderer.circle(l, j, h / 2);\n          break;\n\n        case \"square\":\n          h = h - 1;\n          d = h / 2;\n          e = this.renderer.rect(l - d, j - d, h, h);\n          break;\n\n        case \"diamond\":\n          var n = \"M \" + (l - d) + \",\" + j + \" L\" + l + \",\" + (j - d) + \" L\" + (l + d) + \",\" + j + \" L\" + l + \",\" + (j + d) + \" Z\";\n          e = this.renderer.path(n);\n          break;\n\n        case \"triangle_up\":\n        case \"triangle\":\n          var n = \"M \" + (l - d) + \",\" + (j + d) + \" L \" + (l + d) + \",\" + (j + d) + \" L \" + l + \",\" + (j - d) + \" Z\";\n          e = this.renderer.path(n);\n          break;\n\n        case \"triangle_down\":\n          var n = \"M \" + (l - d) + \",\" + (j - d) + \" L \" + l + \",\" + (j + d) + \" L \" + (l + d) + \",\" + (j - d) + \" Z\";\n          e = this.renderer.path(n);\n          break;\n\n        case \"triangle_left\":\n          var n = \"M \" + (l - d) + \",\" + j + \" L \" + (l + d) + \",\" + (j + d) + \" L \" + (l + d) + \",\" + (j - d) + \" Z\";\n          e = this.renderer.path(n);\n          break;\n\n        case \"triangle_right\":\n          var n = \"M \" + (l - d) + \",\" + (j - d) + \" L \" + (l - d) + \",\" + (j + d) + \" L \" + (l + d) + \",\" + j + \" Z\";\n          e = this.renderer.path(n);\n          break;\n\n        default:\n          e = this.renderer.circle(l, j, h);\n      }\n\n      this.renderer.attr(e, {\n        fill: c,\n        \"fill-opacity\": m,\n        stroke: k,\n        \"stroke-width\": g,\n        \"stroke-opacity\": f,\n        \"stroke-dasharray\": b || \"\"\n      });\n\n      if (i != \"circle\") {\n        this.renderer.attr(e, {\n          r: h / 2\n        });\n\n        if (i != \"square\") {\n          this.renderer.attr(e, {\n            x: l,\n            y: j\n          });\n        }\n      }\n\n      return e;\n    },\n    _getSymbol: function _getSymbol(f, b) {\n      var c = [\"circle\", \"square\", \"diamond\", \"triangle_up\", \"triangle_down\", \"triangle_left\", \"triangle_right\"];\n      var e = this.seriesGroups[f];\n      var d = e.series[b];\n      var h;\n\n      if (d.symbolType != undefined) {\n        h = d.symbolType;\n      }\n\n      if (h == undefined) {\n        h = e.symbolType;\n      }\n\n      if (h == \"default\") {\n        return c[b % c.length];\n      } else {\n        if (h != undefined) {\n          return h;\n        }\n      }\n\n      return \"none\";\n    },\n    _startTooltipTimer: function _startTooltipTimer(k, j, d, i, h, b, f) {\n      this._cancelTooltipTimer();\n\n      var l = this;\n      var e = l.seriesGroups[k];\n      var c = this.toolTipShowDelay || this.toolTipDelay;\n\n      if (isNaN(c) || c > 10000 || c < 0) {\n        c = 500;\n      }\n\n      if (this._ttEl || true == this.enableCrosshairs && false == this.showToolTips) {\n        c = 0;\n      }\n\n      if (!isNaN(b)) {\n        c = b;\n      }\n\n      clearTimeout(this._tttimerHide);\n\n      if (isNaN(i)) {\n        i = l._mouseX;\n      }\n\n      if (isNaN(h)) {\n        h = l._mouseY - 3;\n      }\n\n      if (c == 0) {\n        l._showToolTip(i, h, k, j, d);\n      }\n\n      this._tttimer = setTimeout(function () {\n        if (c != 0) {\n          l._showToolTip(i, h, k, j, d);\n        }\n\n        var g = l.toolTipHideDelay;\n\n        if (!isNaN(f)) {\n          g = f;\n        }\n\n        if (isNaN(g)) {\n          g = 4000;\n        }\n\n        l._tttimerHide = setTimeout(function () {\n          l._hideToolTip();\n\n          l._unselect();\n        }, g);\n      }, c);\n    },\n    _cancelTooltipTimer: function _cancelTooltipTimer() {\n      clearTimeout(this._tttimer);\n    },\n    _getGroupGradientType: function _getGroupGradientType(c) {\n      var b = this.seriesGroups[c];\n\n      if (b.type.indexOf(\"area\") != -1) {\n        return b.orientation == \"horizontal\" ? \"horizontalLinearGradient\" : \"verticalLinearGradient\";\n      } else {\n        if (this._isColumnType(b.type) || b.type.indexOf(\"candle\") != -1) {\n          if (b.polar) {\n            return \"radialGradient\";\n          }\n\n          return b.orientation == \"horizontal\" ? \"verticalLinearGradient\" : \"horizontalLinearGradient\";\n        } else {\n          if (b.type.indexOf(\"scatter\") != -1 || b.type.indexOf(\"bubble\") != -1 || this._isPieGroup(c)) {\n            return \"radialGradient\";\n          }\n        }\n      }\n\n      return undefined;\n    },\n    _select: function _select(h, l, o, n, i, m) {\n      if (this._selected) {\n        if (this._selected.item != i || this._selected.series != n || this._selected.group != o) {\n          this._unselect();\n        } else {\n          return;\n        }\n      }\n\n      var k = this.seriesGroups[o];\n      var p = k.series[n];\n\n      if (k.enableSelection == false || p.enableSelection == false) {\n        return;\n      }\n\n      var f = k.type.indexOf(\"line\") != -1 && k.type.indexOf(\"area\") == -1;\n      this._selected = {\n        element: h,\n        type: l,\n        group: o,\n        series: n,\n        item: i,\n        iidxBase: m,\n        isLineType: f,\n        linesUnselectMode: p.linesUnselectMode || k.linesUnselectMode\n      };\n\n      var b = this._getColors(o, n, m || i, this._getGroupGradientType(o));\n\n      var c = b.fillColorSelected;\n\n      if (f) {\n        c = \"none\";\n      }\n\n      var e = this._getSerieSettings(o, n);\n\n      var d = l == \"symbol\" ? b.lineColorSymbolSelected : b.lineColorSelected;\n      c = l == \"symbol\" ? b.fillColorSymbolSelected : c;\n      var j = l == \"symbol\" ? 1 : e.stroke;\n\n      if (this.renderer.getAttr(h, \"fill\") == b.fillColorAlt) {\n        c = b.fillColorAltSelected;\n      }\n\n      this.renderer.attr(h, {\n        stroke: d,\n        fill: c,\n        \"stroke-width\": j\n      });\n\n      if (k.type.indexOf(\"pie\") != -1 || k.type.indexOf(\"donut\") != -1) {\n        this._applyPieSelect();\n      }\n\n      this._raiseItemEvent(\"mouseover\", k, p, i);\n    },\n    _applyPieSelect: function _applyPieSelect() {\n      var c = this;\n\n      c._createAnimationGroup(\"animPieSlice\");\n\n      var e = this._selected;\n\n      if (!e) {\n        return;\n      }\n\n      var f = this.getItemCoord(e.group, e.series, e.item);\n\n      if (!f) {\n        return;\n      }\n\n      var d = this._getRenderInfo(e.group, e.series, e.item);\n\n      var b = {\n        element: d,\n        coord: f\n      };\n\n      this._enqueueAnimation(\"animPieSlice\", undefined, undefined, 300, function (i, g, j) {\n        var l = g.coord;\n        var h = l.selectedRadiusChange * j;\n        var k = c.renderer.pieSlicePath(l.center.x, l.center.y, l.innerRadius == 0 ? 0 : l.innerRadius + h, l.outerRadius + h, l.fromAngle, l.toAngle, l.centerOffset);\n        c.renderer.attr(g.element.element, {\n          d: k\n        });\n\n        c._showPieLabel(e.group, e.series, e.item, undefined, h);\n      }, b);\n\n      c._startAnimation(\"animPieSlice\");\n    },\n    _applyPieUnselect: function _applyPieUnselect() {\n      this._stopAnimations();\n\n      var b = this._selected;\n\n      if (!b) {\n        return;\n      }\n\n      var d = this.getItemCoord(b.group, b.series, b.item);\n\n      if (!d || !d.center) {\n        return;\n      }\n\n      var c = this.renderer.pieSlicePath(d.center.x, d.center.y, d.innerRadius, d.outerRadius, d.fromAngle, d.toAngle, d.centerOffset);\n      this.renderer.attr(b.element, {\n        d: c\n      });\n\n      this._showPieLabel(b.group, b.series, b.item, undefined, 0);\n    },\n    _unselect: function _unselect() {\n      var o = this;\n\n      if (o._selected) {\n        var n = o._selected.group;\n        var m = o._selected.series;\n        var f = o._selected.item;\n        var k = o._selected.iidxBase;\n        var j = o._selected.type;\n        var i = o.seriesGroups[n];\n        var p = i.series[m];\n        var e = i.type.indexOf(\"line\") != -1 && i.type.indexOf(\"area\") == -1;\n\n        var b = o._getColors(n, m, k || f, o._getGroupGradientType(n));\n\n        var c = b.fillColor;\n\n        if (e) {\n          c = \"none\";\n        }\n\n        var d = o._getSerieSettings(n, m);\n\n        var l = j == \"symbol\" ? b.lineColorSymbol : b.lineColor;\n        c = j == \"symbol\" ? b.fillColorSymbol : c;\n\n        if (this.renderer.getAttr(o._selected.element, \"fill\") == b.fillColorAltSelected) {\n          c = b.fillColorAlt;\n        }\n\n        var h = j == \"symbol\" ? 1 : d.stroke;\n        o.renderer.attr(o._selected.element, {\n          stroke: l,\n          fill: c,\n          \"stroke-width\": h\n        });\n\n        if (i.type.indexOf(\"pie\") != -1 || i.type.indexOf(\"donut\") != -1) {\n          this._applyPieUnselect();\n        }\n\n        o._selected = undefined;\n\n        if (!isNaN(f)) {\n          o._raiseItemEvent(\"mouseout\", i, p, f);\n        }\n      }\n\n      if (o._pointMarker) {\n        if (o._pointMarker.element) {\n          o.renderer.removeElement(o._pointMarker.element);\n          o._pointMarker.element = undefined;\n        }\n\n        o._pointMarker = undefined;\n\n        o._hideCrosshairs();\n      }\n    },\n    _raiseItemEvent: function _raiseItemEvent(f, g, e, c) {\n      var d = e[f] || g[f];\n      var h = 0;\n\n      for (; h < this.seriesGroups.length; h++) {\n        if (this.seriesGroups[h] == g) {\n          break;\n        }\n      }\n\n      if (h == this.seriesGroups.length) {\n        return;\n      }\n\n      var b = {\n        event: f,\n        seriesGroup: g,\n        serie: e,\n        elementIndex: c,\n        elementValue: this._getDataValue(c, e.dataField, h)\n      };\n\n      if (d && a.isFunction(d)) {\n        d(b);\n      }\n\n      this._raiseEvent(f, b);\n    },\n    _raiseEvent: function _raiseEvent(d, c) {\n      var e = new a.Event(d);\n      e.owner = this;\n      c.event = d;\n      e.args = c;\n      var b = this.host.trigger(e);\n      return b;\n    },\n    _calcInterval: function _calcInterval(d, j, h) {\n      var m = Math.abs(j - d);\n      var k = m / h;\n      var f = [1, 2, 3, 4, 5, 10, 15, 20, 25, 50, 100];\n      var b = [0.5, 0.25, 0.125, 0.1];\n      var c = 0.1;\n      var g = f;\n\n      if (k < 1) {\n        g = b;\n        c = 10;\n      }\n\n      var l = 0;\n\n      do {\n        l = 0;\n\n        if (k >= 1) {\n          c *= 10;\n        } else {\n          c /= 10;\n        }\n\n        for (var e = 1; e < g.length; e++) {\n          if (Math.abs(g[l] * c - k) > Math.abs(g[e] * c - k)) {\n            l = e;\n          } else {\n            break;\n          }\n        }\n      } while (l == g.length - 1);\n\n      return g[l] * c;\n    },\n    _renderDataClone: function _renderDataClone() {\n      if (!this._renderData || this._isToggleRefresh) {\n        return;\n      }\n\n      var d = this._elementRenderInfo = [];\n\n      if (this._isSelectorRefresh) {\n        return;\n      }\n\n      for (var h = 0; h < this._renderData.length; h++) {\n        var c = this._getXAxis(h).dataField;\n\n        while (d.length <= h) {\n          d.push({});\n        }\n\n        var b = d[h];\n        var f = this._renderData[h];\n\n        if (!f.offsets) {\n          continue;\n        }\n\n        if (f.valueAxis) {\n          b.valueAxis = {\n            itemOffsets: {}\n          };\n\n          for (var j in f.valueAxis.itemOffsets) {\n            b.valueAxis.itemOffsets[j] = f.valueAxis.itemOffsets[j];\n          }\n        }\n\n        if (f.xAxis) {\n          b.xAxis = {\n            itemOffsets: {}\n          };\n\n          for (var j in f.xAxis.itemOffsets) {\n            b.xAxis.itemOffsets[j] = f.xAxis.itemOffsets[j];\n          }\n        }\n\n        b.series = [];\n        var g = b.series;\n\n        var l = this._isPieGroup(h);\n\n        for (var m = 0; m < f.offsets.length; m++) {\n          g.push({});\n\n          for (var e = 0; e < f.offsets[m].length; e++) {\n            if (!l) {\n              g[m][f.xoffsets.xvalues[e]] = {\n                value: f.offsets[m][e].value,\n                valueRadius: f.offsets[m][e].valueRadius,\n                xoffset: f.xoffsets.data[e],\n                from: f.offsets[m][e].from,\n                to: f.offsets[m][e].to\n              };\n            } else {\n              var k = f.offsets[m][e];\n              g[m][k.displayValue] = {\n                value: k.value,\n                x: k.x,\n                y: k.y,\n                fromAngle: k.fromAngle,\n                toAngle: k.toAngle\n              };\n            }\n          }\n        }\n      }\n    },\n    getPolarDataPointOffset: function getPolarDataPointOffset(d, c, f) {\n      var e = this._renderData[f];\n\n      if (!e) {\n        return {\n          x: NaN,\n          y: NaN\n        };\n      }\n\n      var h = this.getValueAxisDataPointOffset(c, f);\n      var b = this.getXAxisDataPointOffset(d, f);\n\n      var g = this._toPolarCoord(e.polarCoords, e.xAxis.rect, b, h);\n\n      return {\n        x: g.x,\n        y: g.y\n      };\n    },\n    _getDataPointOffsetDiff: function _getDataPointOffsetDiff(j, i, b, f, g, d, h) {\n      var e = this._getDataPointOffset(j, b, f, g, d, h);\n\n      var c = this._getDataPointOffset(i, b, f, g, d, h);\n\n      return Math.abs(e - c);\n    },\n    _getXAxisRenderData: function _getXAxisRenderData(d) {\n      if (d >= this._renderData.length) {\n        return;\n      }\n\n      var e = this.seriesGroups[d];\n      var c = this._renderData[d].xAxis;\n\n      if (!c) {\n        return;\n      }\n\n      if (e.xAxis == undefined) {\n        for (var b = 0; b <= d; b++) {\n          if (this.seriesGroups[b].xAxis == undefined) {\n            break;\n          }\n        }\n\n        c = this._renderData[b].xAxis;\n      }\n\n      return c;\n    },\n    getXAxisDataPointOffset: function getXAxisDataPointOffset(j, l) {\n      var k = this.seriesGroups[l];\n\n      if (isNaN(j)) {\n        return NaN;\n      }\n\n      var m = this._getXAxisRenderData(l);\n\n      if (!m) {\n        return NaN;\n      }\n\n      var f = m.data.axisStats;\n      var i = f.min.valueOf();\n      var b = f.max.valueOf();\n      var g = b - i;\n\n      if (g == 0) {\n        g = 1;\n      }\n\n      if (j.valueOf() > b || j.valueOf() < i) {\n        return NaN;\n      }\n\n      var c = this._getXAxis(l);\n\n      var d = k.orientation == \"horizontal\" ? \"height\" : \"width\";\n      var o = k.orientation == \"horizontal\" ? \"y\" : \"x\";\n      var h = (j.valueOf() - i) / g;\n      var n = m.rect[d] - m.data.padding.left - m.data.padding.right;\n\n      if (k.polar || k.spider) {\n        var e = this._renderData[l].polarCoords;\n\n        if (e.isClosedCircle) {\n          n = m.data.axisSize;\n        }\n      }\n\n      return this._plotRect[o] + m.data.padding.left + n * (c.flip ? 1 - h : h);\n    },\n    getValueAxisDataPointOffset: function getValueAxisDataPointOffset(g, h) {\n      var j = this._getValueAxis(h);\n\n      if (!j) {\n        return NaN;\n      }\n\n      var i = this._renderData[h];\n\n      if (!i) {\n        return NaN;\n      }\n\n      var f = j.flip == true;\n      var d = i.logBase;\n      var e = i.scale;\n      var b = i.gbase;\n      var c = i.baseOffset;\n      return this._getDataPointOffset(g, b, d, e, c, f);\n    },\n    _getDataPointOffset: function _getDataPointOffset(f, c, d, h, e, b) {\n      var g;\n\n      if (isNaN(f)) {\n        f = c;\n      }\n\n      if (!isNaN(d)) {\n        g = (a.jqx.log(f, d) - a.jqx.log(c, d)) * h;\n      } else {\n        g = (f - c) * h;\n      }\n\n      if (this._isVML) {\n        g = Math.round(g);\n      }\n\n      if (b) {\n        g = e + g;\n      } else {\n        g = e - g;\n      }\n\n      return g;\n    },\n    _calcGroupOffsets: function _calcGroupOffsets(l, K) {\n      var x = this.seriesGroups[l];\n\n      while (this._renderData.length < l + 1) {\n        this._renderData.push({});\n      }\n\n      if (this._renderData[l] != null && this._renderData[l].offsets != undefined) {\n        return this._renderData[l];\n      }\n\n      if (this._isPieGroup(l)) {\n        return this._calcPieSeriesGroupOffsets(l, K);\n      }\n\n      var o = this._getValueAxis(l);\n\n      if (!o || !x.series || x.series.length == 0) {\n        return this._renderData[l];\n      }\n\n      var z = o.flip == true;\n      var O = o.logarithmicScale == true;\n      var N = o.logarithmicScaleBase || 10;\n      var T = [];\n      var E = x.type.indexOf(\"stacked\") != -1;\n      var d = E && x.type.indexOf(\"100\") != -1;\n      var J = x.type.indexOf(\"range\") != -1;\n\n      var U = this._isColumnType(x.type);\n\n      var Z = x.type.indexOf(\"waterfall\") != -1;\n\n      var s = this._getDataLen(l);\n\n      var r = x.baselineValue || o.baselineValue || 0;\n\n      if (d) {\n        r = 0;\n      }\n\n      var ag = this._stats.seriesGroups[l];\n\n      if (!ag || !ag.isValid) {\n        return;\n      }\n\n      var aj = ag.hasStackValueReversal;\n\n      if (aj) {\n        r = 0;\n      }\n\n      if (Z && E) {\n        if (aj) {\n          return;\n        } else {\n          r = ag.base;\n        }\n      }\n\n      if (r > ag.max) {\n        r = ag.max;\n      }\n\n      if (r < ag.min) {\n        r = ag.min;\n      }\n\n      var q = d || O ? ag.maxRange : ag.max - ag.min;\n      var an = ag.min;\n      var B = ag.max;\n      var M = K.height / (O ? ag.intervals : q);\n      var ai = 0;\n\n      if (d) {\n        if (an * B < 0) {\n          q /= 2;\n          ai = -(q + r) * M;\n        } else {\n          ai = -r * M;\n        }\n      } else {\n        ai = -(r - an) * M;\n      }\n\n      if (z) {\n        ai = K.y - ai;\n      } else {\n        ai += K.y + K.height;\n      }\n\n      var ah = [];\n      var ad = [];\n      var S = [];\n      var al, G;\n\n      if (O) {\n        al = a.jqx.log(B, N) - a.jqx.log(r, N);\n\n        if (E) {\n          al = ag.intervals;\n          r = d ? 0 : an;\n        }\n\n        G = ag.intervals - al;\n\n        if (!z) {\n          ai = K.y + al / ag.intervals * K.height;\n        }\n      }\n\n      ai = a.jqx._ptrnd(ai);\n      var c = an * B < 0 ? K.height / 2 : K.height;\n      var m = [];\n      var W = [];\n      var ao = E && (U || O);\n      var am = [];\n      T = new Array(x.series.length);\n\n      for (var ab = 0; ab < x.series.length; ab++) {\n        T[ab] = new Array(s);\n      }\n\n      for (var ac = 0; ac < s; ac++) {\n        if (!Z && E) {\n          W = [];\n        }\n\n        for (var ab = 0; ab < x.series.length; ab++) {\n          if (!E && O) {\n            m = [];\n          }\n\n          var C = x.series[ab];\n          var D = C.dataField;\n          var aq = C.dataFieldFrom;\n          var P = C.dataFieldTo;\n          var Y = C.radiusDataField || C.sizeDataField;\n          T[ab][ac] = {};\n\n          var g = this._isSerieVisible(l, ab);\n\n          if (x.type.indexOf(\"candle\") != -1 || x.type.indexOf(\"ohlc\") != -1) {\n            var b = [\"Open\", \"Close\", \"High\", \"Low\"];\n\n            for (var ak in b) {\n              var p = \"dataField\" + b[ak];\n\n              if (C[p]) {\n                T[ab][ac][b[ak]] = this._getDataPointOffset(this._getDataValueAsNumber(ac, C[p], l), r, O ? N : NaN, M, ai, z);\n              }\n            }\n\n            continue;\n          }\n\n          if (E) {\n            while (W.length <= ac) {\n              W.push(0);\n            }\n          }\n\n          var ap = NaN;\n\n          if (J) {\n            ap = this._getDataValueAsNumber(ac, aq, l);\n\n            if (isNaN(ap)) {\n              ap = r;\n            }\n          }\n\n          var I = NaN;\n\n          if (J) {\n            I = this._getDataValueAsNumber(ac, P, l);\n          } else {\n            I = this._getDataValueAsNumber(ac, D, l);\n          }\n\n          var e = this._getDataValueAsNumber(ac, Y, l);\n\n          if (E) {\n            W[ac] += g ? I : 0;\n          }\n\n          if (!g) {\n            I = NaN;\n          }\n\n          if (isNaN(I) || O && I <= 0) {\n            T[ab][ac] = {\n              from: undefined,\n              to: undefined\n            };\n            continue;\n          }\n\n          var H;\n\n          if (E) {\n            if (ao) {\n              H = I >= r ? ah : ad;\n            } else {\n              I = W[ac];\n            }\n          }\n\n          var af = M * (I - r);\n\n          if (J) {\n            af = M * (I - ap);\n          }\n\n          if (E && ao) {\n            if (!am[ac]) {\n              am[ac] = true;\n              af = M * (I - r);\n            } else {\n              af = M * I;\n            }\n          }\n\n          if (O) {\n            while (m.length <= ac) {\n              m.push({\n                p: {\n                  value: 0,\n                  height: 0\n                },\n                n: {\n                  value: 0,\n                  height: 0\n                }\n              });\n            }\n\n            var A = J || J ? ap : r;\n            var aa = I > A ? m[ac].p : m[ac].n;\n            aa.value += I;\n\n            if (d) {\n              I = aa.value / (ag.psums[ac] + ag.nsums[ac]) * 100;\n              af = (a.jqx.log(I, N) - ag.minPow) * M;\n            } else {\n              af = a.jqx.log(aa.value, N) - a.jqx.log(A, N);\n              af *= M;\n            }\n\n            af -= aa.height;\n            aa.height += af;\n          }\n\n          var R = ai;\n\n          if (J) {\n            var t = 0;\n\n            if (O) {\n              t = (a.jqx.log(ap, N) - a.jqx.log(r, N)) * M;\n            } else {\n              t = (ap - r) * M;\n            }\n\n            R += z ? t : -t;\n          }\n\n          if (E) {\n            if (d && !O) {\n              var w = ag.psums[ac] - ag.nsums[ac];\n\n              if (I > r) {\n                af = ag.psums[ac] / w * c;\n\n                if (ag.psums[ac] != 0) {\n                  af *= I / ag.psums[ac];\n                }\n              } else {\n                af = ag.nsums[ac] / w * c;\n\n                if (ag.nsums[ac] != 0) {\n                  af *= I / ag.nsums[ac];\n                }\n              }\n            }\n\n            if (ao) {\n              if (isNaN(H[ac])) {\n                H[ac] = R;\n              }\n\n              R = H[ac];\n            }\n          }\n\n          if (isNaN(S[ac])) {\n            S[ac] = 0;\n          }\n\n          var ae = S[ac];\n          af = Math.abs(af);\n          var V = af;\n\n          if (af >= 1) {\n            var L = this._isVML ? Math.round(af) : a.jqx._ptrnd(af) - 1;\n\n            if (Math.abs(af - L) > 0.5) {\n              af = Math.round(af);\n            } else {\n              af = L;\n            }\n          }\n\n          ae += af - V;\n\n          if (!E) {\n            ae = 0;\n          }\n\n          if (Math.abs(ae) > 0.5) {\n            if (ae > 0) {\n              af -= 1;\n              ae -= 1;\n            } else {\n              af += 1;\n              ae += 1;\n            }\n          }\n\n          S[ac] = ae;\n\n          if (ab == x.series.length - 1 && d) {\n            var v = 0;\n\n            for (var X = 0; X < ab; X++) {\n              v += Math.abs(T[X][ac].to - T[X][ac].from);\n            }\n\n            v += af;\n\n            if (v < c) {\n              if (af > 0.5) {\n                af = a.jqx._ptrnd(af + c - v);\n              } else {\n                var X = ab - 1;\n\n                while (X >= 0) {\n                  var F = Math.abs(T[X][ac].to - T[X][ac].from);\n\n                  if (F > 1) {\n                    if (T[X][ac].from > T[X][ac].to) {\n                      T[X][ac].from += c - v;\n                    }\n\n                    break;\n                  }\n\n                  X--;\n                }\n              }\n            }\n          }\n\n          if (z) {\n            af *= -1;\n          }\n\n          var Q = I < r;\n\n          if (J) {\n            Q = ap > I;\n          }\n\n          var n = isNaN(ap) ? I : {\n            from: ap,\n            to: I\n          };\n\n          if (Q) {\n            if (ao) {\n              H[ac] += af;\n            }\n\n            T[ab][ac] = {\n              from: R,\n              to: R + af,\n              value: n,\n              valueRadius: e\n            };\n          } else {\n            if (ao) {\n              H[ac] -= af;\n            }\n\n            T[ab][ac] = {\n              from: R,\n              to: R - af,\n              value: n,\n              valueRadius: e\n            };\n          }\n        }\n      }\n\n      var u = this._renderData[l];\n      u.baseOffset = ai;\n      u.gbase = r;\n      u.logBase = O ? N : NaN;\n      u.scale = M;\n      u.offsets = !Z ? T : this._applyWaterfall(T, s, l, ai, r, O ? N : NaN, M, z, E);\n      u.xoffsets = this._calculateXOffsets(l, K.width);\n      return this._renderData[l];\n    },\n    _isPercent: function _isPercent(b) {\n      return typeof b === \"string\" && b.length > 0 && b.indexOf(\"%\") == b.length - 1;\n    },\n    _calcPieSeriesGroupOffsets: function _calcPieSeriesGroupOffsets(e, b) {\n      var z = this;\n\n      var m = this._getDataLen(e);\n\n      var n = this.seriesGroups[e];\n      var A = this._renderData[e] = {};\n      var G = A.offsets = [];\n\n      for (var C = 0; C < n.series.length; C++) {\n        var t = n.series[C];\n\n        var E = this._get([t.minAngle, t.startAngle]);\n\n        if (isNaN(E) || E < 0 || E > 360) {\n          E = 0;\n        }\n\n        var M = this._get([t.maxAngle, t.endAngle]);\n\n        if (isNaN(M) || M < 0 || M > 360) {\n          M = 360;\n        }\n\n        var f = M - E;\n        var o = t.initialAngle || 0;\n\n        if (o < E) {\n          o = E;\n        }\n\n        if (o > M) {\n          o = M;\n        }\n\n        var c = t.centerOffset || 0;\n        var K = a.jqx.getNum([t.offsetX, n.offsetX, b.width / 2]);\n        var J = a.jqx.getNum([t.offsetY, n.offsetY, b.height / 2]);\n        var w = Math.min(b.width, b.height) / 2;\n        var v = o;\n        var g = t.radius;\n\n        if (z._isPercent(g)) {\n          g = parseFloat(g) / 100 * w;\n        }\n\n        if (isNaN(g)) {\n          g = w * 0.4;\n        }\n\n        var l = t.innerRadius;\n\n        if (z._isPercent(l)) {\n          l = parseFloat(l) / 100 * w;\n        }\n\n        if (isNaN(l) || l >= g) {\n          l = 0;\n        }\n\n        var d = t.selectedRadiusChange;\n\n        if (z._isPercent(d)) {\n          d = parseFloat(d) / 100 * (g - l);\n        }\n\n        if (isNaN(d)) {\n          d = 0.1 * (g - l);\n        }\n\n        G.push([]);\n        var h = 0;\n        var j = 0;\n\n        for (var F = 0; F < m; F++) {\n          var L = this._getDataValueAsNumber(F, t.dataField, e);\n\n          if (isNaN(L)) {\n            continue;\n          }\n\n          if (!this._isSerieVisible(e, C, F) && t.hiddenPointsDisplay != true) {\n            continue;\n          }\n\n          if (L > 0) {\n            h += L;\n          } else {\n            j += L;\n          }\n        }\n\n        var r = h - j;\n\n        if (r == 0) {\n          r = 1;\n        }\n\n        for (var F = 0; F < m; F++) {\n          var L = this._getDataValueAsNumber(F, t.dataField, e);\n\n          if (isNaN(L)) {\n            G[C].push({});\n            continue;\n          }\n\n          var D = t.displayText || t.displayField;\n\n          var k = this._getDataValue(F, D, e);\n\n          if (k == undefined) {\n            k = F;\n          }\n\n          var I = 0;\n\n          var B = this._isSerieVisible(e, C, F);\n\n          if (B || t.hiddenPointsDisplay == true) {\n            I = Math.abs(L) / r * f;\n          }\n\n          var q = b.x + K;\n          var p = b.y + J;\n          var H = c;\n\n          if (a.isFunction(c)) {\n            H = c({\n              seriesIndex: C,\n              seriesGroupIndex: e,\n              itemIndex: F\n            });\n          }\n\n          if (isNaN(H)) {\n            H = 0;\n          }\n\n          var u = {\n            key: e + \"_\" + C + \"_\" + F,\n            value: L,\n            displayValue: k,\n            x: q,\n            y: p,\n            fromAngle: v,\n            toAngle: v + I,\n            centerOffset: H,\n            innerRadius: l,\n            outerRadius: g,\n            selectedRadiusChange: d,\n            visible: B\n          };\n          G[C].push(u);\n          v += I;\n        }\n      }\n\n      return A;\n    },\n    _isPointSeriesOnly: function _isPointSeriesOnly() {\n      for (var b = 0; b < this.seriesGroups.length; b++) {\n        var c = this.seriesGroups[b];\n\n        if (c.type.indexOf(\"line\") == -1 && c.type.indexOf(\"area\") == -1 && c.type.indexOf(\"scatter\") == -1 && c.type.indexOf(\"bubble\") == -1) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    _hasColumnSeries: function _hasColumnSeries() {\n      var d = [\"column\", \"ohlc\", \"candlestick\", \"waterfall\"];\n\n      for (var c = 0; c < this.seriesGroups.length; c++) {\n        var e = this.seriesGroups[c];\n\n        for (var b in d) {\n          if (e.type.indexOf(d[b]) != -1) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    _alignValuesWithTicks: function _alignValuesWithTicks(f) {\n      var b = this._isPointSeriesOnly();\n\n      var c = this.seriesGroups[f];\n\n      var e = this._getXAxis(f);\n\n      var d = e.valuesOnTicks == undefined ? b : e.valuesOnTicks != false;\n\n      if (e.logarithmicScale) {\n        d = true;\n      }\n\n      if (f == undefined) {\n        return d;\n      }\n\n      if (c.valuesOnTicks == undefined) {\n        return d;\n      }\n\n      return c.valuesOnTicks;\n    },\n    _getYearsDiff: function _getYearsDiff(c, b) {\n      return b.getFullYear() - c.getFullYear();\n    },\n    _getMonthsDiff: function _getMonthsDiff(c, b) {\n      return 12 * (b.getFullYear() - c.getFullYear()) + b.getMonth() - c.getMonth();\n    },\n    _getDateDiff: function _getDateDiff(f, e, d, b) {\n      var c = 0;\n\n      if (d != \"year\" && d != \"month\") {\n        c = e.valueOf() - f.valueOf();\n      }\n\n      switch (d) {\n        case \"year\":\n          c = this._getYearsDiff(f, e);\n          break;\n\n        case \"month\":\n          c = this._getMonthsDiff(f, e);\n          break;\n\n        case \"day\":\n          c /= 24 * 3600 * 1000;\n          break;\n\n        case \"hour\":\n          c /= 3600 * 1000;\n          break;\n\n        case \"minute\":\n          c /= 60 * 1000;\n          break;\n\n        case \"second\":\n          c /= 1000;\n          break;\n\n        case \"millisecond\":\n          break;\n      }\n\n      if (d != \"year\" && d != \"month\" && b != false) {\n        c = a.jqx._rnd(c, 1, true);\n      }\n\n      return c;\n    },\n    _getBestDTUnit: function _getBestDTUnit(k, p, q, d, g) {\n      var f = \"day\";\n      var m = p.valueOf() - k.valueOf();\n\n      if (m < 1000) {\n        f = \"second\";\n      } else {\n        if (m < 3600000) {\n          f = \"minute\";\n        } else {\n          if (m < 86400000) {\n            f = \"hour\";\n          } else {\n            if (m < 2592000000) {\n              f = \"day\";\n            } else {\n              if (m < 31104000000) {\n                f = \"month\";\n              } else {\n                f = \"year\";\n              }\n            }\n          }\n        }\n      }\n\n      var o = [{\n        key: \"year\",\n        cnt: m / (1000 * 60 * 60 * 24 * 365)\n      }, {\n        key: \"month\",\n        cnt: m / (1000 * 60 * 60 * 24 * 30)\n      }, {\n        key: \"day\",\n        cnt: m / (1000 * 60 * 60 * 24)\n      }, {\n        key: \"hour\",\n        cnt: m / (1000 * 60 * 60)\n      }, {\n        key: \"minute\",\n        cnt: m / (1000 * 60)\n      }, {\n        key: \"second\",\n        cnt: m / 1000\n      }, {\n        key: \"millisecond\",\n        cnt: m\n      }];\n      var l = -1;\n\n      for (var h = 0; h < o.length; h++) {\n        if (o[h].key == f) {\n          l = h;\n          break;\n        }\n      }\n\n      var b = -1,\n          n = -1;\n\n      for (; l < o.length; l++) {\n        if (o[l].cnt / 100 > d) {\n          break;\n        }\n\n        var c = this._estAxisInterval(k, p, q, d, o[l].key, g);\n\n        var e = this._getDTIntCnt(k, p, c, o[l].key);\n\n        if (b == -1 || b < e) {\n          b = e;\n          n = l;\n        }\n      }\n\n      f = o[n].key;\n      return f;\n    },\n    _getXAxisStats: function _getXAxisStats(h, o, F) {\n      var m = this._getDataLen(h);\n\n      var c = o.type == \"date\" || o.type == \"time\";\n\n      if (c && !this._autoDateFormats) {\n        if (!this._autoDateFormats) {\n          this._autoDateFormats = [];\n        }\n\n        var q = this._testXAxisDateFormat();\n\n        if (q) {\n          this._autoDateFormats.push(q);\n        }\n      }\n\n      var p = c ? this._castAsDate(o.minValue, o.dateFormat) : this._castAsNumber(o.minValue);\n      var s = c ? this._castAsDate(o.maxValue, o.dateFormat) : this._castAsNumber(o.maxValue);\n\n      if (this._selectorRange && this._selectorRange[h]) {\n        var j = this._selectorRange[h].min;\n\n        if (!isNaN(j)) {\n          p = c ? this._castAsDate(j, o.dateFormat) : this._castAsNumber(j);\n        }\n\n        var k = this._selectorRange[h].max;\n\n        if (!isNaN(k)) {\n          s = c ? this._castAsDate(k, o.dateFormat) : this._castAsNumber(k);\n        }\n      }\n\n      var A = p,\n          E = s;\n      var f, r;\n      var d = o.type == undefined || o.type == \"auto\";\n      var l = d || o.type == \"basic\";\n      var B = 0,\n          e = 0;\n\n      for (var D = 0; D < m && o.dataField; D++) {\n        var z = this._getDataValue(D, o.dataField, h);\n\n        z = c ? this._castAsDate(z, o.dateFormat) : this._castAsNumber(z);\n\n        if (isNaN(z)) {\n          continue;\n        }\n\n        if (c) {\n          B++;\n        } else {\n          e++;\n        }\n\n        if (isNaN(f) || z < f) {\n          f = z;\n        }\n\n        if (isNaN(r) || z >= r) {\n          r = z;\n        }\n      }\n\n      if (d && (!c && e == m || c && B == m)) {\n        l = false;\n      }\n\n      if (l) {\n        f = 0;\n        r = Math.max(0, m - 1);\n      }\n\n      if (isNaN(A)) {\n        A = f;\n      }\n\n      if (isNaN(E)) {\n        E = r;\n      }\n\n      if (c) {\n        if (!this._isDate(A)) {\n          A = this._isDate(E) ? E : new Date();\n        }\n\n        if (!this._isDate(E)) {\n          E = this._isDate(A) ? A : new Date();\n        }\n      } else {\n        if (isNaN(A)) {\n          A = 0;\n        }\n\n        if (isNaN(E)) {\n          E = l ? Math.max(0, m - 1) : A;\n        }\n      }\n\n      if (f == undefined) {\n        f = A;\n      }\n\n      if (r == undefined) {\n        r = E;\n      }\n\n      var t = o.rangeSelector;\n\n      if (t) {\n        var u = t.minValue || A;\n\n        if (u && c) {\n          u = this._castAsDate(u, t.dateFormat || o.dateFormat);\n        }\n\n        var y = t.maxValue || E;\n\n        if (y && c) {\n          y = this._castAsDate(y, t.dateFormat || o.rangeSelector);\n        }\n\n        if (A < u) {\n          A = u;\n        }\n\n        if (E < u) {\n          E = y;\n        }\n\n        if (A > y) {\n          A = u;\n        }\n\n        if (E > y) {\n          E = y;\n        }\n      }\n\n      var G = o.unitInterval;\n      var x, H;\n\n      if (c) {\n        x = o.baseUnit;\n\n        if (!x) {\n          x = this._getBestDTUnit(A, E, h, F);\n        }\n\n        H = x == \"hour\" || x == \"minute\" || x == \"second\" || x == \"millisecond\";\n      }\n\n      var v = o.logarithmicScale == true;\n      var g = o.logarithmicScaleBase;\n\n      if (isNaN(g) || g <= 1) {\n        g = 10;\n      }\n\n      var G = o.unitInterval;\n\n      if (v) {\n        G = 1;\n      } else {\n        if (isNaN(G) || G <= 0) {\n          G = this._estAxisInterval(A, E, h, F, x);\n        }\n      }\n\n      var C = {\n        min: A,\n        max: E\n      };\n      var n = this.seriesGroups[h];\n\n      if (v) {\n        if (!A) {\n          A = 1;\n\n          if (E && A > E) {\n            A = E;\n          }\n        }\n\n        if (!E) {\n          E = A;\n        }\n\n        C = {\n          min: A,\n          max: E\n        };\n\n        var b = a.jqx._rnd(a.jqx.log(A, g), 1, false);\n\n        var w = a.jqx._rnd(a.jqx.log(E, g), 1, true);\n\n        E = Math.pow(g, w);\n        A = Math.pow(g, b);\n      } else {\n        if (!c && (n.polar || n.spider)) {\n          A = a.jqx._rnd(A, G, false);\n          E = a.jqx._rnd(E, G, true);\n        }\n      }\n\n      return {\n        min: A,\n        max: E,\n        logAxis: {\n          enabled: v,\n          base: g,\n          minPow: b,\n          maxPow: w\n        },\n        dsRange: {\n          min: f,\n          max: r\n        },\n        filterRange: C,\n        useIndeces: l,\n        isDateTime: c,\n        isTimeUnit: H,\n        dateTimeUnit: x,\n        interval: G\n      };\n    },\n    _getDefaultDTFormatFn: function _getDefaultDTFormatFn(d) {\n      var b = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n      var c;\n\n      if (d == \"year\" || d == \"month\" || d == \"day\") {\n        c = function c(e) {\n          return e.getDate() + \"-\" + b[e.getMonth()] + \"-\" + e.getFullYear();\n        };\n      } else {\n        c = function c(e) {\n          return e.getDate() + \"-\" + b[e.getMonth()] + \"-\" + e.getFullYear() + \"<br>\" + e.getHours() + \":\" + e.getMinutes() + \":\" + e.getSeconds();\n        };\n      }\n\n      return c;\n    },\n    _getDTIntCnt: function _getDTIntCnt(e, b, c, h) {\n      var d = 0;\n      var f = new Date(e);\n      var g = new Date(b);\n      g = g.valueOf();\n\n      if (c <= 0) {\n        return 1;\n      }\n\n      while (f.valueOf() < g) {\n        if (h == \"millisecond\") {\n          f = new Date(f.valueOf() + c);\n        } else {\n          if (h == \"second\") {\n            f = new Date(f.valueOf() + c * 1000);\n          } else {\n            if (h == \"minute\") {\n              f = new Date(f.valueOf() + c * 60000);\n            } else {\n              if (h == \"hour\") {\n                f = new Date(f.valueOf() + c * 60000 * 24);\n              } else {\n                if (h == \"day\") {\n                  f.setDate(f.getDate() + c);\n                } else {\n                  if (h == \"month\") {\n                    f.setMonth(f.getMonth() + c);\n                  } else {\n                    if (h == \"year\") {\n                      f.setFullYear(f.getFullYear() + c);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        d++;\n      }\n\n      return d;\n    },\n    _estAxisInterval: function _estAxisInterval(e, h, m, b, j, c) {\n      if (isNaN(e) || isNaN(h)) {\n        return NaN;\n      }\n\n      var d = [1, 2, 5, 10, 15, 20, 50, 100, 200, 500];\n      var g = 0;\n      var f = b / (!isNaN(c) && c > 0 ? c : 50);\n\n      if (this._renderData && this._renderData.length > m && this._renderData[m].xAxis && !isNaN(this._renderData[m].xAxis.avgWidth)) {\n        var o = Math.max(1, this._renderData[m].xAxis.avgWidth);\n\n        if (o != 0 && isNaN(c)) {\n          f = 0.9 * b / o;\n        }\n      }\n\n      if (f <= 1) {\n        return Math.abs(h - e);\n      }\n\n      var n = 0;\n\n      while (true) {\n        var l = g >= d.length ? Math.pow(10, 3 + g - d.length) : d[g];\n\n        if (this._isDate(e) && this._isDate(h)) {\n          n = this._getDTIntCnt(e, h, l, j);\n        } else {\n          n = (h - e) / l;\n        }\n\n        if (n <= f) {\n          break;\n        }\n\n        g++;\n      }\n\n      var k = this.seriesGroups[m];\n\n      if (k.spider || k.polar) {\n        if (2 * l > h - e) {\n          l = h - e;\n        }\n      }\n\n      return l;\n    },\n    _getPaddingSize: function _getPaddingSize(m, e, f, c, o, g, p) {\n      var h = m.min;\n      var k = m.max;\n\n      if (m.logAxis.enabled) {\n        h = m.logAxis.minPow;\n        k = m.logAxis.maxPow;\n      }\n\n      var b = m.interval;\n      var d = m.dateTimeUnit;\n\n      if (o) {\n        var l = c / Math.max(1, k - h + b) * b;\n\n        if (g) {\n          return {\n            left: 0,\n            right: l\n          };\n        } else {\n          if (f) {\n            return {\n              left: 0,\n              right: 0\n            };\n          }\n\n          return {\n            left: l / 2,\n            right: l / 2\n          };\n        }\n      }\n\n      if (f && !p) {\n        return {\n          left: 0,\n          right: 0\n        };\n      }\n\n      if (this._isDate(h) && this._isDate(k)) {\n        var n = this._getDTIntCnt(h, k, Math.min(b, k - h), d);\n\n        var i = c / Math.max(2, n);\n        return {\n          left: i / 2,\n          right: i / 2\n        };\n      }\n\n      var n = Math.max(1, k - h);\n\n      if (n == 1) {\n        var j = c / 4;\n        return {\n          left: j,\n          right: j\n        };\n      }\n\n      var i = c / (n + 1);\n      return {\n        left: i / 2,\n        right: i / 2\n      };\n    },\n    _calculateXOffsets: function _calculateXOffsets(f, E) {\n      var D = this.seriesGroups[f];\n\n      var o = this._getXAxis(f);\n\n      var w = [];\n      var m = [];\n\n      var n = this._getDataLen(f);\n\n      var d = this._getXAxisStats(f, o, E);\n\n      var v = d.min;\n      var B = d.max;\n      var b = d.isDateTime;\n      var G = d.isTimeUnit;\n\n      var C = this._hasColumnSeries();\n\n      var c = D.polar || D.spider;\n\n      var y = this._get([D.startAngle, D.minAngle, 0]);\n\n      var t = this._get([D.endAngle, D.maxAngle, 360]);\n\n      var q = c && !(Math.abs(Math.abs(t - y) - 360) > 0.0001);\n\n      var l = this._alignValuesWithTicks(f);\n\n      var s = this._getPaddingSize(d, o, l, E, c, q, C);\n\n      var I = B - v;\n      var A = d.filterRange;\n\n      if (I == 0) {\n        I = 1;\n      }\n\n      var H = E - s.left - s.right;\n\n      if (c && l && !q) {\n        s.left = s.right = 0;\n      }\n\n      var j = -1,\n          p = -1;\n\n      for (var z = 0; z < n; z++) {\n        var u = o.dataField === undefined ? z : this._getDataValue(z, o.dataField, f);\n\n        if (d.useIndeces) {\n          if (z < A.min || z > A.max) {\n            w.push(NaN);\n            m.push(undefined);\n            continue;\n          }\n\n          r = s.left + (z - v) / I * H;\n\n          if (d.logAxis.enabled == true) {\n            var e = d.logAxis.base;\n            r = this._jqxPlot.scale(u, {\n              min: v.valueOf(),\n              max: B.valueOf(),\n              type: \"logarithmic\",\n              base: e\n            }, {\n              min: 0,\n              max: H,\n              flip: false\n            });\n          }\n\n          w.push(a.jqx._ptrnd(r));\n          m.push(u);\n\n          if (j == -1) {\n            j = z;\n          }\n\n          if (p == -1 || p < z) {\n            p = z;\n          }\n\n          continue;\n        }\n\n        u = b ? this._castAsDate(u, o.dateFormat) : this._castAsNumber(u);\n\n        if (isNaN(u) || u < A.min || u > A.max) {\n          w.push(NaN);\n          m.push(undefined);\n          continue;\n        }\n\n        var r = 0;\n\n        if (d.logAxis.enabled == true) {\n          var e = d.logAxis.base;\n          r = this._jqxPlot.scale(u, {\n            min: v.valueOf(),\n            max: B.valueOf(),\n            type: \"logarithmic\",\n            base: e\n          }, {\n            min: 0,\n            max: H,\n            flip: false\n          });\n        } else {\n          if (!b || b && G) {\n            var F = u - v;\n            r = (u - v) * H / I;\n          } else {\n            r = (u.valueOf() - v.valueOf()) / (B.valueOf() - v.valueOf()) * H;\n          }\n        }\n\n        r = a.jqx._ptrnd(s.left + r);\n        w.push(r);\n        m.push(u);\n\n        if (j == -1) {\n          j = z;\n        }\n\n        if (p == -1 || p < z) {\n          p = z;\n        }\n      }\n\n      if (o.flip == true) {\n        for (var z = 0; z < w.length; z++) {\n          if (!isNaN(w[z])) {\n            w[z] = E - w[z];\n          }\n        }\n      }\n\n      if (G || b) {\n        I = this._getDateDiff(v, B, o.baseUnit);\n        I = a.jqx._rnd(I, 1, false);\n      }\n\n      var k = Math.max(1, I);\n      var h = H / k;\n\n      if (j == p && k == 1) {\n        w[j] = s.left + H / 2;\n      }\n\n      return {\n        axisStats: d,\n        data: w,\n        xvalues: m,\n        first: j,\n        last: p,\n        length: p == -1 ? 0 : p - j + 1,\n        itemWidth: h,\n        intervalWidth: h * d.interval,\n        rangeLength: I,\n        useIndeces: d.useIndeces,\n        padding: s,\n        axisSize: H\n      };\n    },\n    _getXAxis: function _getXAxis(b) {\n      if (b == undefined || this.seriesGroups.length <= b) {\n        return this.categoryAxis || this.xAxis;\n      }\n\n      return this.seriesGroups[b].categoryAxis || this.seriesGroups[b].xAxis || this.categoryAxis || this.xAxis;\n    },\n    _isGreyScale: function _isGreyScale(e, b) {\n      var d = this.seriesGroups[e];\n      var c = d.series[b];\n\n      if (c.greyScale == true) {\n        return true;\n      } else {\n        if (c.greyScale == false) {\n          return false;\n        }\n      }\n\n      if (d.greyScale == true) {\n        return true;\n      } else {\n        if (d.greyScale == false) {\n          return false;\n        }\n      }\n\n      return this.greyScale == true;\n    },\n    _getSeriesColors: function _getSeriesColors(f, c, e) {\n      var b = this._getSeriesColorsInternal(f, c, e);\n\n      if (this._isGreyScale(f, c)) {\n        for (var d in b) {\n          b[d] = a.jqx.toGreyScale(b[d]);\n        }\n      }\n\n      return b;\n    },\n    _getColorFromScheme: function _getColorFromScheme(o, l, b) {\n      var d = \"#000000\";\n      var n = this.seriesGroups[o];\n      var g = n.series[l];\n\n      if (this._isPieGroup(o)) {\n        var c = this._getDataLen(o);\n\n        d = this._getItemColorFromScheme(g.colorScheme || n.colorScheme || this.colorScheme, l * c + b, o, l);\n      } else {\n        var m = 0;\n\n        for (var f = 0; f <= o; f++) {\n          for (var e in this.seriesGroups[f].series) {\n            if (f == o && e == l) {\n              break;\n            } else {\n              m++;\n            }\n          }\n        }\n\n        var k = this.colorScheme;\n\n        if (n.colorScheme) {\n          k = n.colorScheme;\n          var p = l;\n        }\n\n        if (k == undefined || k == \"\") {\n          k = this.colorSchemes[0].name;\n        }\n\n        if (!k) {\n          return d;\n        }\n\n        for (var f = 0; f < this.colorSchemes.length; f++) {\n          var h = this.colorSchemes[f];\n\n          if (h.name == k) {\n            while (m > h.colors.length) {\n              m -= h.colors.length;\n\n              if (++f >= this.colorSchemes.length) {\n                f = 0;\n              }\n\n              h = this.colorSchemes[f];\n            }\n\n            d = h.colors[m % h.colors.length];\n          }\n        }\n      }\n\n      return d;\n    },\n    _createColorsCache: function _createColorsCache() {\n      this._colorsCache = {\n        get: function get(b) {\n          if (this._store[b]) {\n            return this._store[b];\n          }\n        },\n        set: function set(c, b) {\n          if (this._size < 10000) {\n            this._store[c] = b;\n            this._size++;\n          }\n        },\n        clear: function clear() {\n          this._store = {};\n          this._size = 0;\n        },\n        _size: 0,\n        _store: {}\n      };\n    },\n    _getSeriesColorsInternal: function _getSeriesColorsInternal(m, d, b) {\n      var f = this.seriesGroups[m];\n      var o = f.series[d];\n\n      if (!a.isFunction(o.colorFunction) && f.type != \"pie\" && f.type != \"donut\") {\n        b = NaN;\n      }\n\n      var h = m + \"_\" + d + \"_\" + (isNaN(b) ? \"NaN\" : b);\n\n      if (this._colorsCache.get(h)) {\n        return this._colorsCache.get(h);\n      }\n\n      var c = {\n        lineColor: \"#222222\",\n        lineColorSelected: \"#151515\",\n        lineColorSymbol: \"#222222\",\n        lineColorSymbolSelected: \"#151515\",\n        fillColor: \"#222222\",\n        fillColorSelected: \"#333333\",\n        fillColorSymbol: \"#222222\",\n        fillColorSymbolSelected: \"#333333\",\n        fillColorAlt: \"#222222\",\n        fillColorAltSelected: \"#333333\"\n      };\n      var i;\n\n      if (a.isFunction(o.colorFunction)) {\n        var j = !isNaN(b) ? this._getDataValue(b, o.dataField, m) : NaN;\n\n        if (f.type.indexOf(\"range\") != -1 && !isNaN(b)) {\n          var e = this._getDataValue(b, o.dataFieldFrom, m);\n\n          var l = this._getDataValue(b, o.dataFieldTo, m);\n\n          j = {\n            from: e,\n            to: l\n          };\n        }\n\n        i = o.colorFunction(j, b, o, f);\n\n        if (typeof i == \"object\") {\n          for (var k in i) {\n            c[k] = i[k];\n          }\n        } else {\n          c.fillColor = i;\n        }\n      } else {\n        for (var k in c) {\n          if (o[k]) {\n            c[k] = o[k];\n          }\n        }\n\n        if (!o.fillColor && !o.color) {\n          c.fillColor = this._getColorFromScheme(m, d, b);\n        } else {\n          o.fillColor = o.fillColor || o.color;\n        }\n      }\n\n      var n = {\n        fillColor: {\n          baseColor: \"fillColor\",\n          adjust: 1\n        },\n        fillColorSelected: {\n          baseColor: \"fillColor\",\n          adjust: 1.1\n        },\n        fillColorSymbol: {\n          baseColor: \"fillColor\",\n          adjust: 1\n        },\n        fillColorSymbolSelected: {\n          baseColor: \"fillColorSymbol\",\n          adjust: 2\n        },\n        fillColorAlt: {\n          baseColor: \"fillColor\",\n          adjust: 4\n        },\n        fillColorAltSelected: {\n          baseColor: \"fillColor\",\n          adjust: 3\n        },\n        lineColor: {\n          baseColor: \"fillColor\",\n          adjust: 0.95\n        },\n        lineColorSelected: {\n          baseColor: \"lineColor\",\n          adjust: 0.95\n        },\n        lineColorSymbol: {\n          baseColor: \"lineColor\",\n          adjust: 1\n        },\n        lineColorSymbolSelected: {\n          baseColor: \"lineColorSelected\",\n          adjust: 1\n        }\n      };\n\n      for (var k in c) {\n        if (typeof i != \"object\" || !i[k]) {\n          if (o[k]) {\n            c[k] = o[k];\n          }\n        }\n      }\n\n      for (var k in c) {\n        if (typeof i != \"object\" || !i[k]) {\n          if (!o[k]) {\n            c[k] = a.jqx.adjustColor(c[n[k].baseColor], n[k].adjust);\n          }\n        }\n      }\n\n      this._colorsCache.set(h, c);\n\n      return c;\n    },\n    _getItemColorFromScheme: function _getItemColorFromScheme(d, f, k, h) {\n      if (d == undefined || d == \"\") {\n        d = this.colorSchemes[0].name;\n      }\n\n      for (var g = 0; g < this.colorSchemes.length; g++) {\n        if (d == this.colorSchemes[g].name) {\n          break;\n        }\n      }\n\n      var e = 0;\n\n      while (e <= f) {\n        if (g == this.colorSchemes.length) {\n          g = 0;\n        }\n\n        var b = this.colorSchemes[g].colors.length;\n\n        if (e + b <= f) {\n          e += b;\n          g++;\n        } else {\n          var c = this.colorSchemes[g].colors[f - e];\n\n          if (this._isGreyScale(k, h) && c.indexOf(\"#\") == 0) {\n            c = a.jqx.toGreyScale(c);\n          }\n\n          return c;\n        }\n      }\n    },\n    getColorScheme: function getColorScheme(b) {\n      for (var c = 0; c < this.colorSchemes.length; c++) {\n        if (this.colorSchemes[c].name == b) {\n          return this.colorSchemes[c].colors;\n        }\n      }\n\n      return undefined;\n    },\n    addColorScheme: function addColorScheme(c, b) {\n      for (var d = 0; d < this.colorSchemes.length; d++) {\n        if (this.colorSchemes[d].name == c) {\n          this.colorSchemes[d].colors = b;\n          return;\n        }\n      }\n\n      this.colorSchemes.push({\n        name: c,\n        colors: b\n      });\n    },\n    removeColorScheme: function removeColorScheme(b) {\n      for (var c = 0; c < this.colorSchemes.length; c++) {\n        if (this.colorSchemes[c].name == b) {\n          this.colorSchemes.splice(c, 1);\n          break;\n        }\n      }\n    },\n    colorSchemes: [{\n      name: \"scheme01\",\n      colors: [\"#307DD7\", \"#AA4643\", \"#89A54E\", \"#71588F\", \"#4198AF\"]\n    }, {\n      name: \"scheme02\",\n      colors: [\"#7FD13B\", \"#EA157A\", \"#FEB80A\", \"#00ADDC\", \"#738AC8\"]\n    }, {\n      name: \"scheme03\",\n      colors: [\"#E8601A\", \"#FF9639\", \"#F5BD6A\", \"#599994\", \"#115D6E\"]\n    }, {\n      name: \"scheme04\",\n      colors: [\"#D02841\", \"#FF7C41\", \"#FFC051\", \"#5B5F4D\", \"#364651\"]\n    }, {\n      name: \"scheme05\",\n      colors: [\"#25A0DA\", \"#309B46\", \"#8EBC00\", \"#FF7515\", \"#FFAE00\"]\n    }, {\n      name: \"scheme06\",\n      colors: [\"#0A3A4A\", \"#196674\", \"#33A6B2\", \"#9AC836\", \"#D0E64B\"]\n    }, {\n      name: \"scheme07\",\n      colors: [\"#CC6B32\", \"#FFAB48\", \"#FFE7AD\", \"#A7C9AE\", \"#888A63\"]\n    }, {\n      name: \"scheme08\",\n      colors: [\"#3F3943\", \"#01A2A6\", \"#29D9C2\", \"#BDF271\", \"#FFFFA6\"]\n    }, {\n      name: \"scheme09\",\n      colors: [\"#1B2B32\", \"#37646F\", \"#A3ABAF\", \"#E1E7E8\", \"#B22E2F\"]\n    }, {\n      name: \"scheme10\",\n      colors: [\"#5A4B53\", \"#9C3C58\", \"#DE2B5B\", \"#D86A41\", \"#D2A825\"]\n    }, {\n      name: \"scheme11\",\n      colors: [\"#993144\", \"#FFA257\", \"#CCA56A\", \"#ADA072\", \"#949681\"]\n    }, {\n      name: \"scheme12\",\n      colors: [\"#105B63\", \"#EEEAC5\", \"#FFD34E\", \"#DB9E36\", \"#BD4932\"]\n    }, {\n      name: \"scheme13\",\n      colors: [\"#BBEBBC\", \"#F0EE94\", \"#F5C465\", \"#FA7642\", \"#FF1E54\"]\n    }, {\n      name: \"scheme14\",\n      colors: [\"#60573E\", \"#F2EEAC\", \"#BFA575\", \"#A63841\", \"#BFB8A3\"]\n    }, {\n      name: \"scheme15\",\n      colors: [\"#444546\", \"#FFBB6E\", \"#F28D00\", \"#D94F00\", \"#7F203B\"]\n    }, {\n      name: \"scheme16\",\n      colors: [\"#583C39\", \"#674E49\", \"#948658\", \"#F0E99A\", \"#564E49\"]\n    }, {\n      name: \"scheme17\",\n      colors: [\"#142D58\", \"#447F6E\", \"#E1B65B\", \"#C8782A\", \"#9E3E17\"]\n    }, {\n      name: \"scheme18\",\n      colors: [\"#4D2B1F\", \"#635D61\", \"#7992A2\", \"#97BFD5\", \"#BFDCF5\"]\n    }, {\n      name: \"scheme19\",\n      colors: [\"#844341\", \"#D5CC92\", \"#BBA146\", \"#897B26\", \"#55591C\"]\n    }, {\n      name: \"scheme20\",\n      colors: [\"#56626B\", \"#6C9380\", \"#C0CA55\", \"#F07C6C\", \"#AD5472\"]\n    }, {\n      name: \"scheme21\",\n      colors: [\"#96003A\", \"#FF7347\", \"#FFBC7B\", \"#FF4154\", \"#642223\"]\n    }, {\n      name: \"scheme22\",\n      colors: [\"#5D7359\", \"#E0D697\", \"#D6AA5C\", \"#8C5430\", \"#661C0E\"]\n    }, {\n      name: \"scheme23\",\n      colors: [\"#16193B\", \"#35478C\", \"#4E7AC7\", \"#7FB2F0\", \"#ADD5F7\"]\n    }, {\n      name: \"scheme24\",\n      colors: [\"#7B1A25\", \"#BF5322\", \"#9DA860\", \"#CEA457\", \"#B67818\"]\n    }, {\n      name: \"scheme25\",\n      colors: [\"#0081DA\", \"#3AAFFF\", \"#99C900\", \"#FFEB3D\", \"#309B46\"]\n    }, {\n      name: \"scheme26\",\n      colors: [\"#0069A5\", \"#0098EE\", \"#7BD2F6\", \"#FFB800\", \"#FF6800\"]\n    }, {\n      name: \"scheme27\",\n      colors: [\"#FF6800\", \"#A0A700\", \"#FF8D00\", \"#678900\", \"#0069A5\"]\n    }],\n    _formatValue: function _formatValue(g, i, c, f, b, d) {\n      if (g == undefined) {\n        return \"\";\n      }\n\n      if (this._isObject(g) && !this._isDate(g) && !c) {\n        return \"\";\n      }\n\n      if (c) {\n        if (!a.isFunction(c)) {\n          return g.toString();\n        }\n\n        try {\n          return c(g, d, b, f);\n        } catch (h) {\n          return h.message;\n        }\n      }\n\n      if (this._isNumber(g)) {\n        return this._formatNumber(g, i);\n      }\n\n      if (this._isDate(g)) {\n        return this._formatDate(g, i);\n      }\n\n      if (i) {\n        return (i.prefix || \"\") + g.toString() + (i.sufix || \"\");\n      }\n\n      return g.toString();\n    },\n    _getFormattedValue: function _getFormattedValue(f, h, y, p, d, l) {\n      var w = this.seriesGroups[f];\n      var n = w.series[h];\n      var m = \"\";\n      var j = p,\n          k = d;\n\n      if (!k) {\n        k = n.formatFunction || w.formatFunction;\n      }\n\n      if (!j) {\n        j = n.formatSettings || w.formatSettings;\n      }\n\n      if (!n.formatFunction && n.formatSettings) {\n        k = undefined;\n      }\n\n      var o = {},\n          t = 0;\n\n      for (var b in n) {\n        if (b.indexOf(\"dataField\") == 0) {\n          o[b.substring(9).toLowerCase()] = this._getDataValue(y, n[b], f);\n          t++;\n        }\n      }\n\n      if (t == 0) {\n        o = this._getDataValue(y, undefined, f);\n      }\n\n      if (w.type.indexOf(\"waterfall\") != -1 && this._isSummary(f, y)) {\n        o = this._renderData[f].offsets[h][y].value;\n        t = 0;\n      }\n\n      if (k && a.isFunction(k)) {\n        try {\n          return k(t == 1 ? o[\"\"] : o, y, n, w);\n        } catch (x) {\n          return x.message;\n        }\n      }\n\n      if (t == 1 && this._isPieGroup(f)) {\n        return this._formatValue(o[\"\"], j, k, f, h, y);\n      }\n\n      if (t > 0) {\n        var u = 0;\n\n        for (var b in o) {\n          if (u > 0 && m != \"\") {\n            m += \"<br>\";\n          }\n\n          var r = \"dataField\" + (b.length > 0 ? b.substring(0, 1).toUpperCase() + b.substring(1) : \"\");\n          var q = \"displayText\" + (b.length > 0 ? b.substring(0, 1).toUpperCase() + b.substring(1) : \"\");\n          var v = n[q] || n[r];\n          var c = o[b];\n\n          if (undefined != c) {\n            c = this._formatValue(c, j, k, f, h, y);\n          } else {\n            continue;\n          }\n\n          if (l === true) {\n            m += c;\n          } else {\n            m += v + \": \" + c;\n          }\n\n          u++;\n        }\n      } else {\n        if (undefined != o) {\n          m = this._formatValue(o, j, k, f, h, y);\n        }\n      }\n\n      return m || \"\";\n    },\n    _isNumberAsString: function _isNumberAsString(d) {\n      if (typeof d != \"string\") {\n        return false;\n      }\n\n      d = a.trim(d);\n\n      for (var b = 0; b < d.length; b++) {\n        var c = d.charAt(b);\n\n        if (c >= \"0\" && c <= \"9\" || c == \",\" || c == \".\") {\n          continue;\n        }\n\n        if (c == \"-\" && b == 0) {\n          continue;\n        }\n\n        if (c == \"(\" && b == 0 || c == \")\" && b == d.length - 1) {\n          continue;\n        }\n\n        return false;\n      }\n\n      return true;\n    },\n    _castAsDate: function _castAsDate(f, c) {\n      if (f instanceof Date && !isNaN(f)) {\n        return f;\n      }\n\n      if (typeof f == \"string\") {\n        var b;\n\n        if (c) {\n          b = a.jqx.dataFormat.parsedate(f, c);\n\n          if (this._isDate(b)) {\n            return b;\n          }\n        }\n\n        if (this._autoDateFormats) {\n          for (var e = 0; e < this._autoDateFormats.length; e++) {\n            b = a.jqx.dataFormat.parsedate(f, this._autoDateFormats[e]);\n\n            if (this._isDate(b)) {\n              return b;\n            }\n          }\n        }\n\n        var d = this._detectDateFormat(f);\n\n        if (d) {\n          b = a.jqx.dataFormat.parsedate(f, d);\n\n          if (this._isDate(b)) {\n            this._autoDateFormats.push(d);\n\n            return b;\n          }\n        }\n\n        b = new Date(f);\n\n        if (this._isDate(b)) {\n          if (f.indexOf(\":\") == -1) {\n            b.setHours(0, 0, 0, 0);\n          }\n        }\n\n        return b;\n      }\n\n      return undefined;\n    },\n    _castAsNumber: function _castAsNumber(c) {\n      if (c instanceof Date && !isNaN(c)) {\n        return c.valueOf();\n      }\n\n      if (typeof c == \"string\") {\n        if (this._isNumber(c)) {\n          c = parseFloat(c);\n        } else {\n          if (!/[a-zA-Z]/.test(c)) {\n            var b = new Date(c);\n\n            if (b != undefined) {\n              c = b.valueOf();\n            }\n          }\n        }\n      }\n\n      return c;\n    },\n    _isNumber: function _isNumber(b) {\n      if (typeof b == \"string\") {\n        if (this._isNumberAsString(b)) {\n          b = parseFloat(b);\n        }\n      }\n\n      return typeof b === \"number\" && isFinite(b);\n    },\n    _isDate: function _isDate(b) {\n      return b instanceof Date && !isNaN(b.getDate());\n    },\n    _isBoolean: function _isBoolean(b) {\n      return typeof b === \"boolean\";\n    },\n    _isObject: function _isObject(b) {\n      return b && (typeof b === \"object\" || a.isFunction(b)) || false;\n    },\n    _formatDate: function _formatDate(d, c) {\n      var b = d.toString();\n\n      if (c) {\n        if (c.dateFormat) {\n          b = a.jqx.dataFormat.formatDate(d, c.dateFormat);\n        }\n\n        b = (c.prefix || \"\") + b + (c.sufix || \"\");\n      }\n\n      return b;\n    },\n    _formatNumber: function _formatNumber(n, e) {\n      if (!this._isNumber(n)) {\n        return n;\n      }\n\n      e = e || {};\n      var q = \".\";\n      var o = \"\";\n      var r = this;\n\n      if (r.localization) {\n        q = r.localization.decimalSeparator || r.localization.decimalseparator || q;\n        o = r.localization.thousandsSeparator || r.localization.thousandsseparator || o;\n      }\n\n      if (e.decimalSeparator) {\n        q = e.decimalSeparator;\n      }\n\n      if (e.thousandsSeparator) {\n        o = e.thousandsSeparator;\n      }\n\n      var m = e.prefix || \"\";\n      var p = e.sufix || \"\";\n      var h = e.decimalPlaces;\n\n      if (isNaN(h)) {\n        h = this._getDecimalPlaces([n], undefined, 3);\n      }\n\n      var l = e.negativeWithBrackets || false;\n      var g = n < 0;\n\n      if (g && l) {\n        n *= -1;\n      }\n\n      var d = n.toString();\n      var b;\n      var k = Math.pow(10, h);\n      d = (Math.round(n * k) / k).toString();\n\n      if (isNaN(d)) {\n        d = \"\";\n      }\n\n      b = d.lastIndexOf(\".\");\n\n      if (h > 0) {\n        if (b < 0) {\n          d += q;\n          b = d.length - 1;\n        } else {\n          if (q !== \".\") {\n            d = d.replace(\".\", q);\n          }\n        }\n\n        while (d.length - 1 - b < h) {\n          d += \"0\";\n        }\n      }\n\n      b = d.lastIndexOf(q);\n      b = b > -1 ? b : d.length;\n      var f = d.substring(b);\n      var c = 0;\n\n      for (var j = b; j > 0; j--, c++) {\n        if (c % 3 === 0 && j !== b && (!g || j > 1 || g && l)) {\n          f = o + f;\n        }\n\n        f = d.charAt(j - 1) + f;\n      }\n\n      d = f;\n\n      if (g && l) {\n        d = \"(\" + d + \")\";\n      }\n\n      return m + d + p;\n    },\n    _defaultNumberFormat: {\n      prefix: \"\",\n      sufix: \"\",\n      decimalSeparator: \".\",\n      thousandsSeparator: \",\",\n      decimalPlaces: 2,\n      negativeWithBrackets: false\n    },\n    _calculateControlPoints: function _calculateControlPoints(g, f) {\n      var e = g[f],\n          m = g[f + 1],\n          d = g[f + 2],\n          j = g[f + 3],\n          c = g[f + 4],\n          i = g[f + 5];\n      var l = 0.4;\n      var o = Math.sqrt(Math.pow(d - e, 2) + Math.pow(j - m, 2));\n      var b = Math.sqrt(Math.pow(c - d, 2) + Math.pow(i - j, 2));\n      var h = o + b;\n\n      if (h == 0) {\n        h = 1;\n      }\n\n      var n = l * o / h;\n      var k = l - n;\n      return [d + n * (e - c), j + n * (m - i), d - k * (e - c), j - k * (m - i)];\n    },\n    _getBezierPoints: function _getBezierPoints(d) {\n      var c = \"\";\n      var h = [],\n          e = [];\n      var g = d.split(\" \");\n\n      for (var f = 0; f < g.length; f++) {\n        var j = g[f].split(\",\");\n        h.push(parseFloat(j[0]));\n        h.push(parseFloat(j[1]));\n\n        if (isNaN(h[h.length - 1]) || isNaN(h[h.length - 2])) {\n          continue;\n        }\n      }\n\n      var b = h.length;\n\n      if (b <= 1) {\n        return \"\";\n      } else {\n        if (b == 2) {\n          c = \"M\" + a.jqx._ptrnd(h[0]) + \",\" + a.jqx._ptrnd(h[1]) + \" L\" + a.jqx._ptrnd(h[0] + 1) + \",\" + a.jqx._ptrnd(h[1] + 1) + \" \";\n          return c;\n        }\n      }\n\n      for (var f = 0; f < b - 4; f += 2) {\n        e = e.concat(this._calculateControlPoints(h, f));\n      }\n\n      for (var f = 2; f < b - 5; f += 2) {\n        c += \" C\" + a.jqx._ptrnd(e[2 * f - 2]) + \",\" + a.jqx._ptrnd(e[2 * f - 1]) + \" \" + a.jqx._ptrnd(e[2 * f]) + \",\" + a.jqx._ptrnd(e[2 * f + 1]) + \" \" + a.jqx._ptrnd(h[f + 2]) + \",\" + a.jqx._ptrnd(h[f + 3]) + \" \";\n      }\n\n      if (b <= 4 || Math.abs(h[0] - h[2]) < 3 || Math.abs(h[1] - h[3]) < 3 || this._isVML) {\n        c = \"M\" + a.jqx._ptrnd(h[0]) + \",\" + a.jqx._ptrnd(h[1]) + \" L\" + a.jqx._ptrnd(h[2]) + \",\" + a.jqx._ptrnd(h[3]) + \" \" + c;\n      } else {\n        c = \"M\" + a.jqx._ptrnd(h[0]) + \",\" + a.jqx._ptrnd(h[1]) + \" Q\" + a.jqx._ptrnd(e[0]) + \",\" + a.jqx._ptrnd(e[1]) + \" \" + a.jqx._ptrnd(h[2]) + \",\" + a.jqx._ptrnd(h[3]) + \" \" + c;\n      }\n\n      if (b >= 4 && (Math.abs(h[b - 2] - h[b - 4]) < 3 || Math.abs(h[b - 1] - h[b - 3]) < 3 || this._isVML)) {\n        c += \" L\" + a.jqx._ptrnd(h[b - 2]) + \",\" + a.jqx._ptrnd(h[b - 1]) + \" \";\n      } else {\n        if (b >= 5) {\n          c += \" Q\" + a.jqx._ptrnd(e[b * 2 - 10]) + \",\" + a.jqx._ptrnd(e[b * 2 - 9]) + \" \" + a.jqx._ptrnd(h[b - 2]) + \",\" + a.jqx._ptrnd(h[b - 1]) + \" \";\n        }\n      }\n\n      return c;\n    },\n    _animTickInt: 50,\n    _createAnimationGroup: function _createAnimationGroup(b) {\n      if (!this._animGroups) {\n        this._animGroups = {};\n      }\n\n      this._animGroups[b] = {\n        animations: [],\n        startTick: NaN\n      };\n    },\n    _startAnimation: function _startAnimation(c) {\n      var e = new Date();\n      var b = e.getTime();\n      this._animGroups[c].startTick = b;\n\n      this._runAnimation();\n\n      this._enableAnimTimer();\n    },\n    _enqueueAnimation: function _enqueueAnimation(e, d, c, g, f, b, h) {\n      if (g < 0) {\n        g = 0;\n      }\n\n      if (h == undefined) {\n        h = \"easeInOutSine\";\n      }\n\n      this._animGroups[e].animations.push({\n        key: d,\n        properties: c,\n        duration: g,\n        fn: f,\n        context: b,\n        easing: h\n      });\n    },\n    _stopAnimations: function _stopAnimations() {\n      clearTimeout(this._animtimer);\n      this._animtimer = undefined;\n      this._animGroups = undefined;\n    },\n    _enableAnimTimer: function _enableAnimTimer() {\n      if (!this._animtimer) {\n        var b = this;\n        this._animtimer = setTimeout(function () {\n          b._runAnimation();\n        }, this._animTickInt);\n      }\n    },\n    _runAnimation: function _runAnimation(q) {\n      if (this._animGroups) {\n        var t = new Date();\n        var h = t.getTime();\n        var o = {};\n\n        for (var l in this._animGroups) {\n          var s = this._animGroups[l].animations;\n          var m = this._animGroups[l].startTick;\n          var g = 0;\n\n          for (var n = 0; n < s.length; n++) {\n            var u = s[n];\n            var b = h - m;\n\n            if (u.duration > g) {\n              g = u.duration;\n            }\n\n            var r = u.duration > 0 ? b / u.duration : 1;\n            var k = r;\n\n            if (u.easing && u.duration != 0) {\n              k = a.easing[u.easing](r, b, 0, 1, u.duration);\n            }\n\n            if (r > 1) {\n              r = 1;\n              k = 1;\n            }\n\n            if (u.fn) {\n              u.fn(u.key, u.context, k);\n              continue;\n            }\n\n            var f = {};\n\n            for (var l = 0; l < u.properties.length; l++) {\n              var c = u.properties[l];\n              var e = 0;\n\n              if (r == 1) {\n                e = c.to;\n              } else {\n                e = k * (c.to - c.from) + c.from;\n              }\n\n              f[c.key] = e;\n            }\n\n            this.renderer.attr(u.key, f);\n          }\n\n          if (m + g > h) {\n            o[l] = {\n              startTick: m,\n              animations: s\n            };\n          }\n        }\n\n        this._animGroups = o;\n\n        if (this.renderer instanceof a.jqx.HTML5Renderer) {\n          this.renderer.refresh();\n        }\n      }\n\n      this._animtimer = null;\n\n      for (var l in this._animGroups) {\n        this._enableAnimTimer();\n\n        break;\n      }\n    },\n    _fixCoords: function _fixCoords(d, e) {\n      var b = this.seriesGroups[e].orientation == \"horizontal\";\n\n      if (!b) {\n        return d;\n      }\n\n      var c = d.x;\n      d.x = d.y;\n      d.y = c + this._plotRect.y - this._plotRect.x;\n      var c = d.width;\n      d.width = d.height;\n      d.height = c;\n      return d;\n    },\n    getItemCoord: function getItemCoord(d, f, A) {\n      var n = this;\n\n      if (n._isPieGroup(d) && (!n._isSerieVisible(d, f, A) || !n._renderData || n._renderData.length <= d)) {\n        return {\n          x: NaN,\n          y: NaN\n        };\n      }\n\n      if (!n._isSerieVisible(d, f) || !n._renderData || n._renderData.length <= d) {\n        return {\n          x: NaN,\n          y: NaN\n        };\n      }\n\n      var u = n.seriesGroups[d];\n      var l = u.series[f];\n\n      var q = n._getItemCoord(d, f, A);\n\n      if (n._isPieGroup(d)) {\n        if (isNaN(q.x) || isNaN(q.y) || isNaN(q.fromAngle) || isNaN(q.toAngle)) {\n          return {\n            x: NaN,\n            y: NaN\n          };\n        }\n\n        var k = this._plotRect;\n        var r = q.fromAngle * (Math.PI / 180);\n        var h = q.toAngle * (Math.PI / 180);\n        var v = k.x + q.center.x + Math.cos(r) * q.outerRadius;\n        var t = k.x + q.center.x + Math.cos(h) * q.outerRadius;\n        var c = k.y + q.center.y - Math.sin(r) * q.outerRadius;\n        var b = k.y + q.center.y - Math.sin(h) * q.outerRadius;\n        var j = Math.min(v, t);\n        var o = Math.abs(t - v);\n        var i = Math.min(c, b);\n        var m = Math.abs(b - c);\n        q = {\n          x: j,\n          y: i,\n          width: o,\n          height: m,\n          center: q.center,\n          centerOffset: q.centerOffset,\n          innerRadius: q.innerRadius,\n          outerRadius: q.outerRadius,\n          selectedRadiusChange: q.selectedRadiusChange,\n          fromAngle: q.fromAngle,\n          toAngle: q.toAngle\n        };\n        return q;\n      }\n\n      if (u.type.indexOf(\"column\") != -1 || u.type.indexOf(\"waterfall\") != -1) {\n        var B = this._getColumnSerieWidthAndOffset(d, f);\n\n        q.height = Math.abs(q.y.to - q.y.from);\n        q.y = Math.min(q.y.to, q.y.from);\n        q.x += B.offset;\n        q.width = B.width;\n      } else {\n        if (u.type.indexOf(\"ohlc\") != -1 || u.type.indexOf(\"candlestick\") != -1) {\n          var B = this._getColumnSerieWidthAndOffset(d, f);\n\n          var i = q.y;\n          var z = Math.min(i.Open, i.Close, i.Low, i.High);\n          var w = Math.max(i.Open, i.Close, i.Low, i.High);\n          q.height = Math.abs(w - z);\n          q.y = z;\n          q.x += B.offset;\n          q.width = B.width;\n        } else {\n          if (u.type.indexOf(\"line\") != -1 || u.type.indexOf(\"area\") != -1) {\n            q.width = q.height = 0;\n            q.y = q.y.to;\n          } else {\n            if (u.type.indexOf(\"bubble\") != -1 || u.type.indexOf(\"scatter\") != -1) {\n              q.center = {\n                x: q.x,\n                y: q.y.to\n              };\n              var e = q.y.radius;\n\n              if (l.symbolType != \"circle\" && l.symbolType != undefined) {\n                e /= 2;\n              }\n\n              q.y = q.y.to;\n              q.radius = e;\n              q.width = 2 * e;\n              q.height = 2 * e;\n            }\n          }\n        }\n      }\n\n      q = this._fixCoords(q, d);\n\n      if (u.polar || u.spider) {\n        var p = this._toPolarCoord(this._renderData[d].polarCoords, this._plotRect, q.x, q.y);\n\n        q.x = p.x;\n        q.y = p.y;\n\n        if (q.center) {\n          q.center = this._toPolarCoord(this._renderData[d].polarCoords, this._plotRect, q.center.x, q.center.y);\n        }\n      }\n\n      if (u.type.indexOf(\"bubble\") != -1 || u.type.indexOf(\"scatter\") != -1) {\n        q.x -= e;\n        q.y -= e;\n      }\n\n      return q;\n    },\n    _getItemCoord: function _getItemCoord(o, j, b) {\n      var e = this.seriesGroups[o],\n          l,\n          k;\n\n      if (!e || !this._renderData) {\n        return {\n          x: NaN,\n          y: NaN\n        };\n      }\n\n      var f = e.series[j];\n\n      if (!f) {\n        return {\n          x: NaN,\n          y: NaN\n        };\n      }\n\n      var h = this._plotRect;\n\n      if (this._isPieGroup(o)) {\n        var m = this._renderData[o].offsets[j][b];\n\n        if (!m) {\n          return {\n            x: NaN,\n            y: NaN\n          };\n        }\n\n        var c = (m.fromAngle + m.toAngle) / 2 * (Math.PI / 180);\n        l = h.x + m.x + Math.cos(c) * m.outerRadius;\n        k = h.y + m.y - Math.sin(c) * m.outerRadius;\n        return {\n          x: l,\n          y: k,\n          center: {\n            x: m.x,\n            y: m.y\n          },\n          centerOffset: m.centerOffset,\n          innerRadius: m.innerRadius,\n          outerRadius: m.outerRadius,\n          selectedRadiusChange: m.selectedRadiusChange,\n          fromAngle: m.fromAngle,\n          toAngle: m.toAngle\n        };\n      } else {\n        l = h.x + this._renderData[o].xoffsets.data[b];\n        k = this._renderData[o].offsets[j][b];\n\n        if (isNaN(l) || !k) {\n          return {\n            x: NaN,\n            y: NaN\n          };\n        }\n      }\n\n      var n = {};\n\n      for (var d in k) {\n        n[d] = k[d];\n      }\n\n      return {\n        x: l,\n        y: n\n      };\n    },\n    getXAxisValue: function getXAxisValue(g, r) {\n      var q = this.seriesGroups[r];\n\n      if (!q) {\n        return undefined;\n      }\n\n      var c = this._getXAxis(r);\n\n      var n = this._plotRect;\n      var b = 0;\n      var m = NaN;\n      var e = this._renderData[0].xoffsets.axisStats;\n      var f = 0,\n          l = 0;\n\n      if (q.polar || q.spider) {\n        if (isNaN(g.x) || isNaN(g.y)) {\n          return NaN;\n        }\n\n        var h = this._getPolarAxisCoords(r, n);\n\n        var k = a.jqx._ptdist(g.x, g.y, h.x, h.y);\n\n        if (k > h.r) {\n          return NaN;\n        }\n\n        var i = Math.atan2(h.y - g.y, g.x - h.x);\n        i = Math.PI / 2 - i;\n\n        if (i < 0) {\n          i = 2 * Math.PI + i;\n        }\n\n        m = i * h.r;\n        var j = h.startAngle + Math.PI / 2;\n        var d = h.endAngle + Math.PI / 2;\n        f = j * h.r;\n        l = d * h.r;\n        b = (d - j) * h.r;\n\n        var o = this._getPaddingSize(e, c, c.valuesOnTicks, b, true, h.isClosedCircle, this._hasColumnSeries());\n\n        if (h.isClosedCircle) {\n          b -= o.left + o.right;\n          l -= o.left + o.right;\n        } else {\n          if (!c.valuesOnTicks) {\n            f += o.left;\n            l -= o.right;\n          }\n        }\n      } else {\n        if (q.orientation != \"horizontal\") {\n          if (g < n.x || g > n.x + n.width) {\n            return NaN;\n          }\n\n          m = g - n.x;\n          b = n.width;\n        } else {\n          if (g < n.y || g > n.y + n.height) {\n            return NaN;\n          }\n\n          m = g - n.y;\n          b = n.height;\n        }\n\n        if (this._renderData[r] && this._renderData[r].xoffsets) {\n          var o = this._renderData[r].xoffsets.padding;\n          b -= o.left + o.right;\n          m -= o.left;\n        }\n\n        l = b;\n      }\n\n      var p = this._jqxPlot.scale(m, {\n        min: f,\n        max: l\n      }, {\n        min: e.min.valueOf(),\n        max: e.max.valueOf(),\n        type: e.logAxis.enabled ? \"logarithmic\" : \"linear\",\n        base: e.logAxis.base,\n        flip: c.flip\n      });\n\n      return p;\n    },\n    getValueAxisValue: function getValueAxisValue(c, j) {\n      var i = this.seriesGroups[j];\n\n      if (!i) {\n        return undefined;\n      }\n\n      var k = this._getValueAxis(j);\n\n      var g = this._plotRect;\n      var b = 0;\n      var f = NaN;\n\n      if (i.polar || i.spider) {\n        if (isNaN(c.x) || isNaN(c.y)) {\n          return NaN;\n        }\n\n        var e = this._getPolarAxisCoords(j, g);\n\n        f = a.jqx._ptdist(c.x, c.y, e.x, e.y);\n        b = e.r;\n        f = b - f;\n      } else {\n        if (i.orientation == \"horizontal\") {\n          if (c < g.x || c > g.x + g.width) {\n            return NaN;\n          }\n\n          f = c - g.x;\n          b = g.width;\n        } else {\n          if (c < g.y || c > g.y + g.height) {\n            return NaN;\n          }\n\n          f = c - g.y;\n          b = g.height;\n        }\n      }\n\n      var d = this._stats.seriesGroups[j];\n\n      var h = this._jqxPlot.scale(f, {\n        min: 0,\n        max: b\n      }, {\n        min: d.min.valueOf(),\n        max: d.max.valueOf(),\n        type: d.logarithmic ? \"logarithmic\" : \"linear\",\n        base: d.logBase,\n        flip: !k.flip\n      });\n\n      return h;\n    },\n    _detectDateFormat: function _detectDateFormat(g, c) {\n      var h = {\n        en_US_d: \"M/d/yyyy\",\n        en_US_D: \"dddd, MMMM dd, yyyy\",\n        en_US_t: \"h:mm tt\",\n        en_US_T: \"h:mm:ss tt\",\n        en_US_f: \"dddd, MMMM dd, yyyy h:mm tt\",\n        en_US_F: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\n        en_US_M: \"MMMM dd\",\n        en_US_Y: \"yyyy MMMM\",\n        en_US_S: \"yyyy'-'MM'-'dd'T'HH':'mm':'ss\",\n        en_CA_d: \"dd/MM/yyyy\",\n        en_CA_D: \"MMMM-dd-yy\",\n        en_CA_f: \"MMMM-dd-yy h:mm tt\",\n        en_CA_F: \"MMMM-dd-yy h:mm:ss tt\",\n        ISO: \"yyyy-MM-dd hh:mm:ss\",\n        ISO2: \"yyyy-MM-dd HH:mm:ss\",\n        d1: \"dd.MM.yyyy\",\n        d2: \"dd-MM-yyyy\",\n        zone1: \"yyyy-MM-ddTHH:mm:ss-HH:mm\",\n        zone2: \"yyyy-MM-ddTHH:mm:ss+HH:mm\",\n        custom: \"yyyy-MM-ddTHH:mm:ss.fff\",\n        custom2: \"yyyy-MM-dd HH:mm:ss.fff\",\n        de_DE_d: \"dd.MM.yyyy\",\n        de_DE_D: \"dddd, d. MMMM yyyy\",\n        de_DE_t: \"HH:mm\",\n        de_DE_T: \"HH:mm:ss\",\n        de_DE_f: \"dddd, d. MMMM yyyy HH:mm\",\n        de_DE_F: \"dddd, d. MMMM yyyy HH:mm:ss\",\n        de_DE_M: \"dd MMMM\",\n        de_DE_Y: \"MMMM yyyy\",\n        fr_FR_d: \"dd/MM/yyyy\",\n        fr_FR_D: \"dddd d MMMM yyyy\",\n        fr_FR_t: \"HH:mm\",\n        fr_FR_T: \"HH:mm:ss\",\n        fr_FR_f: \"dddd d MMMM yyyy HH:mm\",\n        fr_FR_F: \"dddd d MMMM yyyy HH:mm:ss\",\n        fr_FR_M: \"d MMMM\",\n        fr_FR_Y: \"MMMM yyyy\",\n        it_IT_d: \"dd/MM/yyyy\",\n        it_IT_D: \"dddd d MMMM yyyy\",\n        it_IT_t: \"HH:mm\",\n        it_IT_T: \"HH:mm:ss\",\n        it_IT_f: \"dddd d MMMM yyyy HH:mm\",\n        it_IT_F: \"dddd d MMMM yyyy HH:mm:ss\",\n        it_IT_M: \"dd MMMM\",\n        it_IT_Y: \"MMMM yyyy\",\n        ru_RU_d: \"dd.MM.yyyy\",\n        ru_RU_D: \"d MMMM yyyy '?.'\",\n        ru_RU_t: \"H:mm\",\n        ru_RU_T: \"H:mm:ss\",\n        ru_RU_f: \"d MMMM yyyy '?.' H:mm\",\n        ru_RU_F: \"d MMMM yyyy '?.' H:mm:ss\",\n        ru_RU_Y: \"MMMM yyyy\",\n        cs_CZ_d: \"d.M.yyyy\",\n        cs_CZ_D: \"d. MMMM yyyy\",\n        cs_CZ_t: \"H:mm\",\n        cs_CZ_T: \"H:mm:ss\",\n        cs_CZ_f: \"d. MMMM yyyy H:mm\",\n        cs_CZ_F: \"d. MMMM yyyy H:mm:ss\",\n        cs_CZ_M: \"dd MMMM\",\n        cs_CZ_Y: \"MMMM yyyy\",\n        he_IL_d: \"dd MMMM yyyy\",\n        he_IL_D: \"dddd dd MMMM yyyy\",\n        he_IL_t: \"HH:mm\",\n        he_IL_T: \"HH:mm:ss\",\n        he_IL_f: \"dddd dd MMMM yyyy HH:mm\",\n        he_IL_F: \"dddd dd MMMM yyyy HH:mm:ss\",\n        he_IL_M: \"dd MMMM\",\n        he_IL_Y: \"MMMM yyyy\",\n        hr_HR_d: \"d.M.yyyy.\",\n        hr_HR_D: \"d. MMMM yyyy.\",\n        hr_HR_t: \"H:mm\",\n        hr_HR_T: \"H:mm:ss\",\n        hr_HR_f: \"d. MMMM yyyy. H:mm\",\n        hr_HR_F: \"d. MMMM yyyy. H:mm:ss\",\n        hr_HR_M: \"d. MMMM\",\n        hu_HU_d: \"yyyy.MM.dd.\",\n        hu_HU_D: \"yyyy. MMMM d.\",\n        hu_HU_t: \"H:mm\",\n        hu_HU_T: \"H:mm:ss\",\n        hu_HU_f: \"yyyy. MMMM d. H:mm\",\n        hu_HU_F: \"yyyy. MMMM d. H:mm:ss\",\n        hu_HU_M: \"MMMM d.\",\n        hu_HU_Y: \"yyyy. MMMM\",\n        jp_JP_d: \"gg y/M/d\",\n        jp_JP_D: \"gg y'?'M'?'d'?'\",\n        jp_JP_t: \"H:mm\",\n        jp_JP_T: \"H:mm:ss\",\n        jp_JP_f: \"gg y'?'M'?'d'?' H:mm\",\n        jp_JP_F: \"gg y'?'M'?'d'?' H:mm:ss\",\n        jp_JP_M: \"M'?'d'?'\",\n        jp_JP_Y: \"gg y'?'M'?'\",\n        lt_LT_d: \"yyyy.MM.dd\",\n        lt_LT_D: \"yyyy 'm.' MMMM d 'd.'\",\n        lt_LT_t: \"HH:mm\",\n        lt_LT_T: \"HH:mm:ss\",\n        lt_LT_f: \"yyyy 'm.' MMMM d 'd.' HH:mm\",\n        lt_LT_F: \"yyyy 'm.' MMMM d 'd.' HH:mm:ss\",\n        lt_LT_M: \"MMMM d 'd.'\",\n        lt_LT_Y: \"yyyy 'm.' MMMM\",\n        sa_IN_d: \"dd-MM-yyyy\",\n        sa_IN_D: \"dd MMMM yyyy dddd\",\n        sa_IN_t: \"HH:mm\",\n        sa_IN_T: \"HH:mm:ss\",\n        sa_IN_f: \"dd MMMM yyyy dddd HH:mm\",\n        sa_IN_F: \"dd MMMM yyyy dddd HH:mm:ss\",\n        sa_IN_M: \"dd MMMM\",\n        basic_y: \"yyyy\",\n        basic_ym: \"yyyy-MM\",\n        basic_d: \"yyyy-MM-dd\",\n        basic_dhm: \"yyyy-MM-dd hh:mm\",\n        basic_bhms: \"yyyy-MM-dd hh:mm:ss\",\n        basic2_ym: \"MM-yyyy\",\n        basic2_d: \"MM-dd-yyyy\",\n        basic2_dhm: \"MM-dd-yyyy hh:mm\",\n        basic2_dhms: \"MM-dd-yyyy hh:mm:ss\",\n        basic3_ym: \"yyyy/MM\",\n        basic3_d: \"yyyy/MM/dd\",\n        basic3_dhm: \"yyyy/MM/dd hh:mm\",\n        basic3_bhms: \"yyyy/MM/dd hh:mm:ss\",\n        basic4_ym: \"MM/yyyy\",\n        basic4_d: \"MM/dd/yyyy\",\n        basic4_dhm: \"MM/dd/yyyy hh:mm\",\n        basic4_dhms: \"MM/dd/yyyy hh:mm:ss\"\n      };\n\n      if (c) {\n        h = a.extend({}, h, c);\n      }\n\n      var f = [];\n\n      if (!a.isArray(g)) {\n        f.push(g);\n      } else {\n        f = g;\n      }\n\n      for (var d in h) {\n        h[d] = {\n          format: h[d],\n          count: 0\n        };\n      }\n\n      for (var e = 0; e < f.length; e++) {\n        var k = f[e];\n\n        if (k == null || k == undefined) {\n          continue;\n        }\n\n        for (var d in h) {\n          var l = a.jqx.dataFormat.parsedate(k, h[d].format);\n\n          if (l != null) {\n            h[d].count++;\n          }\n        }\n      }\n\n      var b = {\n        key: undefined,\n        count: 0\n      };\n\n      for (var d in h) {\n        if (h[d].count > b.count) {\n          b.key = d;\n          b.count = h[d].count;\n        }\n      }\n\n      return b.key ? h[b.key].format : \"\";\n    },\n    _testXAxisDateFormat: function _testXAxisDateFormat(j) {\n      var l = this;\n\n      var d = l._getXAxis(j);\n\n      var c = l._getDataLen(j);\n\n      var e = {};\n\n      if (l.localization && l.localization.patterns) {\n        for (var k in l.localization.patterns) {\n          e[\"local_\" + k] = l.localization.patterns[k];\n        }\n      }\n\n      var g = [];\n\n      for (var f = 0; f < c && f < 10; f++) {\n        var h = l._getDataValue(f, d.dataField, j);\n\n        if (h == null || h == undefined) {\n          continue;\n        }\n\n        g.push(h);\n      }\n\n      var b = l._detectDateFormat(g, e);\n\n      return b;\n    }\n  });\n})(jqxBaseFramework);","map":null,"metadata":{},"sourceType":"script"}